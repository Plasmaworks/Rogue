#$ ROGUEC       = roguec
#$ ROGUEC_ARGS  = --whatever
#$ CPP          = g++ -Wall -std=gnu++11 -fno-strict-aliasing -Wno-invalid-offsetof
#$ CPP_ARGS     = -a -b -c
#$ LINK         = true              # Links following LIBRARIES with this Build file
#$ LINK         = -lalpha -lbeta    # Links following LIBRARIES and includes these additional flags
#$ LINK         = false             # Linking turned off for following LIBRARIES
#$ LIBRARIES    = libalpha
#$ LIBRARIES    = libbeta(library-name)
#$ LIBRARIES    = libfreetype6-dev(freetype2)
#$ DEPENDENCIES = Library/Rogue/**/*.rogue

#$ LIBRARIES    = name(package)
#$ LIBRARIES    = name(package:<package> install:<install-cmd> link:<link-flags> which:<which-name>)

# Build.rogue source replacements - the libraries should also be declared in #$ LIBRARIES:
#   $LIBRARY_FLAGS(lib1,lib2) -> -Ipath/to/lib1/include -Lpath/to/lib1/library -I ...

# Command Line Option
#
# --build=<filepath>
#   Compiles and runs the .rogue file at the given filepath.
#
# --create
#   Creates a default Build.rogue file.

global rogo_folder    : String
global cache_filepath : String
global config         : Value
global cache          : Value
global is_cache_modified : Logical
global link_setting = false
global package_manager = "apt"
global package_manager_install = "sudo apt-get install"
global package_manager_list    : String

local buildfiles = Buildfiles()

local should_create = false
local buildfile : String
local cmd_line_args = String[]
forEach (arg in System.command_line_arguments)
  if (arg == "--build" or arg.begins_with("--build="))
    local cur_buildfile = arg.after_first( '=' )
    if (cur_buildfile.count == 0)
      Console.error.println ''ERROR: expected filename after "--build=".''
      System.exit 1
    endIf
    if (not File.exists(cur_buildfile))
      if (File.exists(cur_buildfile + ".rogue"))
        cur_buildfile += ".rogue"
      else
        Console.error.println ''ERROR: no such file "$".'' (cur_buildfile)
        System.exit 1
      endIf
    endIf
    buildfiles.add( cur_buildfile )
    buildfile = File.abs( cur_buildfile )

  else
    if (arg == "--create") should_create = true
    cmd_line_args.add( arg )
  endIf
endForEach

if (buildfile)
  rogo_folder = buildfile
  if (not File.is_folder(rogo_folder))
    rogo_folder = File.folder( rogo_folder )
  endIf
  rogo_folder /= ".rogo"
else
  rogo_folder = ".rogo"
endIf

if (buildfiles.is_empty)
  if (buildfile and File.is_folder(buildfile))
    buildfiles.add( buildfile/"Build.rogue" )
    buildfiles.add( buildfile/"BuildCore.rogue" )
    buildfiles.add( buildfile/"BuildLocal.rogue" )
  endIf
endIf

if (not buildfile)
  # These add()s only succeed for files that actually exist.
  buildfiles.add( "Build.rogue" )
  buildfiles.add( "BuildCore.rogue" )
  buildfiles.add( "BuildLocal.rogue" )
endIf

if (not buildfiles.count)
  if (should_create)
    local bitmap_option = cmd_line_args.contains( "--bitmap" )
    local project_option = cmd_line_args.find( $.begins_with("--project") )
    local project_name : String
    if (project_option)
      project_name = project_option.value.after_first('=')
      if (project_name.count == 0) project_name = null
    endIf

    print "Creating Build.rogue"
    if (project_name)
      project_name = project_name.replacing( " ", "" )
      print " and Source/$.rogue" (project_name)
      if (bitmap_option) print " with Bitmap library support"
      println
    else
      print " with default Rogo framework"
      if (bitmap_option) print " and Bitmap library support"
      println
    endIf
    cmd_line_args.clear

    local builder = StringBuilder()
    builder.println ...
      @|# To run this build file, install Rogue from github.com/AbePralle/Rogue then cd
       |# to this folder and type "rogo" at the command line.
       |
       |# description()s are optional - Rogo uses introspection to determine which
       |# commands are available. 'rogo help default' displays the description for
       |# "default", etc.
       |description( "default", "The default action is performed when no other actions are specified. Use 'rogo default' to explicitly perform the default option." )
       |description( "help",    "Displays a list of all actions that can be performed by Rogo." )
       |

    if (bitmap_option)
      builder.println ...
        @|#$ LINK                 = true
         |   # Link the following in when compiling this Build.rogue
         |
         |#$ LIBRARIES(macOS)     = libpng libjpeg zlib
         |#$ LIBRARIES(Linux-apt) = libpng-dev libjpeg-dev
         |
         |uses Bitmap
         |
    endIf

    if (project_name)
      builder.println @|augment Build
                       |  # You can create a Local.settings file with overrides for these values, e.g.:
                       |  # LAUNCHER_FOLDER = "~/bin"
                       |  PROPERTIES
      builder.println ''    PROJECT           = "$"'' (project_name)
      builder.println ''    LAUNCHER_NAME     = "$"'' (project_name.to_lowercase)
      builder.println ''    LAUNCHER_FOLDER   = "/usr/local/bin"''
      builder.println ''    ROGUEC_FLAGS      = "--debug"''
      builder.println ''    CPP_FLAGS_UNIX    = "-O0"''
      builder.println ''                        # -O3 to optimize''
      builder.println ''    CPP_FLAGS_WINDOWS = "/Od"''
      builder.println ''                        # /Ob2ity /GF /Gy to optimize''

      builder.println ...
        @|endAugment
         |
         |routine exe_filepath->String
         |  if (System.is_windows) return "Build/$.exe" (Build.LAUNCHER_NAME)
         |  return "Build/$-$" (Build.PROJECT,System.os)
         |endRoutine
         |
         |routine launcher_folder->String
         |  local result = Build.LAUNCHER_FOLDER
         |  result = File.expand_path( result )
         |  return File.without_trailing_separator( result )
         |endRoutine
         |
         |routine rogo_default
         |  rogo_build
     builder.println "  #rogo_install_launcher  # Uncomment to automatically install a /usr/local/bin/$ launcher" (project_name.to_lowercase)
     builder.println ...
        @|  rogo_run
         |endRoutine
         |
         |routine rogo_build
         |  block exe_filepath
         |    local source_files = Files( "Source", "**/*.rogue" )
         |    local src_filepath = "Source/$.rogue" (Build.PROJECT)
         |    if (source_files.any_newer_than(exe_filepath))
         |      local cpp_filepath = "Build/$-$.cpp" (Build.PROJECT,System.os)
         |      if (source_files.any_newer_than(cpp_filepath))
         |        execute "roguec $ $ --main --output=$ --target=Console,C++,$"...
         |                (File.esc(src_filepath),Build.ROGUEC_FLAGS,File.esc(cpp_filepath),System.os)
         |      endIf
         |      if (System.is_windows)
         |        local libs = ""
         |        local cc = "cl $ /EHsc /nologo $ /Fe$ $" (Build.CPP_FLAGS_WINDOWS,File.esc(cpp_filepath),File.esc(exe_filepath),libs)
         |        #cc += " /link /LTCG"   # uncomment this if there are errors linking libraries
         |        execute cc
         |      else

    if (bitmap_option)
      builder.println @|        local libs = which{ System.is_linux:" $LIBRARY_FLAGS(libpng-dev,libjpeg-dev)" || " $LIBRARY_FLAGS(libpng,libjpeg,zlib)" }
    else
      builder.println @|        local libs = ""
    endIf
    builder.println ...
        @|        local cc = "c++ -Wall -std=gnu++11 -fno-strict-aliasing -Wno-invalid-offsetof $ $ -o $$"...
         |          (Build.CPP_FLAGS_UNIX,File.esc(cpp_filepath),File.esc(exe_filepath),libs)
         |        execute cc
         |      endIf
         |    endIf
         |  endBlock
         |endRoutine
         |
         |routine rogo_run
         |  execute File.esc( exe_filepath )
         |endRoutine
         |
         |routine rogo_install_launcher
         |  local exe_filepath = File.abs( exe_filepath )
         |  if (System.is_windows)
         |    local exe_folder = File.conventional_filepath( File.folder(exe_filepath) )
         |    local path = System.environment//PATH
         |    if (not path.to_lowercase.contains(exe_folder.to_lowercase))
         |      println
         |      println ''Add the following to your system PATH then reopen this command prompt to be able''
         |      println ''to launch $ by typing "$":'' (Build.PROJECT,Build.LAUNCHER_NAME)
         |      println
         |      println "  ADD THIS TO YOUR PATH"
         |      println "  " + exe_folder
         |    endIf
         |  else
         |    contingent
         |      local result = Process.run( "which " + Build.LAUNCHER_NAME, &env )
         |      necessary (result.success)
         |      local launcher_filepath = result->String.trimmed
         |      necessary launcher_filepath
         |      necessary File.load_as_string( launcher_filepath ).contains( exe_filepath )
         |
         |    unsatisfied
         |      local launcher_filepath = "$/$" (launcher_folder,Build.LAUNCHER_NAME)
         |      println "Creating launcher " + launcher_filepath
         |      local sudo = ""
         |      loop
         |        try
         |          if (not File.exists(launcher_folder)) execute( "$mkdir $"(sudo,launcher_folder) )
         |          File.save( "$.launcher"(Build.LAUNCHER_NAME), ''#!/bin/sh\nexec "$" "$@"\n''(exe_filepath,'$') )
         |          execute( "$mv $.launcher $"(sudo,Build.LAUNCHER_NAME,launcher_filepath) )
         |          execute( "$chmod a+x $"(sudo,launcher_filepath) )
         |          escapeLoop
         |        catch (err:Error)
         |          if (sudo != "") throw err
         |          sudo = "sudo "
         |        endTry
         |      endLoop
         |    endContingent
         |  endIf
         |endRoutine
         |
         |routine rogo_clean
         |  verbose_delete( "Build" )
         |  if (not System.is_windows) verbose_delete( "$/$"(launcher_folder,Build.LAUNCHER_NAME) )
         |endRoutine
         |
         |routine verbose_delete( filepath:String )
         |  if (File.exists(filepath))
         |    println "> Delete " + filepath
         |    if (not File.delete(filepath))
         |      println "*** Failed to delete - retrying with sudo"
         |      local cmd = ''sudo rm -rf $'' (File.shell_escaped(filepath))
         |      execute cmd
         |    endIf
         |  endIf
         |endRoutine

    else
      builder.println ...
        @|routine rogo_default
         |  rogo_help
         |endRoutine

    endIf

    builder.println ...
      @|
       |routine execute( commands:String, &suppress_error )->Logical
       |  forEach (cmd in LineReader(commands))
       |    print( "> " ).println( cmd )
       |    if (System.run(cmd) != 0)
       |      if (suppress_error) return false
       |      else                throw Error( "Build failed." )
       |    endIf
       |  endForEach
       |  return true
       |endRoutine
       |
       |#-------------------------------------------------------------------------------
       |# Introspection-based Launcher Framework
       |#-------------------------------------------------------------------------------
       |# Rogo is a "build your own build system" facilitator. At its core Rogo just
       |# recompiles build files if needed and then runs the build executable while
       |# forwarding any command line arguments. This file contains a default framework
       |# which uses introspection to turn command line arguments into parameterized
       |# routine calls.
       |
       |# Example: to handle the command "rogo abc xyz 5", define
       |# "routine rogo_abc_xyz( n:Int32 )".
       |
       |# "rogo_default" will run in the absence of any other command line argument.
       |
       |# The following "comment directives" can be used in this file to control how
       |# RogueC compiles it and to manage automatic dependency installation and
       |# linking.
       |
       |# Each of the following should be on a line beginning with the characters #$
       |# (preceding whitespace is fine). Sample args are given.
       |
       |#   ROGUEC       = roguec       # Path to roguec to compile this file with
       |#   ROGUEC_ARGS  = --whatever   # Additional options to pass to RogueC
       |#   CPP          = g++ -Wall -std=gnu++11 -fno-strict-aliasing
       |#                  -Wno-invalid-offsetof   # C++ compiler path and/or invocation
       |#   CPP_ARGS     = -a -b -c          # Additional C++ args
       |#   LINK         = true              # Links following LIBRARIES with this Build
       |#                                    # file (otherwise just installs them)
       |#   LINK         = -lalpha -lbeta    # Links following LIBRARIES and includes
       |#                                    # these additional flags
       |#   LINK         = false             # Linking turned off for following
       |#                                    # LIBRARIES - info can still be obtained
       |#                                    # from $LIBRARY_FLAGS()
       |#   LINK(macOS)  = ...               # Options applying only to
       |#                                    # System.os=="macOS" (use with any OS and
       |#                                    # any comment directive)
       |#   LIBRARIES    = libalpha
       |#   LIBRARIES    = libbeta(library-name)
       |#   LIBRARIES    = libfreetype6-dev(freetype2)
       |#   DEPENDENCIES = Library/Rogue/**/*.rogue
       |#
       |#   LIBRARIES    = name(package)
       |#   LIBRARIES    = name(package:<package> install:<install-cmd>
       |#                  link:<link-flags> which:<which-name>)
       |#
       |# The following macro is replaced within this file (Build.rogue) - the libraries
       |# should normally also be declared in #$ LIBRARIES:
       |#
       |#   $LIBRARY_FLAGS(lib1,lib2)                              # sample macro
       |#     ->
       |#   -Ipath/to/lib1/include -Lpath/to/lib1/library -I ...   # sample replacement
       |
       |routine syntax( command:String, text:String )
       |  Build.rogo_syntax[ command ] = text
       |endRoutine
       |
       |routine description( command:String, text:String )
       |  Build.rogo_descriptions[ command ] = text
       |endRoutine
       |
       |routine help( command:String, description=null:String, syntax=null:String )
       |  if (description) Global.description( command, description )
       |  if (syntax)      Global.syntax( command, syntax )
       |endRoutine
       |
       |try
       |  Build.launch
       |catch (err:Error)
       |  Build.rogo_error = err
       |  Build.on_error
       |endTry
       |
       |class Build [singleton]
       |  PROPERTIES
       |    rogo_syntax         = StringTable<<String>>()
       |    rogo_descriptions   = StringTable<<String>>()
       |    rogo_prefix         = ?:{ $moduleName.count:$moduleName "::" || "" } + "rogo_" : String
       |    rogo_command        = "default"
       |    rogo_args           = @[]
       |    rogo_error          : Error
       |
       |    LOCAL_SETTINGS_FILE = "Local.settings"
       |
       |  METHODS
       |    method launch
       |      rogo_args.add( forEach in System.command_line_arguments )
       |      read_defs
       |      on_launch
       |      parse_args
       |      dispatch_command
       |
       |    method dispatch_command
       |      local m = find_command( rogo_command )
       |      require m || "no such routine rogo_$()" (rogo_command)
       |
       |      local args = @[]
       |      forEach (arg in rogo_args)
       |        which (arg)
       |          case "true":  args.add( true )
       |          case "false": args.add( false )
       |          case "null":  args.add( NullValue )
       |          others:       args.add( arg )
       |        endWhich
       |      endForEach
       |      if (m.parameter_count == 1 and args.count > 1) args = @[ args ] # Wrap args in a ValueList.
       |      m( args )
       |
       |    method find_command( name:String )->MethodInfo
       |      return <<Global>>.find_global_method( rogo_prefix + name )
       |
       |    method on_error
       |      local w = Console.width.or_smaller( 80 )
       |      Console.error.println "=" * w
       |      Console.error.println rogo_error
       |      Console.error.println "=" * w
       |      on_exit
       |      System.exit 1
       |
       |    method on_command_found
       |      noAction
       |
       |    method on_command_not_found
       |      local w = Console.width.or_smaller( 80 )
       |      println "=" * w
       |      println "ERROR: No such command '$'." (rogo_args.first)
       |      println "=" * w
       |      println
       |      rogo_command = "help"
       |      rogo_args.clear
       |      on_command_found
       |
       |    method on_launch
       |      noAction
       |
       |    method on_exit
       |      noAction
       |
       |    method parse_args
       |      block
       |        if (rogo_args.count)
       |          local parts = String[]
       |          parts.add( forEach in rogo_args )
       |          rogo_args.clear
       |
       |          while (parts.count)
       |            local cmd = _join( parts )
       |            if (find_command(cmd))
       |              rogo_command = cmd
       |              on_command_found
       |              escapeBlock
       |            endIf
       |            rogo_args.insert( parts.remove_last )
       |          endWhile
       |
       |          on_command_not_found
       |        endIf
       |
       |        # Use default command
       |        on_command_found
       |      endBlock
       |
       |    method read_defs
       |      read_defs( LOCAL_SETTINGS_FILE )
       |
       |    method read_defs( defs_filepath:String )
       |      # Attempt to read defs from Local.settings
       |      local overrides = String[]
       |      if (File.exists(defs_filepath))
       |        forEach (line in LineReader(File(defs_filepath)))
       |          if (line.contains("="))
       |            local name  = line.before_first('=').trimmed
       |            local value = line.after_first('=').trimmed
       |            if (value.begins_with('"') or value.begins_with('\''))
       |              value = value.leftmost(-1).rightmost(-1)
       |            endIf
       |            local p = <<Build>>.find_property( name )
       |            if (p)
       |              overrides.add( "$ = $" (name,value) )
       |              <<Build>>.set_property( this, p, Value(value) )
       |            endIf
       |          endIf
       |        endForEach
       |      endIf
       |
       |    method _join( value:Value )->String
       |      local args = String[]
       |      args.add( forEach in value )
       |      return args.join( "_" )
       |endClass
       |
       |
       |routine rogo_help( command="":String )
       |  command = Build._join( Build.rogo_args )
       |  if (command.count)
       |    local syntax = get_syntax( command )
       |    local success = false
       |    if (syntax)
       |      println "SYNTAX"
       |      println "  " + syntax
       |      println
       |      success = true
       |    endIf
       |    local description = get_description( command )
       |    if (description)
       |      println "DESCRIPTION"
       |      forEach (line in LineReader(description.word_wrapped(76)))
       |        print( "  " ).println( line )
       |      endForEach
       |      println
       |      success = true
       |    endIf
       |    if (success)
       |      return
       |    else
       |      local w = Console.width.or_smaller( 80 )
       |      println "=" * w
       |      println "ERROR: No such command '$'." (command)
       |      println "=" * w
       |      println
       |    endIf
       |  endIf
       |
       |  println "USAGE"
       |  local lines = String[]
       |  forEach (m in <<Global>>.global_methods)
       |    if (m.name.begins_with(Build.rogo_prefix))
       |      lines.add( "  " + get_syntax(m.name.after_first(Build.rogo_prefix)) )
       |    endIf
       |  endForEach
       |  lines.sort( (a,b)=>(a<b) )
       |  println (forEach in lines)
       |  println
       |endRoutine
       |
       |
       |routine get_syntax( m_name:String )->String
       |  if (Build.rogo_syntax.contains(m_name))
       |    return "rogo " + Build.rogo_syntax[ m_name ]
       |  else
       |    local m = <<Global>>.find_global_method( Build.rogo_prefix + m_name )
       |    if (not m) return null
       |    local line = "rogo $" (m_name.replacing('_',' '))
       |    line += " <$>" (m.parameter_name(forEach in 0..<m.parameter_count))
       |    return line
       |  endIf
       |endRoutine
       |
       |
       |routine get_description( m_name:String )->String
       |  if (Build.rogo_descriptions.contains(m_name))
       |    return Build.rogo_descriptions[ m_name ]
       |  else
       |    return null
       |  endIf
       |endRoutine

    File.save( "Build.rogue", builder->String )
    buildfiles.add( "Build.rogue" )

    if (project_name)
      # Create Source/ProjectName.rogue
      builder.clear
      builder.println "#" + "=" * 80
      builder.println "# $.rogue" (project_name)
      builder.println "# " + Date.today->String(&verbose)
      builder.println "#" + "=" * 80
      builder.println
      builder.print   "$requireRogue "
      builder.println ''"$"'' ($rogueVersion)
      builder.println
      builder.println "uses Utility/CommandLineParser"
      if (bitmap_option)
        builder.println "uses Bitmap"
      endIf
      builder.println

      builder.println @|try
      builder.println "  $( System.command_line_arguments )" (project_name)
      builder.println @|catch (error:Error)
                       |  local w = Console.width.or_smaller( 80 )
                       |  Console.error.println "="*w
                       |  Console.error.println "ERROR"
                       |  Console.error.println error->String.word_wrapped(w-2).indented(2)
                       |  Console.error.println "="*w
                       |  System.exit 1
                       |endTry
      builder.println
      builder.println "class $" (project_name)
      builder.println ...
        @|  METHODS
         |    method init( args:String[] )
         |      local command = parse_args( args )
         |
         |      trace command
         |      # has //options and possibly //args
         |
         |      if (command//options//help)
         |        print_usage
         |        System.exit 0
         |      endIf
         |
         |    method parse_args( args:String[] )->Value
         |      local command = CommandLineParser().
         |      [
         |        option( "--flag",     &alias="-f" )
         |        option( "--help",     &aliases=["-h","-?"] )
         |        option( "--setting=", &alias="-s" )
         |      ].parse( args )
         |      return command
         |
         |    method print_usage
         |      println @|USAGE
      builder.println ...
         "               |  $ [OPTIONS]" (project_name.to_lowercase)
      builder.println ...
        @|               |
         |               |OPTIONS
         |               |  --help, -h, -?
         |               |    Show this help text.
         |endClass

      File.create_folder( "Source" )
      File.save( "Source/$.rogue"(project_name), builder->String )
    endIf

  else
    local w = Console.width.or_smaller( 80 )
    Console.error.println "=" * w
    local mesg = "ROGO ERROR\n\n"
    mesg += @|No standard build file exists (Build.rogue, BuildCore.rogue, BuildLocal.rogue)
    mesg += @| and no alternate specified with --build=<filename>.
             |
             |
    mesg += @|Type 'rogo --create [options]' to create Build.rogue with a default framework.
             |
             |OPTIONS
             |  --project=ProjectName
             |    Creates additional starter framework for the specified ProjectName.
             |
             |  --bitmap
             |    Links Build.rogue and the starter project (if --project is specified) with
             |    libpng and libjpeg libraries.
             |
             |If no options are specified then only Build.rogue is created.
    Console.error.println( mesg.word_wrapped(w) )
    loop (w) do Console.error.print( '=' )
    Console.error.println
    System.exit 1
  endIf
endIf

File.create_folder( rogo_folder )
cache_filepath = "$/Cache-$.json" (rogo_folder,System.os)
config         = @{ roguec:"roguec", filepath:cache_filepath }
cache          = JSON.load_table( File(cache_filepath) )

local compiler_invocation : String
native @|#if defined(DEFAULT_CXX)
        |  $compiler_invocation = RogueString_create_from_utf8( DEFAULT_CXX );
        |#else
           which (System.os)
             case "Windows"
               compiler_invocation = "cl /EHsc /nologo"
             others
               compiler_invocation = "g++ -Wall -std=gnu++11 -fno-strict-aliasing -Wno-invalid-offsetof"
           endWhich
native @|#endif

config//cpp = compiler_invocation

local exe : String
if (buildfile is null)
  buildfile = buildfiles[0]
  exe = "$$Build" (rogo_folder,File.separator)
else
  exe = "$$$" (rogo_folder,File.separator,File.filename(buildfile).before_first('.'))
endIf
local base_name = exe   # e.g. Build
if (System.os == "Windows") exe += ".exe"
else                        exe += "-" + System.os  # e.g. Build-macOS

configure_os

local needs_recompile = buildfiles.any_newer_than( exe )
block
  local dependencies = StringLookupList()
  scan_and_rewrite( File(forEach in buildfiles), dependencies, &skip_rewrite, &dependencies_only )

  local i = 0
  while (i < dependencies.count)
    local pattern = dependencies[ i ]
    local listing = File.listing( pattern, &files )
    forEach (dependency in listing)
      if (File.filename(dependency).begins_with("Build") and not buildfiles.contains(dependency))
        scan_and_rewrite( dependency, dependencies, &skip_rewrite )
      endIf
    endForEach
    ++i
  endWhile

  forEach (pattern in dependencies)
    local listing = File.listing( pattern, &files )
    forEach (dependency in listing)
      if (File.is_newer_than(dependency,exe))
        needs_recompile = true
        escapeBlock
      endIf
    endForEach
  endForEach
endBlock

if (needs_recompile)
  println "Recompiling $..." (buildfile)

  update_old_buildfiles( buildfiles )

  # Collect info for config
  scan_and_rewrite( File(forEach in buildfiles), &skip_rewrite )

  # Select ROGUEC(macOS) or ROGUEC(Linux) etc. based on the OS and merge into to ROGUEC, etc.
  local os_arg = "($)" (System.os.to_lowercase)
  local os_arg_plus_package_manager = "($-$)" (System.os.to_lowercase,package_manager)
  forEach (key in config.keys)
    if (key.contains(os_arg) or key.contains(os_arg_plus_package_manager))
      local generic_key = key.before_first('(')
      if (config.contains(generic_key) and generic_key != "cpp" and generic_key != "roguec")
        # Merge specialized-platform keys with generic keys
        if (generic_key == "libraries")
          # Overwrite same-name libraries
          local table = @{}
          forEach (item in config[generic_key]) table[item//name] = item
          forEach (item in config[key])         table[item//name] = item
          config[ generic_key ] = table.values
        else
          # Append specialized keys to end of generic key string
          config[ generic_key ] += " " + config[key]
        endIf
      else
        config[ generic_key ] = config[ key ]
      endIf
    endIf
  endForEach

  # Now that we have the config info, rewriting to handle $ LIBRARY(name) etc. Places copies in .rogo/
  scan_and_rewrite( File(forEach in buildfiles), &skip_directives )

  local roguec = config//roguec
  if (not File.exists(roguec)) roguec = "roguec"  # use system default
  local roguec_args = config//roguec_args->String
  local cmd =  "$ --target=C++,Console,$" (roguec,System.os)
  cmd += " $$$" (rogo_folder,File.separator,File.filename(forEach in buildfiles))
  cmd += " --api --debug --main --output=$ $" (base_name,roguec_args)
  println cmd
  if (0 != System.run(cmd))
    Console.error.println "ERROR compiling $." (buildfile)
    System.exit 1
  endIf

  cmd = "$ $ $.cpp" (config//cpp,config//cpp_args,base_name)

  local is_windows = (System.os == "Windows")

  forEach (library in config//libraries)
    install_library( library )
    if (library//link)
      cmd += " $" (library_flags(library))
    endIf
  endForEach

  cmd += " $$" (?:{is_windows:"/Fe"||"-o "},exe)
  local link_args = config//link
  if (link_args != "") cmd += " " + link_args

  println cmd
  if (0 != System.run(cmd)) System.exit( 1 )
  File.delete( File.filename(exe).before_last(".exe") + ".obj" )
endIf

System.exit( System.run(''$ $'' (exe,cmd_line_args.map<<String>>( (arg)=>prep_arg(arg) ).join(" "))) )

routine prep_arg( arg:String )->String
  # Quotes and escapes string if necessary
  if (not (arg.contains(' ') or arg.contains('"') or arg.contains('\\'))) return arg
  local quoted = StringBuilder()
  quoted.print( '"' )
  forEach (ch in arg)
    which (ch)
      case '"':  quoted.print( "\\\"" )
      case '\\': quoted.print( "\\\\" )
      others:    quoted.print( ch )
    endWhich
  endForEach
  quoted.print( '"' )
  return quoted
endRoutine

routine require_command_line
  if (System.environment["IDE"])
    throw Error( "$:$: error:Run 'make $' from the command line to install necessary libraries."...
    ($sourceFilepath,$sourceLine,which{System.environment["TARGET"]||""}.to_lowercase) )
  endIf
endRoutine


routine save_cache
  is_cache_modified = false
  cache.save( File(cache_filepath), &formatted )
endRoutine

routine configure_os
  which (System.os)
    case "macOS"
      configure_macos
    case "Linux"
      configure_linux
  endWhich
endRoutine

routine configure_macos
  if (0 != System.run("which brew > /dev/null 2>&1"))
    require_command_line
    if (Console.input( "\nHomebrew must be installed.  Install now (y/n)? " ).to_lowercase.begins_with('y'))
      local cmd = @|/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
      println cmd
      if (0 != System.run(cmd))
        throw Error( "Failed to install Homebrew." )
      endIf
    else
      throw Error( "Missing required dependency 'brew' (Homebrew)." )
    endIf

  endIf

  if (0 != System.run("which pkg-config > /dev/null 2>&1"))
    require_command_line
    if (Console.input( "pkg-config must be installed.  Install now (y/n)? " ).to_lowercase.begins_with('y'))
      local cmd = @|brew install pkg-config
      println cmd
      if (0 != System.run(cmd))
        throw Error( "Failed to install pkg-config." )
      endIf
    else
      throw Error( "Missing required dependency 'pkg-config'." )
    endIf

  endIf
endRoutine

routine configure_linux
  if (0 != System.run("which apt-get > /dev/null 2>&1"))
    if (0 == System.run("which yum > /dev/null 2>&1"))
      package_manager = "yum"
      package_manager_install = "sudo yum install"
      package_manager_list    = "rpm -ql"
    endIf
  endIf

  if (0 != System.run("which pkg-config > /dev/null 2>&1"))
    require_command_line
    if (Console.input( "pkg-config must be installed.  Install now (y/n)? " ).to_lowercase.begins_with('y'))
      local cmd = package_manager_install + " pkg-config"
      println cmd
      if (0 != System.run(cmd))
        throw Error( "Failed to install pkg-config." )
      endIf
    else
      throw Error( "Missing required dependency 'pkg-config'." )
    endIf
  endIf
endRoutine

routine install_library( library:Value )
  local lib = cache//library_flags[ library//name ]
  if (lib)
    # Make sure each filepath actually exists
    block lib = lib->String
      local parts = String[]
      local i = locate_nonescaped_space( lib )
      while (i)
        local part = lib.leftmost( i.value )
        if (String.exists(part)) parts.add( part )
        lib .= from( i.value+1 )
        i = locate_nonescaped_space( lib )
      endWhile
      if (String.exists(lib)) parts.add( lib )

      contingent
        forEach (part in parts)
          part .= after_any( "-I" )
          necessary (File.exists(part))
        endForEach
      satisfied
        return
      endContingent
    endBlock
  endIf

  which (System.os)
    case "macOS"
      install_macos_library( library )
    case "Linux"
      install_linux_library( library )
    others
      throw Error( ''Rogo does not know how to install a library for "$".'' (System.os) )
  endWhich
endRoutine

routine locate_nonescaped_space( st:String )->Int32?
  local skip = false
  forEach (ch at index in st)
    if (skip)
      skip = false
    else
      which (ch)
        case '\\': skip = true
        case ' ':  return index
      endWhich
    endIf
  endForEach

  return null
endRoutine

routine run( cmd:String )->String
  println(cmd).flush
  local result = Process.run( cmd, &env )
  if (result.exit_code != 0) return null
  return result.output_string.trimmed
endRoutine

routine find_macos_library( library:Value )->Logical
  local name = library//name->String
  local package = library//package->String

  local result = run( "  pkg-config --cflags " + package )
  if (result)
    local flags = String[]

    # cflags
    flags.add( result )

    # library( link:... ) flags
    if (library//link and not library//link.is_logical)
      # If the link flags are more than just 'true'.
      flags.add( library//link )
    endIf

    # static library path
    local candidates : String[]
    result = run( "  pkg-config --libs-only-L " + package )
    if (result and result.begins_with("-L"))
      candidates = File.listing( result.from(2) )
    else
      result = run( "  brew list -v " + name )
      if (result)
        candidates = result.split( '\n' )
      endIf
    endIf

    if (candidates)
      candidates.keep( $.ends_with(".a") )
      if (candidates.count) flags.add( candidates.first )  # .a file to link in
    else
      return false
    endIf

    local all_flags = flags.join( ' ' )
    println "  Library flags: $" (all_flags)
    cache.ensure_table("library_flags")[ name ] = all_flags
    save_cache
    return true
  endIf

  # "Library" may be executable package - use 'which' to check.
  println "  which " + library["which"]
  if (0 == System.run("which $ > /dev/null 2>&1"(library["which"])))
    local flags = which{ library//link || Value("") }
    if (flags != "") println "  Library flags: $" (flags)
    cache.ensure_table("library_flags")[ name ] = flags  # package exists but has no flags
    save_cache
    return true
  endIf

  return false
endRoutine

routine install_macos_library( library:Value )
  local library_name = library//name->String
  println "Checking for library $..." (library_name)

  if (not find_macos_library(library))
    # Install library
    require_command_line
    if (not Console.input( "\nLibrary '$' must be installed.  Install now (y/n)? "(library_name) ).to_lowercase.begins_with('y'))
      throw Error( "Missing required library '$'." (library_name) )
    endIf

    # Two install options:
    #   libname                 - install libname
    #   libname(install:"cmd")  - install cmd
    local install_cmd = library//name
    if (library.contains("install")) install_cmd = library//install

    run( "brew install $" (install_cmd) )  # this could succeed in principal but return non-zero with a warning, as with zlib
    if (not find_macos_library(library))
      throw Error( "Failed to install library '$'." (library_name) )
    endIf
  endIf
endRoutine

routine find_linux_library( library:Value )->Logical
  local name = library//name->String
  local package = library//package->String

  # Try pkg-config first
  local result = run( "  pkg-config --cflags --libs " + package )
  if (result)
    local flags = result
    println "  Library flags: $" (flags)
    cache.ensure_table("library_flags")[ name ] = flags
    save_cache
    return true
  endIf

  # Next try rpm -ql for Yum+RPM Linux
  if (package_manager_list)
    println "  No found with pkg-config; checking with rpm"
    result = run( "  $ $" (package_manager_list,package) )
    if (result)
      println "  Located"
      cache.ensure_table("library_flags")[ name ] = ""  # library exists but has no flags
      save_cache
      return true
    endIf
  endIf

  # "Library" may be executable package - use 'which' to check.
  println "  which " + library["which"]
  if (0 == System.run("which $ > /dev/null 2>&1"(library["which"])))
    cache.ensure_table("library_flags")[ name ] = ""  # package exists but has no flags
    save_cache
    return true
  endIf

  return false
endRoutine

routine install_linux_library( library:Value )
  local library_name = library//name->String

  println "Checking for library $..." (library//name->String)

  if (not find_linux_library(library))
    # Install library
    require_command_line
    if (not Console.input( "\nLibrary '$' must be installed.  Install now (y/n)? "(library_name) ).to_lowercase.begins_with('y'))
      throw Error( "Missing required library '$'." (library_name) )
    endIf

    # Two install options:
    #   libname                 - install libname
    #   libname(install:"cmd")  - install cmd
    local install_cmd = library//name
    if (library.contains("install")) install_cmd = library//install

    local cmd = "$ $" (package_manager_install,install_cmd)
    print "> "
    println cmd
    if (System.run(cmd) or not find_linux_library(library))
      throw Error( "Failed to install library '$'." (library_name) )
    endIf
  endIf
endRoutine

routine library_flags( library:Value )->String
  if (not cache//library_flags.contains(library//name))
    install_library( library )
  endIf

  return cache//library_flags[library//name]->String
endRoutine

routine scan_and_rewrite( file:File, dependencies=null:StringLookupList, &skip_rewrite, &skip_directives, &dependencies_only )
  # Note: the organization and usage of this method has become inelegant over time. Could use a refactoring.
  if (not file.exists) return

  local writer : PrintWriter
  if (not skip_rewrite) writer = PrintWriter( File("$/$"(rogo_folder,file.filename)).writer )
  forEach (original_line in LineReader(file))
    local line = original_line.trimmed
    if (not skip_directives)
      if (line.begins_with("#$"))
        local cmd = line.rightmost( -2 )
        local args = cmd.after_first( "=" ).trimmed
        cmd = cmd.before_first( "=" ).trimmed.to_lowercase

        local base_cmd = cmd.before_first('(')
        which (base_cmd)
          case "config", "roguec"
            if (not dependencies_only)
              if (args.begins_with('"')) args = args.after_first('"').before_last('"')
              elseIf (args.begins_with('\'')) args = args.after_first('\'').before_last('\'')
              config[ cmd ] = args
            endIf

          case "libraries"
            if (args.count and not dependencies_only)
              local parser = JSONParser( Scanner(args) )
              parser.consume_spaces
              while (parser.has_another)
                local name = parse_filepath( parser )
                local entry = @{ name:name, link:link_setting }
                config.ensure_list( cmd ).add( entry )
                parser.consume_spaces
                entry//package = name.before_first( "-dev" )  # default of e.g. libpng-dev is libpng
                entry["which"] = name
                if (parser.consume('('))
                  parser.consume_spaces
                  while (parser.has_another)
                    if (parser.consume(')')) escapeWhile
                    local key = parser.parse_identifier
                    parser.consume_spaces
                    if (parser.consume(':'))
                      parser.consume_spaces
                      local value = parse_filepath( parser )
                      entry[ key ] = value
                    else
                      # An identifier with no mapped value is treated as the package name
                      entry//package = key
                    endIf
                    parser.consume_spaces
                    parser.consume( ',' )
                    parser.consume_spaces
                  endWhile
                endIf
                parser.consume_spaces
              endWhile
            endIf

          case "dependencies"
            if (dependencies)
              if (args.begins_with('"'))       args = args.after_first('"').before_last('"')
              elseIf (args.begins_with('\'')) args = args.after_first('\'').before_last('\'')
              dependencies.add( args )
              is_cache_modified = true
            endIf

          others
            if (not dependencies_only)
              if (base_cmd == "link")
                if (cmd == "link" or cmd == "link($)" (System.os.to_lowercase))
                  if (args == "true" or args == "false")
                    # LINK true or LINK false
                    link_setting = (args == "true")
                  else
                    # LINK <args> implies LINK true
                    link_setting = true
                    if (config[cmd]?) config[cmd] += " " + args
                    else              config[cmd] = args
                  endIf
                endIf

              else
                # Join into single space-separated string
                if (config.contains(cmd))
                  config[ cmd ] = "$ $" (config[ cmd ],args)
                else
                  config[ cmd ] = args
                endIf
              endIf
            endIf

        endWhich
      endIf
    endIf

    if (not skip_rewrite)
      line = original_line
      local dollar = line.locate( '$' )
      while (dollar.exists)
        if (line.contains_at("$LIBRARY_FLAGS(",dollar.value))
          local close_paren = line.locate( ')', dollar.value + 1 )
          if (close_paren.exists)
            local replacement = ""
            forEach (library_name in line.from(dollar.value,close_paren.value-1).after_first('(').split(','))
              library_name = library_name.trimmed
              block
                forEach (lib in config//libraries)
                  if (lib//name == library_name)
                    if (replacement.count > 0) replacement += " "
                    replacement += library_flags( lib )
                    escapeBlock
                  endIf
                endForEach
              endBlock
            endForEach
            line = "$$$" (line.before(dollar.value),replacement,line.after(close_paren.value))
          endIf
        endIf
        dollar = line.locate( '$', dollar.value+1 )
      endWhile
      writer.println( line )
    endIf
  endForEach
  if (not skip_rewrite) writer.close

endRoutine

routine parse_filepath( parser:JSONParser )->String
  if (parser.next_is('"')) return parser.parse_string

  local buffer = StringBuilder()
  while (parser.has_another and not " \n()".contains(parser.peek)) buffer.print( parser.read )

  if (buffer.count == 0) buffer.print( parser.read )

  return buffer->String
endRoutine

routine update_old_buildfiles( buildfiles:Buildfiles )
  local all_content = ""
  all_content += File.load_as_string( forEach in buildfiles ) + "\n"
  contingent
    necessary (all_content.contains("find_method"))
    necessary (all_content.contains(".methods"))
    necessary (all_content.contains(".call( Global,"))

    println "="*80
    println @|ATTENTION
             |
             |Rogo buildfiles have been detected that use an outdated mechanism for calling
             |routines via introspection. Rogo is rewriting those files to fix them. Backups
             |will be stored in .rogo/OldBuildfiles. No further action is required.
             |

    local backup_folder = ".rogo/OldBuildfiles"
    require File.create_folder( backup_folder )

    forEach (filepath in buildfiles)
      local content = File.load_as_string( filepath )
      local updated_content = update_old_buildfile( content )
      if (updated_content is not content)
        println "Rewriting " + filepath
        local backup_filepath = "$/$" (backup_folder,File.filename(filepath))
        if (File.exists(backup_filepath))
          local n = 2
          while (File.exists("$/$-$"(backup_folder,n,File.filename(filepath)))) ++n
          backup_filepath = "$/$-$" (backup_folder,n,File.filename(filepath))
        endIf
        println "  Saving original to $" (backup_filepath)
        File.save( backup_filepath, content )
        File.save( filepath, updated_content )
      endIf
    endForEach

    println "="*80
  endContingent
endRoutine

routine update_old_buildfile( content:String )->String
  local is_modified = false
  use builder=StringBuilder.pool
    forEach (line in LineReader(content))
      if (line.ends_with("require m"))
        is_modified = true
        line = line.before_first("require") + @|require m || "no such routine rogo_$()" (rogo_command)
      endIf
      if (line.contains("find_method"))
        is_modified = true
        line .= replacing( "find_method", "find_global_method" )
      endIf
      if (line.contains(".methods"))
        is_modified = true
        line .= replacing( ".methods", ".global_methods" )
      endIf
      if (line.contains(".call( Global,"))
        is_modified = true
        line .= replacing( ".call( Global,", "(" )
      endIf
      builder.println( line )
    endForEach
    if (is_modified) return builder->String
  endUse
  return content
endRoutine

class Buildfiles : String[]
  METHODS
    method add( filepath:String )->this
      if (not File.exists(filepath)) return this
      if (File.is_folder(filepath)) return this
      filepath = File.abs( filepath )
      if (not this.contains(filepath)) prior.add( filepath )
      return this

    method any_newer_than( filepath:String )->Logical
      forEach (cur in this)
        if (File.is_newer_than(cur,filepath)) return true
      endForEach
      return false

    method contains( filepath:String )->Logical
      filepath = File.abs( filepath )
      return prior.contains( filepath )

endClass
