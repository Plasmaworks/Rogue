$include "Presentation/ProgressFn.rogue"

class Action
  DEFINITIONS
    # Duration values
    INSTANT    =  0  # default duration (one and done)
    INDEFINITE = -1  # action loops until finish() called or overridden is_finished()->true

  GLOBAL METHODS
    method create( fn:Function() )->Action
      return ActionCall( fn )

    method create( fn:Function(Real), duration:Real, progress_fn=ProgressFn.LINEAR:Function(Real)->Real )->Action
      return ActionCallWithProgress( fn, duration, progress_fn )

    method finish_all( cmd:Action )->Action
      while (cmd)
        cmd.finish
        cmd = cmd.update
      endWhile
      return null

    method operator+( a:Action, b:Action )->Action
      if (not a) return b
      if (not b) return a
      return a.and_then( b )

    method operator|( a:Action, b:Action )->Action
      if (not a) return b
      if (not b) return a
      return a.also( b )

  PROPERTIES
    duration    : Real
    progress_fn = ProgressFn.LINEAR : Function(Real)->Real

    next        : Action
    concurrent  : Action

    total_ticks : Int32  # duration in ticks
    t           : Int32  # current tick
    dt          : Int32  # delta-ticks since previous update
    last_ticks  : Int32  # 0:not started

  METHODS
    method init( duration=0, progress_fn=ProgressFn.LINEAR, &indefinite )
      if (indefinite) duration = INDEFINITE

    method and_then( node:Action )->this
      if (node)
        local cur = this
        while (cur.next) cur = cur.next
        cur.next = node
      endIf
      return this

    method and_then_also( node:Action )->this
      if (next) next = next.also( node )
      else      next = node
      return this

    method also( node:Action )->this
      if (node)
        local cur = this
        while (cur.concurrent) cur = cur.concurrent
        cur.concurrent = node
      endIf
      return this

    method count->Int32
      local n = 1
      if (next) n += next.count
      if (concurrent) n += concurrent.count
      return n

    method describe->String
      return type_name

    method finish
      if (total_ticks < 0) total_ticks = 0
      t = total_ticks

    method indefinite
      duration = Action.INDEFINITE

    method insert_next( node:Action )->this
      if (node) next = node.and_then( next )
      return this

    method is_finished->Logical
      return (total_ticks >= 0 and t >= total_ticks)

    method last->Action
      # Returns the last node in this chain
      local cur = this
      while (cur.next ) cur = cur.next
      return cur

    method on_start

    method on_update

    method on_finish

    method progress->Real
      return which{ total_ticks>0:progress_fn(t->Real/total_ticks) || 1.0 }

    method start_next->Action
      # Finds the successor to this node, adjusts links if necessary, and
      # returns it or the result of a call to its update().
      if (next)
        if (concurrent)
          # Attach any parallel commands remaining in this finished command to the
          # next command in this chain that will be the new head.
          next = next.also( concurrent )
          concurrent = null
        endIf
        return next.update
      elseIf (concurrent)
        # start_next() is called after update(), which has already updated 'concurrent' this tick.
        return concurrent
      else
        return null
      endIf

    method description->String
      local result = describe
      if (next) result = "$ + $" (result,next->String)
      if (concurrent) result = "($) | ($)" (result,concurrent)
      return result

    method to->String
      return description

    method update->Action
      local cur_ticks = System.ticks
      if (not last_ticks)
        if (duration == -1) total_ticks = -1
        else                total_ticks = (duration*60)->Int32
        on_start
      else
        dt = (cur_ticks - last_ticks).clamped(0,6)
        t += dt
        if (total_ticks >= 0 and t > total_ticks) t = total_ticks
      endIf

      last_ticks = cur_ticks

      on_update

      if (concurrent)
        concurrent = concurrent.update
      endIf

      if (not is_finished) return this

      on_finish

      return start_next
endClass

class IndefiniteAction : Action
  METHODS
    method init_object
      duration = INDEFINITE
endClass


class ActionList : Action
  # Contains nested actions
  PROPERTIES
    actions : Action

  METHODS
    method describe->String
      if (actions) return "[" + actions + "]"
      else         return "[]"

    method finish
      prior.finish
      if (actions) actions.finish

    method is_finished->Logical
      if (actions) return false
      return (total_ticks >= 0 and t >= total_ticks)

    method operator+( action:Action )->ActionList
      actions += action
      return this

    method operator|( action:Action )->ActionList
      actions |= action
      return this

    method update->Action
      local cur_ticks = System.total_ticks
      if (not last_ticks)
        if (duration == -1) total_ticks = -1
        else                total_ticks = (duration*60)->Int32
        on_start
      else
        dt = (cur_ticks - last_ticks).clamped(0,6)
        t += dt
        if (total_ticks >= 0 and t > total_ticks) t = total_ticks
      endIf

      last_ticks = cur_ticks

      on_update
      if (actions) actions = actions.update

      if (concurrent)
        concurrent = concurrent.update
      endIf

      if (not is_finished) return this

      on_finish

      return start_next
endClass


class ActionWait( duration ) : Action;

class ActionWaitFor( condition:Function->Logical, duration=Action.INDEFINITE ) : Action
  METHODS
    method is_finished->Logical
      return condition()
endClass

class ActionCall( fn:Function() ) : Action
  METHODS
    method on_start
      fn()
endClass


class ActionCallWithProgress( fn:Function(Real), duration, progress_fn ) : Action
  METHODS
    method on_update
      fn( progress )
endClass

