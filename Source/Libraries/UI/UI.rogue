module UI

uses Collection/Node
uses Control/Action  [export]
uses Geometry        [export]

# These two macro includes must come first
$include UI/EntityMacros
$include UI/DynamicProperty

$include UI/ConditionalEntityCollector
$include UI/DirtyRegionTracker
$include UI/Drawable2D
$include UI/Entity
$include UI/EntityCollector
$include UI/Event
$include UI/Keyboard
$include UI/Placement2D
$include UI/Pointer
$include UI/UIBorder
$include UI/UIComponent
$include UI/UIContent
$include UI/UIFiller
$include UI/UIFlowLayout
$include UI/UIFont
$include UI/UIHorizontalLayout
$include UI/UILabel
$include UI/UILayout
$include UI/UIList
$include UI/UIScrollView
$include UI/UIScrollViewController
$include UI/UISpacer
$include UI/UIStackLayout
$include UI/UITableLayout
$include UI/UIText
$include UI/UIVerticalLayout
$include UI/UIWidget

class UI : UILayout
  GLOBAL PROPERTIES
    active : UI

  PROPERTIES
    default_font         : UIFont

    dirty_region_tracker = SimpleDirtyRegionTracker() : DirtyRegionTracker
    clip                 : Box?
    dt                   = 1.0 / 60.0

    pointer_focus        : UIComponent
    keyboard_focus       : UIComponent

  METHODS
    method init_object
      active = this

    method activate
      active = this

    method clear
      prior.clear
      clear_focus
      dirty_bounds = null
      clip = null

    method clear_focus
      keyboard_focus = null
      pointer_focus = null

    method clip->Box?
      return @clip

    method default_font->UIFont
      if (@default_font) return @default_font
      Console.error.println "[UI] No .default_font configured."
      return null

    method dirty_region_tracker->DirtyRegionTracker
      if (@dirty_region_tracker) return @dirty_region_tracker
      dirty_region_tracker = SimpleDirtyRegionTracker()
      return @dirty_region_tracker

    method draw
      activate
      update_display_state

      use drawables = collect<<Drawable2D>>( (drawable) => return drawable.needs_redraw, &all )
        dirty_region_tracker.add( forEach in drawables )
        (forEach in drawables).needs_redraw = false
      endUse

      use dirty_regions = dirty_region_tracker
        if (dirty_regions.count)
          dirty_region_tracker.clear

          use drawables = collect<<Drawable2D>>
            drawables.sort( $1.draw_order < $2.draw_order )

            forEach (dirty_region in dirty_regions)
              temporarily clip = dirty_region
                on_draw
                (forEach in drawables).draw
                after_draw
              endTemporarily
            endForEach

            (forEach in drawables).save_display_state
          endUse
        endIf
      endUse

    method handle( e:KeyEvent )
      on( e )
      if (e.is_consumed) return

      if (keyboard_focus)
        if (not keyboard_focus.is_hidden and not keyboard_focus.input_disabled)
          keyboard_focus.handle( e )
        else
          keyboard_focus.release_keyboard_focus
          (forEach in layers).handle( e )
        endIf
      else
        (forEach in layers).handle( e )
      endIf
      if (e.is_consumed) return

      after( e )

      #{
      on( e )
      if (e.is_consumed) return

      if (keyboard_focus)
        if (not keyboard_focus.is_hidden and not keyboard_focus.input_disabled)
          keyboard_focus.handle( e )
        else
          keyboard_focus.release_keyboard_focus
          (forEach in layers).handle( e )
        endIf
      else
        (forEach in layers).handle( e )
      endIf
      if (e.is_consumed) return

      after( e )
      }#

    method handle( e:PointerEvent )
      on( e )
      if (e.is_consumed) return

      if (pointer_focus)
        if (not pointer_focus.is_hidden and not pointer_focus.input_disabled)
          pointer_focus.handle( e )
        else
          pointer_focus.release_pointer_focus
          (forEach in layers).handle( e )
        endIf
      else
        (forEach in layers).handle( e )
      endIf
      if (e.is_consumed) return

      after( e )

    method handle( e:ScrollEvent )
      on( e )
      if (e.is_consumed) return

      if (pointer_focus)
        pointer_focus.handle( e )
      else
        (forEach in layers).handle( e )
      endIf
      if (e.is_consumed) return

      after( e )

    method handle( e:TextEvent )
      on( e )
      if (e.is_consumed) return

      if (keyboard_focus)
        keyboard_focus.handle( e )
      else
        (forEach in layers).handle( e )
      endIf
      if (e.is_consumed) return

      after( e )

    method release_keyboard_focus
      if (keyboard_focus) keyboard_focus.release_pointer_focus

    method release_pointer_focus
      if (pointer_focus) pointer_focus.release_pointer_focus

    method request_redraw
      request_redraw( bounds )

    method request_redraw( bounds:Box )
      dirty_region_tracker.add( bounds )

    method set_bounds( value:Box )
      localize bounds
      if (value == bounds) return

      dirty_region_tracker.add( bounds )
      prior.set_bounds( value )
      dirty_region_tracker.add( value )

      needs_layout = true

      on_resize

      use drawables = collect<<Drawable2D>>
        (forEach in drawables).on_resize
        DynamicProperties.on_resize( forEach in drawables )
        (forEach in drawables).after_resize
      endUse

      after_resize

    method set_clip( @clip )

    method update
      # Must update before layout so that new components created in update() can be
      # measured in update_layout()
      activate
      prior.update
      update_layout

    method update_display_state
      prior.update_display_state

      use drawables = collect<<Drawable2D>>( &all )
        (forEach in drawables).update_display_state
      endUse

    method update_layout
      activate
      needs_layout = false

      local og_size = placement.size

      prepare_layout

      use components = collect<<UIComponent>>( &all )
        on_update_layout
        (forEach in components).on_update_layout

        update_layout_width( placement.size.x )
        update_layout_height( placement.size.y )
        update_layout_placement( bounds )

        (forEach in components).after_update_layout
        after_update_layout
      endUse

      if (placement.size != og_size) request_redraw

    method update_layout( new_bounds:Box )
      bounds = new_bounds
      update_layout

endClass
