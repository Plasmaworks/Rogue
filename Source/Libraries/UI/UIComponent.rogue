class UIComponent : Entity
  PROPERTIES
    anchor        = Anchor.TOP_LEFT : Anchor
    layout_mode   : LayoutModeXY
    layout_size   : XY
    layout_params : ParameterNames

  METHODS
    method init
      noAction

    method init( child:UIComponent )
      add( child )

    method on( e:KeyEvent )
      noAction

    method on( e:PointerEvent )
      noAction

    method on( e:ScrollEvent )
      noAction

    method on( e:TextEvent )
      noAction

    method on_end( e:KeyEvent )
      noAction

    method on_end( e:PointerEvent )
      noAction

    method on_end( e:ScrollEvent )
      noAction

    method on_end( e:TextEvent )
      noAction

    method on_end_draw
      noAction

    method on_draw
      noAction

    method on_release_keyboard_focus
      noAction

    method on_release_pointer_focus
      noAction

    method on_update_size
      noAction

    $localMacro DISPATCH_EVENT
      # Send input events to children in reverse order because the top layer comes last
      next_component?.dispatch( e )
      if (e.is_consumed) return
      handle( e )
    $endLocalMacro

    method dispatch( e:KeyEvent )
      DISPATCH_EVENT

    method dispatch( e:PointerEvent )
      DISPATCH_EVENT

    method dispatch( e:ScrollEvent )
      DISPATCH_EVENT

    method dispatch( e:TextEvent )
      DISPATCH_EVENT

    method draw
      on_draw
      (forEach as UIComponent in children).draw
      on_end_draw

    method first_child_component->UIComponent
      forEach (child as UIComponent in children)
        return child
      endForEach
      return null

    method handle( e:KeyEvent )
      if (attributes.hidden or attributes.input_disabled) return

      on( e )
      if (e.is_consumed) return

      first_child_component?.dispatch( e )
      if (e.is_consumed) return

      on_end( e )

    method handle( e:PointerEvent )
      if (attributes.hidden or attributes.input_disabled) return

      on( e )
      if (e.is_consumed) return

      first_child_component?.dispatch( e )
      if (e.is_consumed) return

      on_end( e )

    method handle( e:ScrollEvent )
      if (attributes.hidden or attributes.input_disabled) return

      on( e )
      if (e.is_consumed) return

      first_child_component?.dispatch( e )
      if (e.is_consumed) return

      on_end( e )

    method handle( e:TextEvent )
      if (attributes.hidden or attributes.input_disabled) return

      on( e )
      if (e.is_consumed) return

      first_child_component?.dispatch( e )
      if (e.is_consumed) return

      on_end( e )

    method next_component->UIComponent
      local next_entity = next
      local next_component = next_entity->(as UIComponent)
      while (next_entity and not next_component)
        next_entity = next_entity.next
        next_component = next_entity->(as UIComponent)
      endWhile
      return next_component

    method operator+( rhs:UIComponent )->UIComponent
      return UIGeneratedHBox( this ).[ add(rhs) ]

    #method operator/( rhs:UIComponent )->UIComponent
    #  return UIGeneratedVBox( this ).[ add(rhs) ]

    #method operator|( rhs:UIComponent )->UIComponent
    #  return UIGeneratedStack( this ).[ add(rhs) ]

    method perform_layout( position )
      (forEach as UIComponent in children).perform_layout( position )

    method proportional( layout_size )
      layout_mode = LayoutModeXY( LayoutMode.PROPORTIONAL, LayoutMode.PROPORTIONAL )

    method proportional_height( h:Real )
      layout_size.y = h
      layout_mode.y = LayoutMode.PROPORTIONAL

    method proportional_width( w:Real )
      layout_size.x = w
      layout_mode.x = LayoutMode.PROPORTIONAL

    method release_keyboard_focus
      if (UI.keyboard_focus is this)
        UI.keyboard_focus = null
        on_release_keyboard_focus
      endIf

    method release_pointer_focus
      if (UI.pointer_focus is this)
        UI.pointer_focus = null
        on_release_pointer_focus
      endIf

    method update_child_layout_heights( available_size:XY )
      (forEach as UIComponent in children).update_layout_height( available_size )

    method update_child_layout_widths( available_size:XY )
      (forEach as UIComponent in children).update_layout_width( available_size )

    method update_shrink_to_fit_layout_height( available_size:XY, &limited )->Real
      local h = 0.0
      h = h.or_larger( (forEach as UIComponent in children).update_layout_height( XY(available_size.x,0), &=limited ) )
      size.y = h
      return h

    method update_shrink_to_fit_layout_width( available_size:XY, &limited )->Real
      local w = 0.0
      w = w.or_larger( (forEach as UIComponent in children).update_layout_width( XY(0,available_size.y), &=limited ) )
      size.x = w
      return w

    method update_layout_height( available_size:XY, &limited )->Real
      if (layout_mode.y == LayoutMode.SHRINK_TO_FIT)
        return update_shrink_to_fit_layout_height( available_size, &=limited )
      else
        which (layout_mode.y)
          case EXPAND_TO_FILL
            size.y = available_size.y
          case ASPECT_FIT
            local fit_y = ((available_size.x / (layout_size.x || 1.0)) * layout_size.y).floor
            if (layout_mode.x == LayoutMode.ASPECT_FILL or fit_y <= available_size.y)
              size.y = fit_y
            else
              size.y = available_size.y
            endIf
          case ASPECT_FILL
            if (layout_mode.x != LayoutMode.ASPECT_FIT)
              local scale_x = (available_size.x / (layout_size.x || 1.0))
              local scale_y = (available_size.y / (layout_size.y || 1.0))
              size.y = (scale_x.or_larger(scale_y) * layout_size.y).floor
            endIf
          case PROPORTIONAL
            size.y = (available_size.y * layout_size.y).floor
          case FIXED_SIZE
            size.y = layout_size.y
          #case PARAMETER
        endWhich

        if (not limited)
          update_child_layout_heights( XY(available_size.x,size.y) )
        endIf

        return size.x
      endIf

    method update_layout_width( available_size:XY, &limited )->Real
      if (layout_mode.x == LayoutMode.SHRINK_TO_FIT)
        return update_shrink_to_fit_layout_width( available_size, &=limited )
      else
        which (layout_mode.x)
          case EXPAND_TO_FILL
            size.x = available_size.x
          case ASPECT_FIT
            local fit_x = ((available_size.y / (layout_size.y || 1.0)) * layout_size.x).floor
            if (layout_mode.y == LayoutMode.ASPECT_FILL or fit_x <= available_size.x)
              size.x = fit_x
            else
              size.x = available_size.x
            endIf
          case ASPECT_FILL
            if (layout_mode.y != LayoutMode.ASPECT_FIT)
              local scale_x = (available_size.x / (layout_size.x || 1.0))
              local scale_y = (available_size.y / (layout_size.y || 1.0))
              size.x = (scale_x.or_larger(scale_y) * layout_size.x).floor
            endIf
          case PROPORTIONAL
            size.x = (available_size.x * layout_size.x).floor
          case FIXED_SIZE
            size.x = layout_size.x
          #case PARAMETER
        endWhich

        if (not limited)
          update_child_layout_widths( XY(size.x,available_size.y) )
        endIf

        return size.x
      endIf

    method update_size
      (forEach as UIComponent in children).update_size
      on_update_size
endClass
