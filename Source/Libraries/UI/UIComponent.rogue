class UIComponent : Entity
  PROPERTIES
    anchor        = Anchor.TOP_LEFT : Anchor
    alignment     : Anchor?
    layout_mode   : LayoutModeXY
    layout_size   : XY
    weight        = XY(1,1)
    layout_params : ParameterNames

  METHODS # Overrides
    method init
      noAction

    method init( child:UIComponent )
      add( child )

    method on( e:KeyEvent )
      noAction

    method on( e:PointerEvent )
      noAction

    method on( e:ScrollEvent )
      noAction

    method on( e:TextEvent )
      noAction

    method on_end( e:KeyEvent )
      noAction

    method on_end( e:PointerEvent )
      noAction

    method on_end( e:ScrollEvent )
      noAction

    method on_end( e:TextEvent )
      noAction

    method on_end_draw
      noAction

    method on_draw
      noAction

    method on_release_keyboard_focus
      noAction

    method on_release_pointer_focus
      noAction

    method on_update_size
      noAction

  METHODS # Public API
    method align( @alignment )
      noAction

    method alignment->Anchor
      if local result = @alignment
        return result
      else
        if local parent_component = parent->(as UIComponent)
          return parent_component.alignment
        else
          return Anchor.CENTER
        endIf
      endIf

    method aspect_fill( layout_size )
      layout_mode = LayoutModeXY( LayoutMode.ASPECT_FILL, LayoutMode.ASPECT_FILL )

    method aspect_fill_height( layout_size )
      layout_mode.y = LayoutMode.ASPECT_FILL

    method aspect_fill_width( layout_size )
      layout_size.x = w
      layout_mode.x = LayoutMode.ASPECT_FILL

    method aspect_fit( layout_size )
      layout_mode = LayoutModeXY( LayoutMode.ASPECT_FIT, LayoutMode.ASPECT_FIT )

    method aspect_fit_height( layout_size )
      layout_mode.y = LayoutMode.ASPECT_FIT

    method aspect_fit_width( layout_size )
      layout_size.x = w
      layout_mode.x = LayoutMode.ASPECT_FIT

    method bg_color->Color?
      return parent->(as UIComponent)?.bg_color

    $localMacro DISPATCH_EVENT
      # Send input events to children in reverse order because the top layer comes last
      next_component?.dispatch( e )
      if (e.is_consumed) return
      handle( e )
    $endLocalMacro

    method collect_child_display_components( list:UIComponent[] )
      # Collect child components that need to be laid out, skipping any meta-components.
      (forEach as UIComponent in children).collect_display_components( list )

    method collect_display_components( list:UIComponent[] )
      if (is_display_component)
        list.add( this )
      else
        collect_child_display_components( list )
      endIf

    method color->Color?
      return parent->(as UIComponent)?.color

    method is_display_component->Logical
      # If false, this component is considered an informational meta-component.
      return true

    method dispatch( e:KeyEvent )
      DISPATCH_EVENT

    method dispatch( e:PointerEvent )
      DISPATCH_EVENT

    method dispatch( e:ScrollEvent )
      DISPATCH_EVENT

    method dispatch( e:TextEvent )
      DISPATCH_EVENT

    method display_bounds->Box
      return Box( display_position, size )

    method display_position->XY
      if local parent_component = parent->(as UIComponent)
        return parent_component.display_position + position
      endIf

    method draw
      on_draw
      use components = WorkList<<UIComponent>>
        collect_child_display_components( components )
        (forEach in components).draw
      endUse
      on_end_draw

    method find_h_split( max_width:Real )->Real?
      return null

    method first_child_component->UIComponent
      forEach (child as UIComponent in children)
        return child
      endForEach
      return null

    method fixed_size( layout_size )
      layout_mode = LayoutModeXY( LayoutMode.FIXED_SIZE, LayoutMode.FIXED_SIZE )

    method fixed_height( h:Real )
      layout_size.y = h
      layout_mode.y = LayoutMode.FIXED_SIZE

    method fixed_width( w:Real )
      layout_size.x = w
      layout_mode.x = LayoutMode.FIXED_SIZE

    method font->UIFont
      return parent->(as UIComponent)?.font

    method handle( e:KeyEvent )
      if (attributes.hidden or attributes.input_disabled) return

      on( e )
      if (e.is_consumed) return

      first_child_component?.dispatch( e )
      if (e.is_consumed) return

      on_end( e )

    method handle( e:PointerEvent )
      if (attributes.hidden or attributes.input_disabled) return

      on( e )
      if (e.is_consumed) return

      first_child_component?.dispatch( e )
      if (e.is_consumed) return

      on_end( e )

    method handle( e:ScrollEvent )
      if (attributes.hidden or attributes.input_disabled) return

      on( e )
      if (e.is_consumed) return

      first_child_component?.dispatch( e )
      if (e.is_consumed) return

      on_end( e )

    method handle( e:TextEvent )
      if (attributes.hidden or attributes.input_disabled) return

      on( e )
      if (e.is_consumed) return

      first_child_component?.dispatch( e )
      if (e.is_consumed) return

      on_end( e )

    method is_br->Logical
      return false

    method is_space->Logical
      return false

    method next_component->UIComponent
      local next_entity = next
      local next_component = next_entity->(as UIComponent)
      while (next_entity and not next_component)
        next_entity = next_entity.next
        next_component = next_entity->(as UIComponent)
      endWhile
      return next_component

    method operator+( rhs:UIComponent )->UIComponent
      return UIGeneratedHBox( this ).[ add(rhs) ]

    method operator/( rhs:UIComponent )->UIComponent
      return UIGeneratedVBox( this ).[ add(rhs) ]

    method operator|( rhs:UIComponent )->UIComponent
      return UIGeneratedStack( this ).[ add(rhs) ]

    method perform_layout( position )
      localize bounds
      use components = WorkList<<UIComponent>>
        collect_child_display_components( components )
        forEach (component in components)
          component.perform_layout( component.bounds.positioned_within(bounds,alignment).position )
        endForEach
      endUse

    method proportional( layout_size )
      layout_mode = LayoutModeXY( LayoutMode.PROPORTIONAL, LayoutMode.PROPORTIONAL )

    method proportional_height( h:Real )
      layout_size.y = h
      layout_mode.y = LayoutMode.PROPORTIONAL

    method proportional_width( w:Real )
      layout_size.x = w
      layout_mode.x = LayoutMode.PROPORTIONAL

    method release_keyboard_focus
      if (UI.keyboard_focus is this)
        UI.keyboard_focus = null
        on_release_keyboard_focus
      endIf

    method release_pointer_focus
      if (UI.pointer_focus is this)
        UI.pointer_focus = null
        on_release_pointer_focus
      endIf

    method request_layout
      UI.needs_layout = true

    method request_redraw
      UI.needs_redraw = true

    method resolve_layout_size( available_size:XY, &limited )->XY
      local sz = available_size

      which (layout_mode.x)
        case EXPAND_TO_FILL
          noAction
        case SHRINK_TO_FIT
          sz.x = 0
        case ASPECT_FIT
          local fit_x = ((available_size.y / (layout_size.y || 1.0)) * layout_size.x).floor
          if (layout_mode.y == LayoutMode.ASPECT_FILL or fit_x <= available_size.x)
            sz.x = fit_x
          else
            sz.x = available_size.x
          endIf
        case ASPECT_FILL
          if (layout_mode.y != LayoutMode.ASPECT_FIT)
            local scale_x = (available_size.x / (layout_size.x || 1.0))
            local scale_y = (available_size.y / (layout_size.y || 1.0))
            sz.x = (scale_x.or_larger(scale_y) * layout_size.x).floor
          endIf
        case PROPORTIONAL
          sz.x = (available_size.x * layout_size.x).floor
        case FIXED_SIZE
          sz.x = layout_size.x
        #case PARAMETER
      endWhich

      which (layout_mode.y)
        case EXPAND_TO_FILL
          sz.y = available_size.y
        case SHRINK_TO_FIT
          sz.y = 0
        case ASPECT_FIT
          local fit_y = ((available_size.x / (layout_size.x || 1.0)) * layout_size.y).floor
          if (layout_mode.x == LayoutMode.ASPECT_FILL or fit_y <= available_size.y)
            sz.y = fit_y
          else
            sz.y = available_size.y
          endIf
        case ASPECT_FILL
          if (layout_mode.x != LayoutMode.ASPECT_FIT)
            local scale_x = (available_size.x / (layout_size.x || 1.0))
            local scale_y = (available_size.y / (layout_size.y || 1.0))
            sz.y = (scale_x.or_larger(scale_y) * layout_size.y).floor
          endIf
        case PROPORTIONAL
          sz.y = (available_size.y * layout_size.y).floor
        case FIXED_SIZE
          sz.y = layout_size.y
        #case PARAMETER
      endWhich

      size = sz

      if (layout_mode.x == LayoutMode.SHRINK_TO_FIT or layout_mode.y == LayoutMode.SHRINK_TO_FIT)
        local shrunk_size = resolve_shrink_to_fit_layout_size( sz, &=limited )
        if (layout_mode.x == LayoutMode.SHRINK_TO_FIT) sz.x = shrunk_size.x
        if (layout_mode.y == LayoutMode.SHRINK_TO_FIT) sz.y = shrunk_size.y
        size = sz
      endIf

      if (not limited)
        resolve_child_layout_sizes
      endIf

      return sz

    method set_structure_modified( setting:Logical ) [override]
      prior.set_structure_modified( setting )
      if (setting) request_layout

    method shrink_to_fit
      layout_mode = LayoutModeXY( LayoutMode.SHRINK_TO_FIT, LayoutMode.SHRINK_TO_FIT )

    method shrink_to_fit_height
      layout_mode.y = LayoutMode.SHRINK_TO_FIT

    method shrink_to_fit_width
      layout_mode.x = LayoutMode.SHRINK_TO_FIT

    method split_h( split_position:Real, components:UIComponent[], component_i:Int )
      noAction

    method resolve_child_layout_sizes
      local available_size = size.xy
      use components = WorkList<<UIComponent>>
        collect_child_display_components( components )
        (forEach in components).resolve_layout_size( available_size )
      endUse

    method resolve_shrink_to_fit_layout_size( available_size:XY, &limited )->XY
      local sz : XY
      use components = WorkList<<UIComponent>>
        collect_child_display_components( components )
        sz = sz.or_larger( (forEach in components).resolve_layout_size( available_size, &=limited ) )
      endUse
      if (layout_mode.x == LayoutMode.SHRINK_TO_FIT) size.x = sz.x
      if (layout_mode.y == LayoutMode.SHRINK_TO_FIT) size.y = sz.y
      return size.xy

    method update_size
      use components = WorkList<<UIComponent>>
        collect_child_display_components( components )
        (forEach in components).update_size
      endUse
      on_update_size
endClass

class UIGeneratedStack : UIComponent
  # Special subclass for operator overrides
  METHODS
    method operator|( rhs:UIComponent )->UIComponent [override]
      add( rhs )
      return this
endClass
