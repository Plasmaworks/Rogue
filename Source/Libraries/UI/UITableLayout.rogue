module UI
uses Utility/WorkList

class UITableLayout : UILayout
  PROPERTIES
    is_adding  : Logical
    next_empty : Int32
    columns    = UITableColumnInfo[]
    rows       = UITableRowInfo[]
    span       = XY[]

  METHODS
    method init
      init( 1, 1 )

    method init( size:XY )
      prior.init( size )
      resize( 1, 1 )

    method init( column_count:Int32, row_count:Int32 )
      prior.init
      resize( column_count, row_count )

    method add( component:UIComponent ) [override]
      if (is_adding)
        prior.add( component )
      else
        is_adding = true

        if (next_empty == -1)
          if (columns.is_empty)
            resize( 1, rows.count )
            add( component )
            is_adding = false
            return
          else
            resize( columns.count, rows.count+1 )
          endIf
        endIf

        set( next_empty, component )
        _advance_next_empty

        is_adding = false
      endIf

    method column( i:Int32 )->UITableColumnInfo
      if (i < 0 or i >= columns.count) throw OutOfBoundsError( i, columns.count )
      return columns[i]

    method get( i:Int32, j:Int32 )->UIComponent
      local index = index_of( i, j )
      if (not index) return null
      return get( index.value )

    method index_of( i:Int32, j:Int32 )->Int32?
      if (i < 0 or i >= columns.count) return null
      if (j < 0 or j >= rows.count)    return null
      return j*columns.count + i

    method measure_content_height( subcomponents:UIComponent[] )->Real64?
      local total_h = 0.0
      forEach (j of rows)
        local h = _row_height( subcomponents, j )
        if (not h) return null
        total_h += h.value
      endForEach
      return total_h

    method measure_content_width( subcomponents:UIComponent[] )->Real64?
      local total_w = 0.0
      forEach (i of columns)
        local w = _column_width( subcomponents, i )
        if (not w) return null
        total_w += w.value
      endForEach
      return total_w

    method resize( new_columns:Int32, new_rows:Int32 )
      next_empty = -1
      if (count)
        # Remove cells or add empty cells to maintain structure
        if (new_columns == 0 or new_rows == 0)
          clear
        else
          use new_cells = WorkList<<UIComponent>>
            forEach (j in 0..<new_rows)
              forEach (i in 0..<new_columns)
                local cell = get( i, j )
                if (cell) new_cells.add( cell )
                else      new_cells.add( UITableEmptyCell() )
              endForEach
            endForEach
            clear
            prior.add( forEach in new_cells )
          endUse

          use new_span = WorkList<<XY>>
            forEach (j in 0..<new_rows)
              forEach (i in 0..<new_columns)
                local index = index_of( i, j )
                if (index?) new_span.add( span[index.value] )
                else        new_span.add( XY(1,1) )
              endForEach
            endForEach
            span.clear
            span.add( new_span )
          endUse
        endIf
      else
        loop (new_columns*new_rows) prior.add( UITableEmptyCell() )
        if (count) next_empty =  0
        else       next_empty = -1
      endIf

      while (columns.count < new_columns) columns.add( UITableColumnInfo() )
      while (rows.count < new_rows) rows.add( UITableRowInfo() )
      columns.discard_from( new_columns )
      rows.discard_from( new_rows )
      loop (columns.count*rows.count - span.count) span.add( XY(1,1) )

      _advance_next_empty

    method row( j:Int32 )->UITableRowInfo
      if (j < 0 or j >= rows.count) throw OutOfBoundsError( j, rows.count )
      return rows[j]

    method set( i:Int32, j:Int32, component:UIComponent )
      local index = j * columns.count + i
      set( index, component )
      if (index == next_empty) _advance_next_empty

    method set_span( i:Int32, j:Int32, new_span:XY )
      local index = index_of(i,j)
      require index.exists
      span[index.value] = new_span

    method span( i:Int32, j:Int32 )->XY
      local index = index_of(i,j)
      require index
      return span[index.value]

    method update_subcomponent_heights( subcomponents:UIComponent[], container_height:Real64 )
      local total_h = 0.0
      local undefined_count = 0
      local undefined_weight = 0.0

      use row_heights = WorkList<<Real64?>>
        forEach (j of rows)
          local h = _row_height( subcomponents, j )
          if (h)
            total_h += h.value
            forEach (i of columns)
              local cell = subcomponents[ j*columns.count + i ]
              cell.update_layout_height( h.value )
            endForEach
            row_heights.add( h )
          else
            ++undefined_count
            undefined_weight += rows[j].weight
            row_heights.add( null )
          endIf
        endForEach

        undefined_weight .= clamped_low(1)
        local excess_h = container_height - total_h
        local remaining_h = excess_h
        forEach (j of rows)
          local h = row_heights[j]
          if (not h)
            if (undefined_count == 1)
              h = remaining_h
            else
              h = (excess_h * (rows[j].weight / undefined_weight)).floor
              remaining_h -= h.value
            endIf
            --undefined_count
            forEach (i of columns)
              local cell = subcomponents[ j*columns.count + i ]
              cell.update_layout_height( h.value )
            endForEach
          endIf
        endForEach
      endUse

    method update_subcomponent_widths( subcomponents:UIComponent[], container_width:Real64 )
      local total_w = 0.0
      local undefined_count = 0
      local undefined_weight = 0.0

      use column_widths = WorkList<<Real64?>>
        forEach (i of columns)
          local w = _column_width( subcomponents, i )
          if (w)
            total_w += w.value
            forEach (j of rows)
              local cell = subcomponents[ j*columns.count + i ]
              cell.update_layout_width( w.value )
            endForEach
            column_widths.add( w )
          else
            ++undefined_count
            undefined_weight += columns[i].weight
            column_widths.add( null )
          endIf
        endForEach

        undefined_weight .= clamped_low(1)
        local excess_w = container_width - total_w
        local remaining_w = excess_w
        forEach (i of columns)
          local w = column_widths[i]
          if (not w)
            if (undefined_count == 1)
              w = remaining_w
            else
              w = (excess_w * (columns[i].weight / undefined_weight)).floor
              remaining_w -= w.value
            endIf
            --undefined_count
            forEach (j of rows)
              local cell = subcomponents[ j*columns.count + i ]
              cell.update_layout_width( w.value )
            endForEach
          endIf
        endForEach
      endUse

    method update_subcomponent_placement( subcomponents:UIComponent[], container:Box ) [override]
      local cursor_start = container.position
      forEach (j of rows)
        local cursor = cursor_start
        local row_height = 0.0
        forEach (i of columns)
          local cell = subcomponents[ j*columns.count + i ]
          cell.update_layout_placement( Box(cursor,cell.size) )
          cursor += cell.size.xv
          row_height = cell.size.y
        endForEach
        cursor_start += XY(0,row_height)
      endForEach

    method _advance_next_empty
      forEach (i in next_empty..<count)
        local cell = this[i]
        if (cell instanceOf UITableEmptyCell)
          next_empty = i
          return
        endIf
      endForEach
      next_empty = -1

    method _column_width( subcomponents:UIComponent[], i:Int32 )->Real64?
      local max_w = columns[i].width
      if (max_w) return max_w

      forEach (j of rows)
        local cell = subcomponents[ j*columns.count + i ]
        local w = cell.measure_width( null )
        if (w)
          if (max_w) max_w = max_w.value.or_larger( w.value )
          else       max_w = w.value
        endIf
      endForEach

      return max_w

    method _row_height( subcomponents:UIComponent[], j:Int32 )->Real64?
      local max_h = rows[j].height
      if (max_h) return max_h

      forEach (i of columns)
        local cell = subcomponents[ j*columns.count + i ]
        local h = cell.measure_height( null )
        if (h)
          if (max_h) max_h = max_h.value.or_larger( h.value )
          else       max_h = h.value
        endIf
      endForEach

      return max_h

endClass

class UITableEmptyCell : UIComponent
endClass

class UITableColumnInfo
  PROPERTIES
    width  : Real64?
    weight = 1.0
endClass

class UITableRowInfo
  PROPERTIES
    height : Real64?
    weight = 1.0
endClass

