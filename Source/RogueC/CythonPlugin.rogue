#{
TODO
====
- (Optionally?) Put a slot in the RogueObject structure that holds a reference
  to a Python object wrapping it so that we don't need to keep creating new
  wrappers.
- Force to_Strings to be essential?
- Have CyClass gather definitions and enumerations
- Support compounds
- Support more types of CmdAccess for default arguments (except just Global)
- Convert readers to iterators?
- Make more useful stuff essential? (e.g., table.count)
}#

augment RogueC
  METHODS
    method launch
      <collect_supported_targets>
      supported_targets.add( "Cython" )

      <validate_target_list>
      if (target_list.contains("Cython") and not target_list.contains("C++"))
        # Automatically add C++ target if Cython target is present.
        target_list.add( "C++" )
      endIf
endAugment

class CyMethod
  PROPERTIES
    cname : String             # True name of C function being wrapped (i.e., includes class name if any, etc.)
    pyname : String            # Name of method to expose to Python
    pyclass : String           # Name of class on which this method resides (or null for free functions)
    cproto_return : String     # C type of return value or null
    return_converter = "" : String  # Cython code to convert Rogue return value to Python return value
    call_args = String[]       # Cython code to construct each argument in a call to the Rogue code
    cproto_params = String[]   # Cython/C versions of each type in the param list of the Rogue function
    py_params = String[]       # The name of each parameter of the exposed Python wrapper

    is_initializer : Logical

    is_static_method : Logical

    valid : Logical

    defaults = String[]        # Default values of params
    py_types = String[]        # Types of params for overloading

    prologue = String[]        # Stuff that appears at top of Cython method

    real_method : Method

  METHODS
    method get_param_name (param:Local)->String
      if param.original_name.begins_with("@") return param.original_name.after(0)
      return param.original_name

    method to->String
      return "$($)->$" (full_name, cproto_params, cproto_return)

    method param_count -> Int32
      return cproto_params.count

    method full_name -> String
      if (pyclass) return "$.$" (pyclass, pyname)
      return pyname

    method init ( builder:CyClass, context:Type, m:Method, static_dispatch=false:Logical, force=false:Logical )
      if (m.is_task) return this
      if (m.is_abstract) return this
      if (m.is_task_conversion) return this
      if (m.omit_output and not force) return this

      # Basic setup
      pyname = m.name.before_first("<")
      pyclass = builder.get_p_type(context)

      if (m.name == "init_class" or m.name == "on_cleanup" or m.name == "init_object" or m.name == "init_class_thread_local")
        return this # Hide
      endIf

      cname = m.cpp_name
      is_initializer = m.is_initializer
      pyname = builder.fix_name(pyname)
      if (pyname == "") return this

      if (static_dispatch)
        is_static_method = true
      else
        call_args.add( "(<$*>check_type(self, $))" (m.type_context.cpp_class_name, builder.pytype) )
        # Probably don't need to check type for the this pointer...
        cproto_params.add( context.cpp_class_name + "*" )
      endIf

      # Return type
      return_converter = "%"
      if (not m.return_type)
        cproto_return = "void"
        return_converter = null
      else
        return_converter = builder.get_c_to_py(m.return_type)
        if (return_converter == "") return this # Not supported
        cproto_return = builder.get_c_type(m.return_type)
      endIf

      # Arguments
      forEach (param in m.parameters)
        local default = param.initial_value
        local negate = default and default instanceOf CmdNegate
        if (negate) default = (default->(as CmdNegate)).operand
        local negatable = false
        if default is null
          defaults.add "_NO_DEFAULT"
        elseIf default instanceOf CmdLiteralReal64
          defaults.add((default->(as CmdLiteralReal64)).value)
          negatable = true
        #elseIf default instanceOf CmdLiteralReal32
        #  defaults.add (default->(as CmdLiteralReal32)).value
        #  negatable = true
        elseIf default instanceOf CmdLiteralString
          defaults.add(''"""'' + (default->(as CmdLiteralString).value) + ''"""'') # Probably needs some special escaping
        elseIf default instanceOf CmdLiteralInt32
          defaults.add((default->(as CmdLiteralInt32)).value)
          negatable = true
        elseIf default instanceOf CmdLiteralInt64
          defaults.add((default->(as CmdLiteralInt64)).value)
          negatable = true
        elseIf default instanceOf CmdLiteralLogical
          defaults.add(which{(default->(as CmdLiteralLogical)).value: "True" || "False"})
        elseIf default instanceOf CmdLiteralNull
          defaults.add("None") # Probably doesn't actually work right yet...
        elseIf default instanceOf CmdLiteralCharacter
          defaults.add((default->(as CmdLiteralCharacter)).value->Int32)
        elseIf default instanceOf CmdAccess
          local cmd = (default->(as CmdAccess)).resolve(Scope(context,m), true)
          if cmd instanceOf CmdReadProperty and (cmd->(as CmdReadProperty)).property_info.type_context == Program.type_Global
            #TODO: Do this for all singletons and/or other types of Access?
            local rp = (cmd->(as CmdReadProperty))
            defaults.add "_PYROGUE_ACCESS"
            prologue.add "if $ is _PYROGUE_ACCESS: $ = Global.singleton.$" (param.name, param.name, rp.property_info.name)
            #TODO: With a little work, these could be negatable...
          else
            defaults.add "_NO_DEFAULT"
          endIf
        else
          defaults.add "_NO_DEFAULT"
        endIf

        if negate
          if negatable
            defaults[defaults.count-1] = "-" + defaults[defaults.count-1]
          else
            defaults[defaults.count-1] = "_NO_DEFAULT"
          endIf
        endIf

        py_types.add( builder.get_p_type(param.type) )

        py_params.add( get_param_name(param) )
        cproto_params.add( builder.get_c_type(param.type) )

        local a = builder.get_py_to_c(param.type)
        if (a == "") return this
        call_args.add a.replacing("%", get_param_name(param))
      endForEach

      # Fix defaults so they're all on the right.  This may mean the Python
      # bindings require more parameters than in Rogue.
      if defaults.count
        local no_defaults = false
        forEach i in 1..defaults.count
          local j = defaults.count - i
          if defaults[j] == "_NO_DEFAULT"
            no_defaults = true
          elseIf no_defaults
            defaults[j] = "_NO_DEFAULT"
          endIf
        endForEach
      endIf

      real_method = m
      valid = true

    method hash_code->Int32
      return this->String.hash_code
endClass


class CyProperty
  PROPERTIES
    valid = false
    pyname = ""
    context : Type
    is_static = false
    prop : Property
    ctype = ""
    cname = ""

    read_c_code = ""
    write_c_code = ""
  METHODS
    method init (pycls:CyClass, context, p:Property, is_static)
      pyname = pycls.fix_name(p.name)
      if (not pyname or pyname == "") return this

      this.prop = p
      this.ctype = pycls.get_c_type(p.type)

      cname = "Rogue$_$" (context.cpp_name, p.cpp_name)

      local access : String
      if (is_static)
        access = cname
      else
        access = "(<$*>check_type(self, $)).$" (context.cpp_class_name, pycls.pytype, p.cpp_name)
        cname = p.cpp_name
      endIf

      read_c_code = pycls.get_c_to_py(p.type).replacing("%", access)
      if (read_c_code == "") return this

      local call_code = pycls.get_py_to_c(p.type).replacing("%", "value")
      if (call_code == "") return this # Not supported
      write_c_code = "$ = $" (access, call_code)

      if (p.is_native) return # Not currently supported

      valid = true
endClass


class CyClass
  PROPERTIES
    pytype : String
    type : Type
    funcs = Table<<String, CyMethod[]>>()
    properties = Table<<String, CyProperty>>()

  GLOBAL PROPERTIES
    ctypes : Table<<String, String>> # RogueType -> C type
    bad_names = Set<<String>>()

  GLOBAL METHODS
    method initialize
      # We steer clear of these names (by mangling)
      local keywords = @|and       del       from      not       while
                        |as        elif      global    or        with
                        |assert    else      if        pass      yield
                        |break     except    import    print
                        |class     exec      in        raise
                        |continue  finally   is        return
                        |def       for       lambda    try
      forEach (k in keywords.split())
        bad_names.add(k)
      endForEach

    method fix_name ( n:String ) -> String
      if (bad_names.contains(n))
        return n + "_"
      endIf
      if (n == 'to_String') return '__str__'
      if (n == 'operator==') return '_eq_'
      if (n == 'operator<=') return '_le_'
      if (n == 'operator>=') return '_ge_'
      if (n == 'operator!=') return '_ne_'
      if (n == 'operator<') return '_lt_'
      if (n == 'operator>') return '_gt_'
      if (n == 'operator+') return '_add_'
      #if (n == 'operator<>') return '_cmp_' # Doesn't work in Rogue yet?
      #if (n == 'hash_code') return '__hash__' # Handle this in Py base class
      if (n.begins_with('operator'))
        #println "** Unhandled operator: $ **" (n)
        #TODO: Handle this?
        return ""
      endIf
      if n.begins_with('to_') and n.ends_with('[]')
        # This probably isn't general enough (list of lists?)
        return n.clipped(&right=2) + '_array'
      endIf
      return n

    method get_c_type ( t:Type ) -> String
      if (t.is_reference)
        return t.cpp_class_name + "*"
      endIf
      return t.cpp_class_name

    method get_c_to_py ( t:Type ) -> String
      # Creates a code template that turns the argument (a C expression of
      # type t) into a Python value or throws an exception
      # Returns empty string if conversion not possible
      if (get_p_type(t) == "") return ""
      if (t is Program.type_String)
        return "pyrogue_get_string(%)"
      endIf
      if (t.is_reference)
        #local tn = get_p_type(t)
        #return tn + '(__pyrogue_new_instance=<intptr_t>%)'
        return "get_wrapper(<intptr_t>%)"
      endIf
      return '%'

    method get_py_to_c ( t:Type ) -> String
      # Creates a code template that turns the argument (a Python expression)
      # into a C value consistent with t, or throws an exception
      # Returns empty string if conversion not possible
      if (get_p_type(t) == "") return ""
      local pass_ctype = get_c_type(t)
      if (pass_ctype == "") return ""
      if t.is_reference
        local pass_ptype = get_p_type(t)
        return "<$>cast_object(%, $)" (pass_ctype, pass_ptype)
      endIf
      return "<$>%" (pass_ctype)

    method get_p_type ( type:Type ) -> String
      # Gets the name of the equivalent/wrapped typed in Python, or
      # empty string if there is no such type.
      if (type is null) return ""
      if (type.is_array) return ""
      if (type.is_compound) return ""
      local pytype = type.name
      if pytype.ends_with("[]")
        return type.cpp_name
      elseIf pytype.contains("<<")
        if (not type.cpp_name) type.assign_cpp_name
        return type.cpp_name
      elseIf pytype.contains("(")
        return type.cpp_name
      endIf
      return type.name

  METHODS
    method init (type, force=false:Logical, do_properties=true:Logical)
      initialize()

      if (not type.is_class and not type.is_aspect and not force) return this

      pytype = get_p_type(type)

      if (pytype is null) return this

      this.type = type

      #TODO: Go through aspects? (Maybe not necessary?)

      forEach (m in type.global_method_list)
        local f = CyMethod( this, type, m, true, &force=force )
        if (f.is_initializer) nextIteration # Not useful
        if (not f.valid) nextIteration
        local dname = f.pyname
        if (not funcs.contains(dname)) funcs[dname] = CyMethod[]
        funcs[dname].add(f)
      endForEach

      forEach (m in type.method_list)
        local f = CyMethod( this, type, m, &force=force )
        if (not f.valid) nextIteration
        if (f.is_initializer) f.pyname = "_init_"
        local dname = f.pyname
        if (not funcs.contains(dname)) funcs[dname] = CyMethod[]
        funcs[dname].add(f)
      endForEach

      if do_properties
        forEach (p in type.property_list)
          local prop = CyProperty(this, type, p, false)
          if (prop.valid)
            properties[prop.pyname] = prop
          endIf
        endForEach

        forEach (p in type.global_list)
          local prop = CyProperty(this, type, p, true)
          if (prop.valid)
            properties[prop.pyname] = prop
          endIf
        endForEach
      endIf

  method to -> String
    return "($:$)" (type_name, type)
endClass


augment Program
  PROPERTIES
    cy_delegate_construction_pass = 0
    # Constructing delegate types takes two passes, each being a call to
    # cy_create_delegates() (which is invoked by the plugin type creation
    # hook).
    # In pass 0, we scan all types looking for existing delegates -- types
    # whose names start with "Function(".  For each of these, we create a
    # "pydelegate" type.  This is a subclass of the original, which will have
    # an overridden call() method that calls a Python callable.  The new type
    # gets parsed in pass 0, but it's not actually a type yet, which is why
    # we need pass 1.
    # In pass 1, the new pydelegate types will acually have been created, so
    # in this phase, we collect them into cy_delegates, creating a CyType
    # for them along the way.
    # Later passes do nothing, but we need to be prepared for them because
    # other plugins may result in us getting called more.

    cy_first_code_file = true
    # We may generate some C++ code, but we only need to do it once, so we
    # put it in the first C++ file and ignore the others.

    cy_delegates = Table<<Type, CyClass>>()
    # All Python delegates, both as their Type and a corresponding CyClass

    cy_delegate_to_pydelegate = Table<<Type, Type>>()
    # Maps from the basic "signature" type to the Python-specific subclass

    cy_overload_count = 0
    # Overload data for all classes is kept in a single table.  This tracks
    # how many entries it has so that we can generate code which refers to
    # the correct one.

    cy_plugin : Plugin
  METHODS
    method cy_on_header_end (code:Object)
      local writer = code->(as CPPWriter)
      if (writer is null) return

      # Declare (extern) for each delegate thunk function pointer
      cy_write_delegate_thunk_pointers(code->(as CPPWriter), &prefix="extern ", &suffix=";")

      writer.println @|extern void (*PyRogue_XDECREF)(void*);
                      |extern void (*PyRogue_XINCREF)(void*);
                      |struct PyRogueDelegateContext
                      |{
                      |  void * f;
                      |  RogueObject * exception;
                      |  PyRogueDelegateContext (void * f)
                      |  : f(f), exception(NULL)
                      |  {
                      |  }
                      |};
                      |extern void PyRogue_handle_rogue_exception ();

    method cy_on_code_end (code:Object)
      local writer = code->(as CPPWriter)
      if (writer is null) return

      if (not cy_first_code_file) return
      cy_first_code_file = false

      # Write out function pointers for all of the delegate thunks
      cy_write_delegate_thunk_pointers(code->(as CPPWriter), &suffix=";")

      writer.println @|void (*PyRogue_XDECREF)(void*);
                      |void (*PyRogue_XINCREF)(void*);

      writer.println @|
                      |#include <exception>
                      |#include <Python.h>
                      |void PyRogue_handle_rogue_exception ()
                      |{
                      |  try
                      |  {
                      |    throw;
                      |  }
                      |  catch (RogueException * e)
                      |  {
                      |    RogueString * msg = RogueException__format(e);
                      |    char buf[2048];
                      |    buf[2047] = 0;
                      |    if (msg && msg->character_count)
                      |      strncpy(buf, (char*)msg->utf8, 2047);
                      |    else
                      |      strcpy(buf, "Unknown Rogue exception");
                      |    PyErr_SetString(PyExc_RuntimeError, buf);
                      |  }
                      |  catch (const std::exception& e)
                      |  {
                      |    PyErr_SetString(PyExc_RuntimeError, e.what());
                      |  }
                      |}

    method cy_write_delegate_thunk_pointers (writer:CPPWriter, prefix="":String, suffix="":String)
      if (not writer) return
      forEach (cyclass in cy_delegates.values)
        local m = cyclass.funcs["call"][0]
        local func = find_function_root(cyclass.type)
        require func
        writer.println "$$ (*PyRogue_delegate_$)($)$" (prefix, m.cproto_return, func.cpp_name, ",".join(m.cproto_params), suffix)
      endForEach

    method cy_inject_rogue_classes
      # We smash in some new Rogue code.  This should probably be included
      # from the Rogue Python library, but that doesn't exist yet. :)
      local src = @|class PyRogueError : Error [essential]
                   |  PROPERTIES
                   |    exc_type : String
                   |    exc_value : String
                   |    exc_traceback : String
                   |  METHODS
                   |    method init (exc_type, exc_value, exc_traceback) [essential]
                   |      prior.init("Python $: $" (exc_type, exc_value))
                   |endClass
      Parser( "(compiler-generated-error)", src ).parse_elements

    method cy_create_delegates->Logical
      if cy_delegate_construction_pass == 0

        if Preprocessor.definitions.contains("PYROGUEFUNCTYPE")
          throw Error("[INTERNAL] Did not expect PYROGUEFUNCTYPE to be defined")
        endIf
        forEach (t in type_list)
          t.assign_cpp_name
          if (t.name.begins_with("PyFunction"))
            throw Error("[INTERNAL] We can't currently handle type names that start with 'PyFunction'")
          endIf
        endForEach
        forEach (t in type_list)
          if (not t.is_function) nextIteration
          if not t.method_lookup_by_name.contains("call")
            throw Error("[INTERNAL] Function type $ not callable?" (t))
          endIf
          if t.method_lookup_by_name["call"].count != 1
            throw Error("[INTERNAL] Function type callable in multiple ways?")
          endIf

          assert t.base_class is type_Object

          # Check if it's something we can wrap
          local ccls = CyClass(t, true)
          if (not ccls.funcs.contains('call')) nextIteration

          # Make all functions callable
          t.method_lookup_by_name["call"][0].make_essential

          # So t here is a Function type in Rogue.  We are going to create a
          # "PyFunction" -- a subclass of the Function type (t) where the call()
          # method calls into Python code.
          # The Python code is a callable Python object, which we keep track
          # of as a property of this subclass.
          # The actual code to call Python is easier to write in Cython, so
          # we do so -- Cython has a "thunk" for each signature.  The first
          # parameter, rather than being a "this" pointer, is the Python
          # callable.
          # Since I don't know how to create an extern with an unmangled name
          # from Cython, we instead generate a function pointer for each
          # thunk in the output C++ code, and these PyFunction classes call
          # via those.  We generate Cython code which actually implements the
          # thunks, and fills all of the function pointers to point to them.
          local m = t.method_lookup_by_name["call"][0]
          local params = String[]
          local args = String[]
          args.add( "&ctxt" )
          local i = 0
          forEach (p in m.parameters)
            i++
            params.add("param$:$" (i, p.type.name))
            args.add("$param$" ("$", i))
          endForEach

          local ret = ""         # Return type suffix if any, e.g., "->Foo"
          local thunk_call = ""  # Code to call the thunk
          local return_var = ""
          local do_return = ""

          if (t.callback_return_type)
            ret = "->" + t.callback_return_type.name
            thunk_call = "return_val = "
            return_var = "local return_val : " + t.callback_return_type.name
            do_return = "return return_val"
          endIf

          thunk_call += ''native("PyRogue_delegate_$($)")$'' (t.cpp_name, ",".join(args), ret)

          local src = "class PyFunction$ : PYROGUEFUNCTYPE [essential]\n" (t.cpp_type_name)
          src +=      "  PROPERTIES\n"
          #src +=      ''    native "void * _py_callable;"\n'' # Should be a pointer type
          src +=      "    _callable : IntPtr\n"
          src +=      "  METHODS\n"
          src +=      "    method call ($)$ [essential]\n" (",".join(params),ret)
          src +=      "      $" (return_var)
          src +=      "      local _py_callable = _callable\n"
          src +=      "      native \"PyRogueDelegateContext ctxt((void*)(intptr_t)$_py_callable);\"\n"
          src +=      "      $\n" (thunk_call)
          src +=      "      native(\";\")\n"
          src +=     @|      local err : Error
                      |      native "$err = (RogueClassError*)(ctxt.exception);"
                      |      if (err is not null) throw err
          src +=      "      $\n" (do_return)
          src +=     @|    method release
                      |      local _py_callable = _callable
                      |      _callable = 0
                      |      native "PyRogue_XDECREF((void*)(intptr_t)$_py_callable);"
                      |    method on_cleanup
                      |      release()
                      |endClass

          # Function type names with a return value can't directly be parsed as
          # a superclass name, so we don't put it directly in the string above,
          # and have the preprocessor insert it instead, which works fine.
          local filepath = "(compiler-generated)"
          Preprocessor.define( "PYROGUEFUNCTYPE", Tokenizer().tokenize(filepath,t.name) )
          Parser( filepath, src ).parse_elements
        endForEach

        cy_delegate_construction_pass++
        return true

      elseIf cy_delegate_construction_pass == 1
        # Now that our new function types have been created, we gather them
        # up into cy_delegates, creating a CyClass for them as we go, since
        # we'll need it later anyway.
        forEach (t in type_list)
          if (not t.name.begins_with("PyFunction")) nextIteration
          t.assign_cpp_name

          local ccls = CyClass(t, true)
          if (not ccls.funcs.contains('call')) nextIteration
          cy_delegates[t] = ccls
          local m = ccls.funcs['call'][0]

          m.cproto_params.remove_first()
          m.cproto_params.insert("void*")
          local base = find_function_root(t)
          require base
          cy_delegate_to_pydelegate[base] = t # Track signature->pydelegate
          cy_delegate_to_pydelegate[t] = t
        endForEach

        cy_delegate_construction_pass++
        return false
      endIf
      return false

    method find_function_root (t:Type)->Type
      # Get the "abstract" type of this function.
      # This is currently just the base class, but there was a period when
      # Functions were aspects.
      return t.base_class

    method configure
      if (RogueC.compile_targets["Cython"])
        RogueC.all_methods_callable_dynamically = true

        cy_plugin = Plugin("Cython")
        RogueC.plugins.add( cy_plugin )

        cy_plugin.on_generate_additional_types( this=>cy_create_delegates )
        cy_plugin.on_finish_header_file( this=>cy_on_header_end )
        cy_plugin.on_finish_code_file( this=>cy_on_code_end )
        cy_inject_rogue_classes()
      endIf

    method cy_write_cy_header (writer:CPPWriter, filepath:String)
      writer.println @|#!python
                      |#cython: optimize.unpack_method_calls=False

      writer.println @|# Generated by the Rogue compiler
                      |import sys
                      |from cpython cimport PyObject, Py_XINCREF, Py_XDECREF
                      |from libcpp cimport bool
                      |from libc.stdlib cimport malloc, free
                      |from libc.stdint cimport intptr_t, uint32_t
                      |cdef object Int32
                      |class Int32:
                      |  pass
                      |cdef object Int64
                      |class Int64:
                      |  pass
                      |cdef object Logical
                      |class Logical:
                      |  pass
                      |cdef object Real32
                      |class Real32:
                      |  pass
                      |cdef object Real64
                      |class Real64:
                      |  pass
                      |cdef object Character
                      |class Character:
                      |  pass
                      |cdef object Byte
                      |class Byte:
                      |  pass
      writer.println 'cdef extern from "$.h":' (filepath)
      writer.println @|  void Rogue_configure ( int argc, const char* argv[] )
                      |  void Rogue_launch ()
                      |  cdef cppclass RogueString:
                      |    int byte_count # in UTF-8 bytes
                      |    int character_count # in whole characters
                      |    int is_ascii
                      |    int hash_code
                      |    int utf8[]
                      |  cdef cppclass RogueType:
                      |    int index
                      |  cdef cppclass RogueObject:
                      |    RogueType * type
                      |  cdef cppclass RogueArray:
                      |    pass
                      |
                      |  cdef void PyRogue_handle_rogue_exception()
                      |
                      |  cdef cppclass PyRogueDelegateContext:
                      |    void * f
                      |    RogueObject * exception
                      |
                      |  ctypedef float RogueReal
                      |  ctypedef float RogueFloat
                      |  ctypedef int RogueLong
                      |  ctypedef int RogueInt32
                      |  ctypedef float RogueReal64
                      |  ctypedef float RogueReal32
                      |  ctypedef long RogueInt64
                      |  ctypedef int RogueInt32
                      |  ctypedef int RogueCharacter
                      |  ctypedef int RogueByte
                      |  ctypedef bool RogueLogical
                      |
                      |  RogueLogical RogueObject_instance_of( RogueObject* THIS, RogueType* ancestor_type )
                      |  RogueObject* RogueType_singleton( RogueType* THIS )
                      |  RogueObject* RogueType_create_object( RogueType* THIS, RogueInt32 size )
                      |  cdef RogueString* RogueString_create_from_utf8( const char* c_string, int count )
                      |  void* RogueObject_retain( RogueObject* THIS )
                      |  void* RogueObject_release( RogueObject* THIS )
                      |
                      |cdef object pyrogue_get_string (RogueString * str):
                      |  # May return bytes or Unicode string.  For Python 3,
                      |  # we probably should always do the latter.
                      |  if str.is_ascii:
                      |    return (<char*>str.utf8)[:str.byte_count]
                      |  return ((<char*>str.utf8)[:str.byte_count]).decode('UTF-8')
                      |
                      |Rogue_configure(0, NULL)
                      |Rogue_launch()
                      |
                      |cdef class PyRogueBase: #Should this merge into Object?
                      |  def __dealloc__ (self):
                      |    RogueObject_release(<RogueObject*>self.thisptr)
                      |    (<PyRogueBase>self).thisptr = NULL
                      |  def __richcmp__ (a, b, int op):
                      |    # Should we be replicating Rogue's missing-operator behavior in here?
                      |    if op == 0:
                      |      return a._lt_(b)
                      |    elif op == 1:
                      |      return a._le_(b)
                      |    elif op == 2:
                      |      return a._eq_(b)
                      |    elif op == 3:
                      |      return a._ne_(b)
                      |    elif op == 4:
                      |      return a._gt_(b)
                      |    elif op == 5:
                      |      return a._ge_(b)
                      |  def __add__ (self, other):
                      |    if hasattr(self, '_add_'):
                      |      return self._add_(other)
                      |    return TypeError("unsupported operand type(s) for +: '%s' and '%s'", type(self).__name__, type(other).__name__)
                      |  # We can't really copy Rogue objects, so don't try...
                      |  def __deepcopy__ (self, memo):
                      |    return self
                      |  def __copy__ (self):
                      |    return self
                      |  def __hash__ (self):
                      |    try:
                      |      return self.hash_code()
                      |    except:
                      |      return self.hash_code
                      |  def __getitem__ (self, key):
                      |    if hasattr(self, '_get_element'):
                      |      try:
                      |        return self._get_element(key)
                      |      except:
                      |        raise IndexError(str(sys.exc_info()[1]))
                      |    return self.get(key)
                      |  def __setitem__ (self, key, value):
                      |    if hasattr(self, '_set_element'):
                      |      try:
                      |        self._set_element(key, value)
                      |      except:
                      |        raise IndexError(str(sys.exc_info()[1]))
                      |      return
                      |    self.set(key, value)
                      |  def __len__ (self):
                      |    length = self.count
                      |    if callable(length): return length()
                      |    return length
                      |  cdef RogueObject *thisptr
                      |  def __repr__ (self):
                      |    return "<%s at %s (%s)>" % (type(self).__name__, hex(<intptr_t>self.thisptr), hex(id(self)))
                      |  def cast_to (self, othertype):
                      |    cdef PyRogueBase this
                      |    this = <PyRogueBase>self
                      |    cdef RogueType * other_ctype
                      |    other_ctype = <RogueType*><intptr_t>othertype._pyrogue_type()
                      |    if RogueObject_instance_of(this.thisptr, other_ctype):
                      |      return othertype(__pyrogue_new_instance=<intptr_t>this.thisptr)
                      |    raise TypeError("Object of type %s not compatible with type %s" % (type(self).__name__, othertype.__name__))
                      |
                      |cdef RogueObject * check_type (PyRogueBase o, t):
                      |  if isinstance(o, t): return o.thisptr
                      |  raise RuntimeError("Object %s is not of type %s" % (o, t))
                      |
                      |cdef object _rogue_type_index_to_pyclass = {}
                      |cdef object get_wrapper (intptr_t native_object_ptr):
                      |  cdef RogueObject * thisptr = <RogueObject*>native_object_ptr
                      |  cls = _rogue_type_index_to_pyclass[thisptr.type.index]
                      |  return cls(__pyrogue_new_instance=native_object_ptr)
                      |
                      |cdef void * cast_object (python_object, t) except <void*>-1:
                      |  """Cast a Python object to Rogue type t"""
                      |  if t is String:
                      |    if isinstance(python_object, str):
                      |      return RogueString_create_from_utf8(python_object, -1)
                      |    raise TypeError("Object %s is not of type %s" % (repr(python_object), t))
                      |  if python_object is None:
                      |    return NULL # Null pointers okay
                      |  if issubclass(t, _PyDelegate):
                      |    if hasattr(python_object, "__call__"):
                      |      return (<PyRogueBase>t._from_callable(python_object)).thisptr
                      |  cdef PyRogueBase rogue_object
                      |  rogue_object = python_object # Casting
                      |  if isinstance(rogue_object, t):
                      |    return rogue_object.thisptr
                      |  raise TypeError("Object %s is not of type %s" % (repr(python_object), t))
                      |
                      |# Method overload machinery
                      |class OverloadException (RuntimeError):
                      |  pass
                      |
                      |cdef object _PyDelegate
                      |class _PyDelegate (object):
                      |  """"We mark all function types with this"""
                      |  @classmethod
                      |  def _from_callable (cls, f):
                      |    assert f
                      |    #print "_from_callable", f, cls
                      |    d = cls._pyrogue_pydelegate_type()
                      |    cdef PyObject * fo
                      |    fo = <PyObject*>f
                      |    Py_XINCREF(fo)
                      |    d._callable = <intptr_t>fo
                      |    return d
                      |
                      |def _objptr(o):
                      |  return <long>((<PyRogueBase>o).thisptr)
                      |
                      |cdef object _NOTHING
                      |cdef object _NO_DEFAULT
                      |cdef object _PYROGUE_ACCESS
                      |cdef object _Overload
                      |cdef object _call_overload
                      |cdef object _overloads
                      |
                      |class _NOTHING:
                      |  pass
                      |
                      |class _NO_DEFAULT:
                      |  pass
                      |
                      |cdef int _M_PERFECT = 4
                      |cdef int _M_WIDEN = 3
                      |cdef int _M_NARROW = 1
                      |class _Overload (object):
                      |  def __init__ (self, types, keywords, defaults, func, static):
                      |    self.num_args = len(keywords)
                      |    self.types = types
                      |    self.keywords = keywords
                      |    self.defaults = defaults
                      |    self.func = func
                      |    self.static = static
                      |    nodefault = False
                      |    for i in range(len(defaults)-1, -1, -1):
                      |      if nodefault:
                      |        defaults[i] = _NO_DEFAULT
                      |      elif defaults[i] is _NO_DEFAULT:
                      |        nodefault = True
                      |  @property
                      |  def max_args_count (self):
                      |    return self.num_args
                      |  @property
                      |  def min_arg_count (self):
                      |    num_with_defaults = len(x for x in self.defaults if x is not _NO_DEFAULT)
                      |    return self.max_args_count - num_with_defaults
                      |  def keyword_index (self, kw):
                      |    return self.keywords.index(kw)
                      |  def is_compatible (self, arg, param_type):
                      |    # The match system is a bit funny, but I didn't immediately
                      |    # have better ideas given the availability of types in
                      |    # Python and Rogue.
                      |    if isinstance(arg, param_type): return _M_PERFECT
                      |    if param_type is Int32:
                      |      if type(arg) is int: return _M_PERFECT
                      |    elif param_type is Int64:
                      |      if type(arg) is long: return _M_PERFECT # Not really, but as good as it gets
                      |      if type(arg) is int: return _M_PERFECT # Close enough, and there's no better
                      |    elif param_type is Real64:
                      |      if type(arg) is float: return _M_PERFECT
                      |      if type(arg) is int: return _M_WIDEN #?
                      |      if type(arg) is long: return _M_NARROW
                      |    elif param_type is Real32:
                      |      if type(arg) is float: return _M_NARROW
                      |      if type(arg) is int: return _M_NARROW
                      |      if type(arg) is long: return _M_NARROW
                      |    elif param_type is Logical:
                      |      if arg is True or arg is False: return _M_PERFECT
                      |    elif param_type is Byte:
                      |      if type(arg) is int: return _M_NARROW
                      |    elif param_type is String:
                      |      if type(arg) is str: return _M_PERFECT
                      |    elif issubclass(param_type, _PyDelegate):
                      |      if hasattr(arg, '__call__'): return _M_PERFECT
                      |    elif arg is None and issubclass(param_type, PyRogueBase):
                      |      return _M_PERFECT
                      |    return False
                      |  def format (self):
                      |    r = []
                      |    for i,n in enumerate(self.keywords):
                      |      s = "%s %s" % (self.types[i], n)
                      |      if self.defaults[i] != _NO_DEFAULT: n += "=" + self.defaults[i]
                      |    return ", ".join(r)
                      |  def map_args (self, args, kws):
                      |    # Checks if an overload is acceptable.
                      |    # Returns a match "score".  Higher is a closer match.  False if
                      |    # it flat out doesn't match.
                      |    # Also returns the "mapped" args (e.g., actual args to use to
                      |    # call this overload).
                      |    try:
                      |      if len(args) > self.num_args: return False,False
                      |      if len(kws) > self.num_args: return False,False
                      |      if self.max_args_count == 0: return _M_PERFECT,[]
                      |      mapping = [_NOTHING] * self.max_args_count
                      |      for kwname,kwvalue in kws.items():
                      |        kwindex = self.keyword_index(kwname)
                      |        # The above will throw an exception if we don't have the keyword;
                      |        # we treat exceptions as meaning a non-match, so that's fine.
                      |        mapping[kwindex] = kwvalue
                      |      for i,arg in enumerate(args):
                      |        if mapping[i] is not _NOTHING:
                      |          return False,False # Can't specify same param with keyword and positional
                      |        mapping[i] = arg
                      |      score = 0
                      |      for i,value in enumerate(mapping):
                      |        if value is _NOTHING:
                      |          if self.defaults[i] is _NO_DEFAULT:
                      |            return False,False # Didn't have an argument or a default
                      |          mapping[i] = self.defaults[i]
                      |        else:
                      |          arg_score = self.is_compatible(value, self.types[i])
                      |          if arg_score is False: return False,False
                      |          score += arg_score
                      |      score /= float(self.max_args_count)
                      |      return score,mapping
                      |    except:
                      |      #import traceback
                      |      #traceback.print_exc()
                      |      return False,False
                      |
                      |def _call_overload (target, num, args, kw):
                      |  candidates = []
                      |  for o in _overloads[num]:
                      |    score,mapped = o.map_args(args, kw)
                      |    if mapped is not False:
                      |      candidates.append((score,-o.max_args_count,mapped,o))
                      |  if not candidates:
                      |    if args and kw: argstr = "%s %s" % (args, kw)
                      |    elif args: argstr = str(args)
                      |    elif kw: argstr = str(args)
                      |    else: argstr = "<Empty>"
                      |    raise OverloadException("No overload for compatible with given arguments: " + argstr)
                      |  candidates.sort()
                      |  _,_,mapped,o = candidates[-1]
                      |  if o.static:
                      |    return o.func(*mapped)
                      |  else:
                      |    if target is None:
                      |      raise RuntimeError("Instance method called with no 'self'")
                      |    return o.func(target, *mapped)
                      |
                      |cdef object _OverloadedMethod
                      |class _OverloadMethod (object):
                      |  """
                      |  Decorator for overloaded methods which may be either static or dynamic
                      |  """
                      |  def __init__ (self, f):
                      |    self.f = f
                      |  def __get__ (self, obj, cls):
                      |    def function (*args, **kw):
                      |      return self.f(obj, *args, **kw)
                      |    return function
                      |
                      |_overloads = []
                      |
                      |cdef object _SingletonDescriptor
                      |class _SingletonDescriptor (object):
                      |  def __init__ (self, f):
                      |    self.f = f
                      |  def __get__ (self, obj, cls):
                      |    return self.f()
                      |
                      |# We do some magic here so that we can expose Rogue global properties
                      |# in a way that seems natural.
                      |cdef object _StaticProperty
                      |class _StaticProperty (object):
                      |  def __init__ (self, getter, setter=None):
                      |    self._getter = getter
                      |    self._setter = setter
                      |  def setter (self, setter):
                      |    self._setter = setter
                      |    return self
                      |  def __get__ (self, obj, cls=None):
                      |    return self._getter()
                      |  def __set__ (self, obj, value):
                      |    if self._setter is None:
                      |      raise AttributeError("Property is read-only")
                      |    self._setter(value)
                      |cdef object _PyRogueMetaclass
                      |class _PyRogueMetaclass (type):
                      |  def __setattr__ (self, key, value):
                      |    obj = self.__dict__.get(key)
                      |    if obj and isinstance(obj, _StaticProperty):
                      |      return obj.__set__(self, value)
                      |    return super(_PyRogueMetaclass, self).__setattr__(key, value)

      # These function pointers were originally meant to keep the C++ generated
      # for the Rogue code from needing to import Python.h, but we are
      # currently doing that anyway, so we could get rid of these...
      # (Actually, maybe we're not importing Python.h anymore and so we *do*
      # need these...?)
      writer.println  'cdef extern from "$.h":' (filepath)
      writer.println @|  # Function pointers we fill in.
                      |  cdef void (*PyRogue_XDECREF)(void*)
                      |  cdef void (*PyRogue_XINCREF)(void*)
                      |cdef void PyRogue_XDECREF_impl (void * o):
                      |  Py_XDECREF(<PyObject *>o)
                      |cdef void PyRogue_XINCREF_impl (void * o):
                      |  Py_XINCREF(<PyObject *>o)
                      |PyRogue_XDECREF = PyRogue_XDECREF_impl
                      |PyRogue_XINCREF = PyRogue_XINCREF_impl

    method cy_write_cppclasses (writer:CPPWriter, filepath:String, all_types:Type[], wrapped_types:Table<<Type, CyClass>>)
      # For all of the reference types we work with, we write a Cython extern
      # cppclass.  If it's a type we are wrapping, we also need to declare its
      # instance properties.

      writer.println 'cdef extern from "$.h":' (filepath)
      forEach (type in all_types)
        writer.println '  cdef RogueType * RogueType$' (type.cpp_name)
        local base = "": String
        # We currently don't bother to generate the C++ classes as a hierarchy,
        # though we could do so for direct base classes (not for aspects since
        # Cython extension types only do single inheritance).  This may let
        # us omit properties/methods from parent types.  If we do ever want
        # to do this, we need to do the topological sort of types first.
        #if (type.base_class)
        #  base = " ($)" (type.base_class.cpp_class_name)
        #  if (type.base_class.omit_output) base = ""
        #  base = ""
        #endIf
        writer.println '  cdef cppclass $$:' (type.cpp_class_name, base) # Was formerly of RogueObject
        writer.println "    pass # Aspect:$" (type.is_aspect)
        if (wrapped_types.contains(type))
          local cls = wrapped_types[type]
          forEach (p in cls.properties.values)
            if (p.is_static) nextIteration
            writer.println "    $ $" (p.ctype, p.prop.cpp_name)
          endForEach
        endIf
        writer.println
      endForEach

    method cy_write_rogue_method_prototypes (writer:CPPWriter, filepath:String, wrapped_types:Table<<Type, CyClass>>)
      # Prototypes for methods of wrapped types
      #
      # Methods in Rogue end up as flat functions which take an explicit "this"
      # parameter.  We write out prototypes of them in Cython here.

      writer.println "# --- Prototypes of Rogue Methods ---"
      writer.println 'cdef extern from "$":' (filepath+".h")
      writer.println '  pass'
      writer.indent+=2

      local signatures = Set<<String>>()
      forEach (cyclass in wrapped_types.values)
        forEach (fi in cyclass.funcs.values)
          forEach (f in fi)
            local m = f.real_method
            local sig = m.cpp_typedef
            if (sig is null) nextIteration
            if (signatures.contains(sig)) nextIteration
            #println "SIG for $.$: $" (cyclass.pytype, m.name, sig)
            signatures.add(sig)
            writer.print "cdef "
            writer.print( m.return_type ).print( " Rogue_call_" ).print( m.cpp_typedef )
            writer.print( "( int i, " ).print( m.type_context ).print( " THIS" )
            forEach (i of m.parameters)
              local p = m.parameters[i]
              writer.print( ", " ).print(p.type).print( " p" ).print( i )
            endForEach
            writer.print( " )" )
            writer.println " except +PyRogue_handle_rogue_exception"
          endForEach
        endForEach
      endForEach

      signatures.clear
      forEach (cyclass in wrapped_types.values)
        writer.println('# cyclass $ $' (cyclass.pytype, cyclass.type))
        forEach (fi in cyclass.funcs.values)
          forEach (f in fi)
            local sig = '$ $ ($) except +PyRogue_handle_rogue_exception' (f.cproto_return, f.cname, ", ".join(f.cproto_params))
            if (signatures.contains(sig)) nextIteration
            writer.println sig
            signatures.add(sig)
          endForEach
        endForEach
      endForEach
      writer.indent-=2

    method cy_write_rogue_global_properties (writer:CPPWriter, filepath:String, wrapped_types:Table<<Type, CyClass>>)
      # Externs of Rogue global properties
      #
      # Global properties of Rogue objects are stored in plain old C++ global
      # variables.  We declare externs for them all here.

      writer.println "# --- Backing variables for global properties ---"
      writer.println 'cdef extern from "$":' (filepath+".h")
      forEach (cyclass in wrapped_types.values)
        forEach (p in cyclass.properties)
          if (not p.is_static) nextIteration
          writer.println "  cdef extern $ $" (p.ctype, p.cname)
        endForEach
      endForEach

    method cy_write_property (writer:CPPWriter, p:CyProperty)
      if (p.is_static)
        writer.println "@_StaticProperty"
        writer.println "def $ ():" (p.pyname)
        writer.println "  return $" (p.read_c_code)
        writer.println "@$.setter" (p.pyname)
        writer.println "def $ (value):" (p.pyname)
        writer.println "  global $" (p.cname)
        writer.println "  $" (p.write_c_code)
      else
        writer.println "@property"
        writer.println "def $ (self):" (p.pyname)
        writer.println "  return $" (p.read_c_code)
        writer.println "@$.setter" (p.pyname)
        writer.println "def $ (self, value):" (p.pyname)
        writer.println "  $" (p.write_c_code)
      endIf

    method cy_find_constructor_context (cyclasses:Table<<Type, CyClass>>, t:CyClass) -> Type
      # Find the "constructor context" type for a given type.  That is, find the
      # most-subclassed subclass of t (inclusive -- it might be t itself) which
      # has any constructors.
      if t.funcs.contains("_init_") return t.type
      require t.type.base_class
      if not cyclasses.contains(t.type.base_class) return null
      return cy_find_constructor_context(cyclasses, cyclasses[t.type.base_class])

    method cy_write_overload_table (writer:CPPWriter, overloads:CyMethod[][], context_constraints:Type[])
      # Writes overload tables for each set of methods in overloads.
      # overloads is a list of lists of methods (all methods in a list being overloads of each other)
      # For each overload, there is also a context_constraint entry.  This is usually null.  If it's
      # not null, only methods with that type_context will be written.  This is used to limit the
      # writing of overloaded constructors to the "topmost" ones.
      local count = -1
      while true
        count++
        if (count >= overloads.count) escapeWhile
        local funcs = overloads[count]
        local context_constraint = context_constraints[count]
        writer.println "# Overloads for $ (#$)" (funcs[0].full_name, count)
        writer.println "_overloads.append( ["
        writer.indent += 2
        local fnum = -1
        local first = true
        forEach (func in funcs)
          fnum++
          if (context_constraint is not null) and (func.real_method.type_context is not context_constraint)
            nextIteration
          endIf
          if not first
            writer.println(",")
          else
            first = false
          endIf
          writer.print " _Overload( "
          local names = String[]
          forEach n in func.py_params
            names.add ''"'' + n + ''"''
          endForEach
          local fname = func.pyname
          if (not fname.begins_with("_")) fname = "_" + fname
          fname = "$.$_$_" (func.pyclass, fname, fnum)
          writer.print "[$], [$], [$], $, $ )" (",".join(func.py_types), ",".join(names), ",".join(func.defaults), fname, which{func.is_static_method:"True" || "False"})
        endForEach
        writer.indent -= 2
        writer.println
        writer.println "] )"
      endWhile

    method cy_write_method (writer:CPPWriter, cyclass:CyClass, fi:CyMethod[], overloading:Logical)
      # Writes a single method or method name.
      #
      # When overloading=true, this writes a method for each entry using a
      # name like "_methodname_overloadnumber_", with the presumption that
      # someone else will write a single "interface" method which dispatches
      # to these.
      # Rather than just decide ourself whether we want to overload or not
      # based on the list length being 1 or >1, we take that as a parameter
      # so that the caller can decide (because there are cases where we may
      # want to force the overloading mechanism... like for constructors).
      local fnum = -1
      forEach (f in fi) # For each method with same name
        fnum++
        local fname = f.pyname
        if overloading
          fname = "$_$_" (fname, fnum)
          if (not fname.begins_with("_")) fname = "_" + fname # Don't double-underscore a method name
        endIf

        local params = String[]

        if (f.is_static_method)
          writer.println "@staticmethod"
        else
          params.add( "self" )
        endIf

        local cname = f.cname
        local args = f.call_args
        if f.real_method.is_overridden
          args = args.cloned()
          args.insert(f.real_method.index)
          cname = "Rogue_call_" + f.real_method.cpp_typedef
        endIf

        local i = 0
        forEach (p in f.py_params)
          local ptext = p
          if f.defaults[i] != "_NO_DEFAULT"
            ptext += "=" + f.defaults[i]
          endIf
          params.add(ptext)
          i++
        endForEach
        writer.println "def $ ($):" (fname, ", ".join(params))
        writer.indent+=2
        forEach (s in f.prologue)
          writer.println s
        endForEach
        local call_code = "$($)" (cname, ", ".join(args))
        if f.return_converter is null
          writer.println call_code
        else
          writer.println "return " + f.return_converter.replacing("%", call_code)
        endIf
        writer.indent-=2
        writer.println
      endForEach

    method cy_write_delegate_thunks (writer:CPPWriter)
      writer.println "# Delegate thunks"
      forEach (ccls in cy_delegates.values)
        local m = ccls.funcs['call'][0]
        local j = 0
        local params = String[]
        forEach (p in m.cproto_params)
          params.add( p + " param" + j )
          ++j
        endForEach
        local func = find_function_root(ccls.type)
        require func
        writer.println "cdef $ PyRogue_delegate_$_thunk ($):" (m.cproto_return, func.cpp_name, ",".join(params))
        j = 0
        writer.println @|  cdef PyRogueDelegateContext* context
                        |  context = <PyRogueDelegateContext*>param0
                        |  f = <object><PyObject *>context.f
                        |  assert f, 'Delegate has no callable'
                        |  try:
                        |    retval = f(
        while (j < m.real_method.parameters.count)
          writer.println ("    " + ccls.get_c_to_py(m.real_method.parameters[j].type).replacing("%", "param"+(j+1)) + "," )
          ++j
        endWhile
        writer.println @|    )
        if (m.real_method.return_type)
          local code = ccls.get_py_to_c(m.real_method.return_type).replacing("%", "retval")
          writer.println "    return " + code
        endIf
        writer.println @|  except:
                        |    import traceback
                        |    e = sys.exc_info()
                        |    tb = traceback.format_exc()
                        |    context.exception = (<PyRogueBase>PyRogueError( str(e[0].__name__), str(e[1]), tb )).thisptr

        writer.println "PyRogue_delegate_$ = PyRogue_delegate_$_thunk" (func.cpp_name, func.cpp_name)
      endForEach

    method cy_sort_cyclasses ( cyclasses:Table<<Type, CyClass>> )->CyClass[]
      # This is a really inefficient topological sort of the types, such
      # that a type should appear in the resulting list after all of its
      # supertypes.  It gives up if it can't make forward progress, which
      # could happen either because the types don't form a hierarchy
      # (which hopefully can't happen) or because some types are not
      # available (e.g., some type that the Cython backend doesn't wrap
      # appears as a superclass -- this currently happens with lists).
      local sorted_types = CyClass[]
      local done = Set<<Type>>()
      local prev = -1
      while (sorted_types.count < cyclasses.count)
        if (cyclasses.count - sorted_types.count == prev)
          # Hope for the best
          escapeWhile
        endIf
        prev = cyclasses.count - sorted_types.count
        local ss = Set<<Type>>()
        forEach (t in cyclasses.values)
          ss.add(t.type)
        endForEach
        ss = ss.difference(done)
        #forEach (t in ss)
        #  println t
        #endForEach
        #trace sorted_types.count, cyclasses.count
        forEach (t in cyclasses.values)
          if (done.contains(t.type)) nextIteration
          local ok = false
          if (t.type.base_types.count == 0)
            ok = true
          else
            ok = true
            forEach (bt in t.type.base_types)
              if (not done.contains(bt))
                ok = false
                escapeForEach
              endIf
            endForEach
          endIf
          if (ok)
            done.add(t.type)
            sorted_types.add(t)
          endIf
        endForEach
      endWhile

      return sorted_types

    method cy_write_classes (writer:CPPWriter, cyclasses:Table<<Type, CyClass>>)
      # We save up all overloads until the end because when they actually occur,
      # they may refer to types which haven't been defined yet.
      local overloads = CyMethod[][]
      local overload_constraints = Type[]

      # Similarly, we need to set the _pyrogue_pydelegate_type of a signature
      # type to its concrete PyDelegate type, which always comes *later* in the
      # type hierarchy.  So we save them all up for the end.
      local pydelegates = String[]

      # Now write out each wrapped class/routine in an order such that a class
      # comes before all of its child classes.
      forEach (cyclass in cy_sort_cyclasses(cyclasses))
        writer.println "# --- Wrapper for Class $ ---" (cyclass.pytype)
        local bases = String[]
        forEach (b in cyclass.type.base_types)
          if (cyclasses.contains(b))
            bases.add(cyclasses[b].pytype)
          endIf
        endForEach
        if (bases.count == 0) bases.add("PyRogueBase")
        if (cyclass.type.is_function) bases.add("_PyDelegate")
        local base = ", ".join(bases)

        writer.println "class $ ($):" (cyclass.pytype, base)
        writer.println @|  __metaclass__ = _PyRogueMetaclass
                        |  def __init__ (self, *args, **kwargs):
                        |    cdef PyRogueBase base
                        |    cdef PyRogueBase other
                        |    base = self
                        |    if '__pyrogue_new_instance' in kwargs:
                        |      base.thisptr = <RogueObject*><intptr_t>kwargs['__pyrogue_new_instance']
                        |      RogueObject_retain(<RogueObject*>base.thisptr)
                        |    else:
        writer.println  "      base.thisptr = RogueType_create_object(RogueType$, 0)" (cyclass.type.cpp_name)
        writer.println @|      if not base.thisptr: raise RuntimeError("Could not create object")
                        |      RogueObject_retain(<RogueObject*>base.thisptr)
                        |      try:
                        |        other = self._init_(*args, **kwargs)
                        |        if other.thisptr != base.thisptr:
                        |          RogueObject_release(<RogueObject*>base.thisptr)
                        |          base.thisptr = other.thisptr
                        |          RogueObject_retain(<RogueObject*>base.thisptr)
                        |      except (AttributeError, OverloadException) as e:
                        |        # Old behavior -- always allow default constructor: if args or kwargs:
                        |        if True: # New behavior; correct constructor required
                        |          RogueObject_release(<RogueObject*>base.thisptr)
                        |          raise e
        if cyclass.type.is_function
          local pydelegate = cy_delegate_to_pydelegate[cyclass.type]
          if (pydelegate is not null)
            pydelegates.add("$._pyrogue_pydelegate_type = $" (cyclass.pytype, cy_delegates[pydelegate].pytype))
          else
            #throw Error("[INTERNAL] No Python delegate for signature type $" (cyclass.type.name))
            # This case happens when there's no Python delegate because, e.g., there are compound
            # paramters.
            #TODO: Support Python/Rogue marshalling of compounds!
          endIf
        endIf
        writer.indent+=2
        if cyclass.type.is_singleton
          writer.println "singleton = _SingletonDescriptor(lambda:$(__pyrogue_new_instance=<intptr_t>RogueType_singleton(RogueType$)))" (cyclass.pytype, cyclass.type.cpp_name)
        endIf

        # Properties
        if (not cyclass.type.is_aspect) # Aspects don't really have properties
          writer.println "# --- Property wrappers ---"
          forEach (p in cyclass.properties)
            cy_write_property(writer, p)
          endForEach
        endIf
        writer.println

        # Iterate over each method name; write the method (and its overloads)
        forEach (fi in cyclass.funcs.values)
          local constructor = fi[0].is_initializer
          local overloading = fi.count > 1 or constructor
          # We always overload constructors.  Why?  I don't remember anymore!

          # The methods in this class may be inherited, in which case we don't
          # need to write them here.  However, the overload mechanism doesn't
          # work right (yet?) if some of the methods are implemented in this
          # class and some in a parent class.  So we implement the following:
          # If all methods with the same name are all inherited, we skip.
          # If any methods with the same name are implemented *here*, we write.
          #TODO: Could be more efficient if we didn't have to do this?
          local must_write = false
          forEach f in fi
            local m = f.real_method
            if cyclass.type is m.type_context
              # It's implemented here.  We need to write.
              must_write = true
              escapeForEach
            endIf
          endForEach

          if must_write
            cy_write_method(writer, cyclass, fi, overloading)
            if overloading
              # Create the "interface" method which calls the overloads
              writer.println "@_OverloadMethod"
              writer.println "def $ (self, *args, **kwargs):" (fi[0].pyname)
              writer.println "  return _call_overload(self, $, args, kwargs)" (overloads.count)
              writer.println
              overloads.add(fi)
              if constructor
                local constraint = cy_find_constructor_context(cyclasses, cyclass)
                require constraint
                overload_constraints.add(constraint)
              else
                overload_constraints.add(null)
              endIf
            endIf
          else
            writer.println "# Skipped $" (fi[0].real_method.name)
          endIf
        endForEach

        writer.println "@staticmethod"
        writer.println "def _pyrogue_type ():"
        writer.println "  return <intptr_t>RogueType$" (cyclass.type.cpp_name)

        if cyclass.type.is_function
          if cyclass.funcs.contains("call")
            writer.println "__call__ = call"
          endIf
        endIf

        writer.indent-=2

        writer.println "_rogue_type_index_to_pyclass[$] = $" (cyclass.type.index, cyclass.pytype)
      endForEach

      # Now we write the table full of overload information used by _call_overload()
      cy_write_overload_table(writer, overloads, overload_constraints)

      # Write out the signature-to-concrete delegate info
      forEach d in pydelegates
        writer.println d
      endForEach

    method cy_write ( filepath:String )

      # All the types that Python needs to know about (excluding primitives
      # which are hardwired).
      local all_type_list = Type[]

      forEach (t in type_list)
        if (not t.is_reference) nextIteration
        if (t.omit_output and not t.is_native) nextIteration
        all_type_list.add(t)
      endForEach

      local cyclasses = Table<<Type, CyClass>>() # Type -> CyClass
      forEach (type in all_type_list)
        local cyclass = CyClass(type)
        if (cyclass.pytype != "") cyclasses[cyclass.type] = cyclass
      endForEach

      if (cyclasses.count == 0) return

      if (not RogueC.quiet) println "Writing $.pyx..." (filepath)
      local writer = CPPWriter( filepath + ".pyx" )

      # From this point on filepath is used to refer to the RogueC-generated
      # .cpp and .h files which will have the _module extension.
      filepath += "_module"

      cy_write_cy_header(writer, filepath)

      # Write the extern cppclasses of types we need to know about.
      cy_write_cppclasses(writer, filepath, all_type_list, cyclasses)

      # Write the externs of the thunk function pointers (we populate them
      # later).
      writer.println 'cdef extern from "$.h":' (filepath)
      writer.println '  pass'
      cy_write_delegate_thunk_pointers(writer, &prefix="  cdef ", &suffix="")

      # Rogue "PyDelegates" call these thunks via function pointer, and then
      # the actual thunks (generated in Cython) call Python.  Write them out
      # here.
      cy_write_delegate_thunks(writer)

      # Write extern prototypes all the C++ functions representing Rogue methods.
      cy_write_rogue_method_prototypes(writer, filepath, cyclasses)

      # Write externs for all global variables representing Rogue global properties.
      cy_write_rogue_global_properties(writer, filepath, cyclasses)

      # Write out the Python wrapper classes and overload table
      cy_write_classes(writer, cyclasses)

      # Expose methods on Global
      writer.println "\n# --- Exposing Global methods ---"
      local rglobal = Program.type_lookup["Global"]
      local cyglobal = cyclasses[rglobal]
      if rglobal and cyglobal
        forEach (fi in cyglobal.funcs.values)
          local constructor = fi[0].is_initializer
          if (constructor) nextIteration
          writer.println "def $ (*args, **kwargs):" (fi[0].pyname)
          writer.println "  return Global.$(*args, **kwargs)" (fi[0].pyname)
        endForEach
      endIf

      writer.close

    method write_cpp ( filepath:String )
      <append>

      if (RogueC.compile_targets["Cython"])
        cy_write(filepath)
      endIf
endAugment
