module RogueC
uses Utility/WorkList

# Generated by Froley. Will not be overwritten; customize as desired.
$include "ParserCore.rogue"

class Parser : ParserCore, Poolable
  PROPERTIES
    processed_tokens      : Token[]
    marked_token          : Token
    token_buffer          = Token[]
    inserted_tokens       = Token[]
    id_start_stack        = Int32[]
    string_start_stack    = Int32[]
    collecting_templates  = false
    _attribute_no_include = false
    _attribute_essential  = false
    is_api                = false

    augment_t             : Token
    augment_context_name  : String

    generic_fn_args_depth : Int32
    generic_fn_args_used  : Int32

    local_definitions     : [String:Token[]]
    local_macros          : [String:Macro[]]


  METHODS
    method init

    method init( file:File )
      prior.init( file )

    method init( filepath:String, content:String )
      prior.init( filepath, content )

    method init( scanner:Scanner )
      prior.init( scanner )

    method init( _tokens:Token[] )
      prior.init( _tokens )

    method reset
      on_return_to_pool

    method on_return_to_pool
      _list_starts.clear
      _list_tokens.clear
      _saved_positions.clear
      start_ip = 0
      buffer.clear
      output.clear

      disable_output         = 0
      is_batch_augment       = false
      saved_setting          = 0
      procedure_returns_this = false
      next_is_to_type        = false
      is_def                 = false
      is_method_template     = false

      processed_tokens       = null
      token_buffer           = Token[]
      id_start_stack.clear
      string_start_stack.clear
      collecting_templates  = false
      _attribute_no_include = false
      _attribute_essential  = false

      generic_fn_args_depth = 0
      generic_fn_args_used  = 0

      if (local_macros) local_macros.clear

    method create_rogue_version_string
      processed_tokens.add( _cur_t.cloned(TokenType.STRING,VERSION.after_first('v')) )

    method create_source_filepath
      processed_tokens.add( _cur_t.cloned(TokenType.STRING,_cur_t.filepath) )

    method create_source_line
      processed_tokens.add( _cur_t.cloned(TokenType.INTEGER,_cur_t.line) )

    method preprocess
      processed_tokens = Token[]( _tokens.count * 1.2 )
      parse( ip_preprocess )
      _tokens.clear
      _tokens.add( processed_tokens )

    method set_augment_context_name
      if (not collecting_templates) return

      local i1 = _saved_positions.last.position
      local i2 = _position - 1
      augment_t = _tokens[i1]

      local builder = String()
      local depth = 0
      forEach (t at i in _tokens.from(i1,i2))
        which (t.type)
          case TokenType.EOL
            if (depth > 0) throw t.error( "Expected '>>', found end of line." )
            escapeForEach
          case TokenType.SYMBOL_COLON
            if (depth > 0)
              escapeForEach
            endIf
          case TokenType.SYMBOL_LTLT
            ++depth
          case TokenType.SYMBOL_GTGT
            --depth
            if (depth < 0)  throw t.error( "Unexpected '>>'." )
            if (depth == 0)
              builder.print ">>"
              escapeForEach
            endIf
        endWhich
        builder.print t->String
      endForEach
      if (depth > 0) throw _tokens[i1].error( "Unterminated '<<'." )
      @augment_context_name = builder

    method batch_augment_create_method
      if (not collecting_templates) return

      local i1 = _saved_positions.last.position
      local i2 = _position - 1
      local tokens = _tokens.from( i1, i2 ).to_list

      local (mod,name) = Program.current_module.split_module_and_type( _tokens[i1], augment_context_name )
      if (not mod) mod = Program.current_module
      local base_name = name.before_first('<')

      # Create a special aspect that will be incorporated into the designated class
      local aspect_name = "Augment_$_$_$"(mod.next_augment_id,mod.name,base_name)
      ++mod.next_augment_id

      if (not mod.augments.contains(name)) mod.augments[name] = String[]
      mod.augments[name].add( aspect_name )

      # Wrap tokens:
      #     METHODS
      #       method <tokens>
      #   endClass
      tokens.insert( tokens.last.cloned(TokenType.KEYWORD_METHOD,null) )
      tokens.insert( tokens.last.cloned(TokenType.EOL,null) )
      tokens.insert( tokens.last.cloned(TokenType.KEYWORD_METHODS,null) )
      tokens.insert( tokens.last.cloned(TokenType.EOL,null) )
      tokens.add( tokens.last.cloned(TokenType.EOL,null) )
      tokens.add( tokens.last.cloned(TokenType.KEYWORD_END_CLASS,null) )
      tokens.add( tokens.last.cloned(TokenType.EOL,null) )

      local attributes = Attribute.ASPECT | Attribute.AUGMENT
      if (is_api) attributes |= (Attribute.ESSENTIAL | Attribute.API)
      mod.templates[aspect_name] = Template( augment_t, mod, aspect_name, Token[], tokens, attributes )

    method begin_join_ids
      id_start_stack.add( processed_tokens.count )

    method end_join_ids
      local i1 = id_start_stack.remove_last
      if (i1 >= processed_tokens.count) return

      local t = processed_tokens[i1]
      if (t.type != TokenType.IDENTIFIER) t .= cloned( TokenType.IDENTIFIER, t->String )
      forEach (i in i1+1..<processed_tokens.count)
        t.content += processed_tokens[i]->String
      endForEach
      processed_tokens.discard_from( i1 )
      processed_tokens.add( t )

    method begin_join_lowercase
      string_start_stack.add( processed_tokens.count )

    method end_join_lowercase
      local i1 = string_start_stack.remove_last
      if (i1 >= processed_tokens.count) return

      local t = processed_tokens[i1]
      if (t.type != TokenType.STRING) t .= cloned( TokenType.STRING, t->String )
      forEach (i in i1+1..<processed_tokens.count)
        t.content += processed_tokens[i]->String
      endForEach
      t.content = t.content.to_lowercase

      processed_tokens.discard_from( i1 )
      processed_tokens.add( t )

    method begin_join_strings
      string_start_stack.add( processed_tokens.count )

    method end_join_strings
      local i1 = string_start_stack.remove_last
      if (i1 >= processed_tokens.count) return

      local t = processed_tokens[i1]
      if (t.type != TokenType.STRING) t .= cloned( TokenType.STRING, t->String )
      forEach (i in i1+1..<processed_tokens.count)
        t.content += processed_tokens[i]->String
      endForEach
      processed_tokens.discard_from( i1 )
      processed_tokens.add( t )

    method begin_join_uppercase
      string_start_stack.add( processed_tokens.count )

    method end_join_uppercase
      local i1 = string_start_stack.remove_last
      if (i1 >= processed_tokens.count) return

      local t = processed_tokens[i1]
      if (t.type != TokenType.STRING) t .= cloned( TokenType.STRING, t->String )
      forEach (i in i1+1..<processed_tokens.count)
        t.content += processed_tokens[i]->String
      endForEach
      t.content = t.content.to_uppercase

      processed_tokens.discard_from( i1 )
      processed_tokens.add( t )

    method define_macro
      assert _cmd_stack.count >= 3
      local tokens = _cmd_stack.remove_last->(as TokenList).tokens
      local placeholders = _cmd_stack.remove_last->(as Placeholders)
      local id_node = _cmd_stack.remove_last

      local macros = Program.macros[id_node->String]
      if (not macros)
        macros = Macro[]
        Program.macros[id_node->String] = macros
      endIf

      forEach (m in macros)
        if (m.placeholders.count == placeholders.count)
          throw m.t.error( "A definition of macro $($) already exists."(id_node->String,placeholders.count) )
        endIf
      endForEach

      if (local_macros)
        local local_group = local_macros[id_node->String]
        if (local_group)
          forEach (m in local_group)
            if (m.placeholders.count == placeholders.count)
              throw m.t.error( "A local definition of macro $($) already exists."(id_node->String,placeholders.count) )
            endIf
          endForEach
        endIf
      endIf

      macros.add( Macro(id_node.t,id_node->String,placeholders,tokens) )

    method define_local_macro
      assert _cmd_stack.count >= 3
      local tokens = _cmd_stack.remove_last->(as TokenList).tokens
      local placeholders = _cmd_stack.remove_last->(as Placeholders)
      local id_node = _cmd_stack.remove_last

      ensure<<local_macros>>
      local macros = local_macros[id_node->String]
      if (not macros)
        macros = Macro[]
        local_macros[id_node->String] = macros
      endIf

      local global_group = Program.macros[ id_node->String ]
      if (global_group)
        forEach (m in global_group)
          if (m.placeholders.count == placeholders.count)
            throw m.t.error( "A global definition of local macro $($) already exists."(id_node->String,placeholders.count) )
          endIf
        endForEach
      endIf

      forEach (m in macros)
        if (m.placeholders.count == placeholders.count)
          throw m.t.error( "A definition of local macro $($) already exists."(id_node->String,placeholders.count) )
        endIf
      endForEach

      macros.add( Macro(id_node.t,id_node->String,placeholders,tokens) )

    method clone
      if (disable_output or _cmd_stack.is_empty) return
      local cmd = _cmd_stack.last
      if (cmd) _cmd_stack.add( cmd.cloned )
      else     _cmd_stack.add( cmd )

    method check_target
      local t = _read
      if (t.type != TokenType.STRING) throw t.error( "Literal string expected." )
      if (Program.targets.contains(t.content))
        processed_tokens.add( t.cloned(TokenType.KEYWORD_TRUE,null) )
      else
        processed_tokens.add( t.cloned(TokenType.KEYWORD_FALSE,null) )
      endIf

    method class_attribute_essential
      _attribute_essential = true

    method create_definition
      local def_name = buffer.cloned
      Program.definitions[ def_name ] = token_buffer
      use history = WorkList<<String>>
        detect_definition_cycle( history, def_name, token_buffer )
      endUse
      token_buffer = Token[]

    method create_local_definition
      ensure<<local_definitions>>
      local def_name = buffer.cloned
      local_definitions[ def_name ] = token_buffer
      use history = WorkList<<String>>
        detect_definition_cycle( history, def_name, token_buffer )
      endUse
      token_buffer = Token[]


    method collect_next_token
      token_buffer.add( _read )

    method collect_token_string
      buffer.print _cur_t->String

    method detect_definition_cycle( history:String[], name:String, tokens:Token[] )
      if (history.contains(name))
        throw marked_token.error( "Definition of '$' results in an infinite cycle."(name) )
      endIf

      history.add( name )
      forEach (t in tokens)
        if (t.type == TokenType.IDENTIFIER)
          local entry = Program.definitions.find( t->String )
          if (entry)
            detect_definition_cycle( history, entry.key, entry.value )
          endIf

          if (local_definitions)
            entry = local_definitions.find( t->String )
            if (entry)
              detect_definition_cycle( history, entry.key, entry.value )
            endIf
          endIf
        endIf
      endForEach
      history.remove_last

    method discard_last
      if (_cmd_stack.count) _cmd_stack.remove_last

    method insert_definition
      if (local_definitions)
        local def = local_definitions[ _cur_t->String ]
        if (def)
          if (def.count > 0)
            _tokens.insert( def, _position )
            _limit += def.count
            if (_position < _limit) _next_t = _tokens[_position]
          endIf
          return
        endIf
      endIf

      local def = Program.definitions[ _cur_t->String ]
      if (def)
        if (def.count > 0)
          _tokens.insert( def, _position )
          _limit += def.count
          if (_position < _limit) _next_t = _tokens[_position]
        endIf
        return
      endIf

      if (_next_t.type == TokenType.SYMBOL_LTLT)
        if (expand_macro(Program.macros[_cur_t->String])) return
        if (local_macros and expand_macro(local_macros[_cur_t->String])) return
      endIf

      processed_tokens.add( _cur_t )

    method expand_macro( macros:Macro[] )->Logical
      if (not macros) return false

      _save_position
      _execute( ip_macro_args )
      local args = _cmd_stack.remove_last
      forEach (m in macros)
        if (m.placeholders.count == args.count)
          _discard_position

          # Expand macro here
          local replacements = [String:Token[]]
          forEach (placeholder at i in m.placeholders)
            replacements[placeholder->String] = args[i]->(as TokenList).tokens
          endForEach

          use expanded_tokens = WorkList<<Token>>
            forEach (t in m.tokens)
              if (t.type == TokenType.PLACEHOLDER)
                local replacement = replacements[ t.content ]
                if (replacement)
                  expanded_tokens.add( forEach in replacement )
                else
                  expanded_tokens.add( t )
                endIf
              else
                expanded_tokens.add( t )
              endIf
            endForEach

            # Insert expanded tokens
            _tokens.insert( expanded_tokens, _position )
            _limit += expanded_tokens.count
            if (_position < _limit) _next_t = _tokens[_position]
          endUse
          return true
        endIf
      endForEach

      # No macro matches arg count
      _restore_position
      return false

    method filename_to_file_bytes
      if (disable_output or _cmd_stack.is_empty) return
      local string_node = _cmd_stack.remove_last
      local t = string_node.t
      local file = File(string_node->String)
      if (not file.filepath.begins_with('/')) file = File(File(t.filepath).folder / file.filepath)
      if (not file.exists) throw t.error( "No such file: $"(file) )
      local bytes = Byte[](file)
      _cmd_stack.add( TypeAccess( t, Type(t,Program.type_Byte), Args(t,LiteralString(t,bytes->String(&hex))) ) )

    method filename_to_file_string
      if (disable_output or _cmd_stack.is_empty) return
      local string_node = _cmd_stack.remove_last
      local t = string_node.t
      local file = File(string_node->String)
      if (not file.filepath.begins_with('/')) file = File(File(t.filepath).folder / file.filepath)
      if (not file.exists) throw t.error( "No such file: $"(file) )
      local string = String(file)
      _cmd_stack.add( LiteralString(t,string) )

    method load_filepath_as_string
      if (disable_output or _cmd_stack.is_empty) return
      local cmd_string = _cmd_stack.last->(as LiteralString)
      assert cmd_string
      local file = File(cmd_string->String)
      if (not file.exists)
        file = File( File(cmd_string.t.filepath).folder / file.filepath )
      endIf
      if (not file.exists) throw cmd_string.t.error("No such file: "+file.filepath)
      cmd_string.value = String(file)

    method mark_token
      marked_token = _cur_t
      _attribute_no_include = false

    method has_another->Logical
      return _position < _limit or inserted_tokens.count

    method include_filepath
      Program.include( marked_token, buffer.cloned, &is_optional=include_attribute_optional )

    method join
      if (not disable_output and _cmd_stack.count >= 2)
        local b = _cmd_stack.remove_last
        local a = _cmd_stack.remove_last
        _cmd_stack.add( Identifier(b.t, a->String + b->String) )
      endIf

    method join_template_args
      if (not disable_output and _cmd_stack.count >= 2)
        local b = _cmd_stack.remove_last
        local a = _cmd_stack.remove_last
        _cmd_stack.add( Identifier(b.t, b->(as TemplateArgs)->String(a->String)) )
      endIf

    method join_adjacent_literal_strings
      if (not disable_output and _cmd_stack.count >= 2)
        local a = _cmd_stack[_cmd_stack.count-2]->(as LiteralString)
        local b = _cmd_stack.remove_last->(as LiteralString)  # we already know b is a literal string
        a.value += b.value
      endIf

    method swap
      if (not disable_output and _cmd_stack.count >= 2)
        local b = _cmd_stack.remove_last
        local a = _cmd_stack.remove_last
        _cmd_stack.add( b )
        _cmd_stack.add( a )
      endIf

    method uses_attribute_no_include
      _attribute_no_include = true

    method uses_filepath
      # First pass $include's the given file
      local filepath = buffer.cloned
      if (filepath == "") throw marked_token.error( "Module path expected." )
      processed_tokens.add( marked_token.cloned(TokenType.STRING,filepath) )
      if (not _attribute_no_include)
        Program.include( marked_token, filepath, &is_optional )
      endIf

    method evaluate_meta_expression
      #if (disable_output or _cmd_stack.is_empty) return
      #local condition = _cmd_stack.remove_last
      #meta_condition = condition.evaluate

    method on_is_defined
      if (not disable_output)
        local t = _cur_t
        local name = t->String
        if (Program.definitions.contains(name) or (local_definitions and local_definitions.contains(name)))
          processed_tokens.add( t.cloned(TokenType.KEYWORD_TRUE,null) )
        else
          processed_tokens.add( t.cloned(TokenType.KEYWORD_FALSE,null) )
        endIf
      endIf

    method on_begin_arg
      ++generic_fn_args_depth

    method on_generic_fn_arg
      if (_cur_t.type == TokenType.SYMBOL_DOLLAR)
        generic_fn_args_used |= 1
      else
        local n = _cur_t.content.rightmost(-1)->Int32
        if (n == 0 or n > 5) throw _cur_t.error( "Only $1..$5 can be used as implicit function arguments." )
        generic_fn_args_used |= (1:<<:n)
      endIf
      if ((generic_fn_args_used & !1) and (generic_fn_args_used & 1))
        throw _cur_t.error( "Cannot mix single arg ('$') and multiple arg ('$N') implicit function argument syntax." )
      endIf

    method on_end_arg
      --generic_fn_args_depth
      if (generic_fn_args_used and generic_fn_args_depth == 0)
        if (not disable_output)
          local arg = _cmd_stack.remove_last
          local n = 0
          if (generic_fn_args_used > 1)
            local bits = generic_fn_args_used :>>>: 1
            while (bits)
              ++n
              if (not (bits & 1))
                throw arg.t.error( "Missing usage of implicit function argument $$. Multiple implicit function arguments must be contiguous and include $1." ('$',n,'$') )
              endIf
              bits = bits:>>>:1
            endWhile
          endIf
          generic_fn_args_used = 0
          arg = ImplicitFunctionGenerator.apply(arg,n)
          _cmd_stack.add( arg )
        else
          generic_fn_args_used = 0
        endIf
      endIf

    method on_parsed_augment
      if (not collecting_templates) return

      local i1 = _saved_positions.last.position
      local i2 = _position - 1
      local tokens = _tokens.from( i1, i2 ).to_list

      local name = augment_context_name
      local m = Program.current_module
      local base_name = name.before_first('<')
      if (base_name.contains(':'))
        local module_name = base_name.before_last( "::" )
        if (module_name == "") module_name = "Rogue"
        m = Program.get_module( augment_t, module_name )
        name .= after_last("::")
      elseIf (name.begins_with('['))
        # Tables go in the standard module namespace
        m = Program.default_module
      endIf

      # Create a special aspect that will be incorporated into the designated class
      local aspect_name = "Augment_$_$_$"(m.next_augment_id,m.name,base_name)
      ++m.next_augment_id

      if (not m.augments.contains(name)) m.augments[name] = String[]
      m.augments[name].add( aspect_name )

      # Change 'endAugment' to 'endClass'
      forEach (t at i in tokens step -1)
        if (t.type == TokenType.KEYWORD_END_AUGMENT)
          tokens[i] = t.cloned(TokenType.KEYWORD_END_CLASS,null)
          escapeForEach
        endIf
      endForEach

      local attributes = Attribute.ASPECT | Attribute.AUGMENT
      if (is_api) attributes |= (Attribute.ESSENTIAL | Attribute.API)
      m.templates[aspect_name] = Template( augment_t, m, aspect_name, Token[], tokens, attributes )

    method on_uses_module
      assert _cmd_stack.count >= 2
      local attributes = _cmd_stack.remove_last->(as Attributes)
      local path = _cmd_stack.remove_last
      if (collecting_templates)
        local m = Program.get_module( path.t, path->String.replacing("/","::") )
        Program.current_module.uses_module( m, &is_exported=attributes.is_exported )
      endIf

    method on_parsed_class
      create_type_template

    method on_parsed_enum
      local _template = create_type_template
      if (_template)
        _template.attributes.is_enum = true
        _template.attributes.is_compound = true
      endIf

    method create_type_template->Template
      local attributes : Int64
      if (_attribute_essential) attributes |= Attribute.ESSENTIAL
      _attribute_essential = false

      if (not collecting_templates) return null

      local i1 = _saved_positions.last.position
      local i2 = _position - 1
      local tokens = _tokens.from( i1, i2 ).to_list

      assert tokens.count
      local class_t = tokens.first

      local name = tokens[1]
      local placeholders = Token[]
      if (i2 >= i1 + 4 and tokens[2].type == TokenType.SYMBOL_LTLT)
        forEach (t at i in tokens from 3)
          if (t.type == TokenType.SYMBOL_GTGT)
            tokens.discard( 0, i+1 )  # remove "class Name<<...>>>"
            escapeForEach
          endIf
          if (t.type == TokenType.PLACEHOLDER) placeholders.add( t )
        endForEach
      else
        tokens.discard( 0, 2 )   # remove "class Name"
      endIf

      local m = Program.current_module
      local extended_name = "$<<$>>"(name,placeholders.count)
      if (m.templates[extended_name])
        if (placeholders.count)
          throw tokens.first.error( "A $-parameter template '$' already exists."(placeholders.count,name) )
        else
          throw tokens.first.error( "A class named '$' already exists."(name) )
        endIf
      endIf

      if (is_api) attributes |= (Attribute.ESSENTIAL | Attribute.API)
      local result = Template( class_t, m, name, placeholders, tokens, attributes )
      m.templates[extended_name] = result
      return result

    method on_parsed_subclass
      if (disable_output and not collecting_templates)
        return
      endIf

      local i1 = _saved_positions.last.position
      local i2 = _position - 1
      local class_t = _tokens[i1]  # 'subclass'

      local m = Program.current_module
      local hash = "$:$:$" (File(class_t.filepath).abs,class_t.line,class_t.column)

      if (collecting_templates)
        local name = "AnonymousSubclass" + Program.anonymous_class_names.count
        Program.anonymous_class_names[ hash ] = name

        local tokens = _tokens.from( i1+1, i2 ).to_list
        tokens.add( tokens.remove_last.cloned(TokenType.KEYWORD_END_CLASS) ) # 'endSubclass' -> 'endClass'

        local attributes = 0
        if (is_api) attributes |= (Attribute.ESSENTIAL | Attribute.API)
        local result = Template( class_t, m, name, Token[], tokens, attributes )
        m.templates["$<<0>>"(name)] = result

      else
        local name = Program.anonymous_class_names[ hash ]
        local template = m.templates["$<<0>>"(name)]
        local tokens = template.tokens

        tokens.insert( class_t.cloned(TokenType.EOL) )

        # Patch name and insert base class
        assert _cmd_stack.count >= 1
        local access = _cmd_stack.last

        if (access instanceOf Access)
          block access = access->(as Access)
            template.name = access.name + template.name
            name = template.name
            m.templates["$<<0>>"(name)] = template
            tokens.insert( class_t.cloned(TokenType.IDENTIFIER,access.name) )
            tokens.insert( class_t.cloned(TokenType.SYMBOL_COLON) )
            access.name = name
          endBlock
        elseIf (access instanceOf TemplatedAccess)
          block access = access->(as TemplatedAccess)
            local type_template_name = "$<<$>>"(access.name,access.type_args.count)
            local type_template = m.find_template( access.t, type_template_name, access.name, &extended_search )
            local of_type : Type
            if (type_template)
              of_type = Type( access.t,type_template,access.type_args )
            else
              throw class_t.error( "Reference to undefined type '$::$'."(m,access.type_args->String(access.name)) )
            endIf
            forEach (t in of_type.name_tokens step -1)
              tokens.insert( t )
            endForEach
            tokens.insert( class_t.cloned(TokenType.SYMBOL_COLON) )
            _cmd_stack.remove_last
            _cmd_stack.add( TypeAccess(access.t, Type(access.t,type_template,access.type_args), access.args) )
          endBlock
        elseIf (access instanceOf TypeAccess)
          block access = access->(as TypeAccess)
            forEach (t in access.of_type.name_tokens step -1)
              tokens.insert( t )
            endForEach
            tokens.insert( class_t.cloned(TokenType.SYMBOL_COLON) )
            access.of_type = Type( class_t, name )
          endBlock
        else
          throw class_t.error( "[INTERNAL] Unhandled context node for subclass: $."(access.type_name) )
        endIf

      endIf

    method on_parsed_routine
      local attributes : Int64
      if (_attribute_essential)
        attributes |= Attribute.ESSENTIAL
      endIf
      _attribute_essential = false

      if (not collecting_templates) return

      local i1 = _saved_positions.last.position
      local i2 = _position - 1
      local tokens = _tokens.from( i1, i2 ).to_list

      assert tokens.count
      local def_t = tokens.first

      # 'routine' -> 'method'
      def_t .= cloned( TokenType.KEYWORD_METHOD )
      tokens[0] = def_t

      tokens.insert( def_t.cloned(TokenType.EOL) )
      tokens.insert( def_t.cloned(TokenType.KEYWORD_GLOBAL_METHODS) )
      tokens.insert( def_t.cloned(TokenType.EOL) )
      tokens.add( tokens.last.cloned(TokenType.EOL,null) )
      tokens.add( tokens.last.cloned(TokenType.KEYWORD_END_CLASS) )

      local m = Program.current_module
      # Make this an augment of class Routine

      # Create a special aspect that will be incorporated into the designated class
      local aspect_name = "Augment_$_Routine_$"(m.next_augment_id,m.name)
      ++m.next_augment_id

      if (not m.augments.contains("Routine")) m.augments["Routine"] = String[]
      m.augments["Routine"].add( aspect_name )

      attributes |= Attribute.ASPECT | Attribute.AUGMENT
      if (is_api) attributes |= (Attribute.ESSENTIAL | Attribute.API)
      m.templates[aspect_name] = Template( augment_t, m, aspect_name, Token[], tokens, attributes )

    method parse_module_id
      # Doing this natively because we need to also switch context to the parsed module
      # so that we can store class templates in the appropriate module.
      local t = _next_t
      buffer.clear
      if (_consume(TokenType.SYMBOL_COLON_COLON))
        buffer.print "Rogue::" # default module
      elseIf (t.type != TokenType.IDENTIFIER)
        if (not disable_output) _push( null, 0 )
        Program.current_module = Program.default_module
        return
      endIf

      if (_next_t.type != TokenType.IDENTIFIER) _throw_syntax_error( "Identifier expected." )
      buffer.print _read.content

      while (_consume(TokenType.SYMBOL_COLON_COLON))
        buffer.print "::"
        if (_next_t.type != TokenType.IDENTIFIER) _throw_syntax_error( "Identifier expected." )
        buffer.print _read.content
      endWhile

      local module_id = buffer.cloned
      if (not disable_output) _push( Identifier(t,module_id), 0 )
      Program.current_module = Program.get_module( t, module_id )

    method _peek->Token
      if (inserted_tokens.count) return inserted_tokens.last
      return prior._peek

    method print_peek
      println "PEEK [$:$.$] $"(_next_t.filepath,_next_t.line,_next_t.column,_next_t)

    method print_stack
      @trace _cmd_stack
      #if (_cmd_stack.count and _cmd_stack.last) @trace _cmd_stack.last.type_name

    method debug_check
      if (_cmd_stack.count and _cmd_stack.last instanceOf ModuleQualifiedID)
        if (_cmd_stack.last->(as ModuleQualifiedID)->String.contains("Rogue::Color"))
          trace _tokens
        endIf
      endIf

    method print_stack_top
      if (_cmd_stack.count)
        if (_cmd_stack.last is null)
          println "STACK null"
        elseIf (_cmd_stack.last instanceOf Type)
          println "STACK [$] $ ($)"(_cmd_stack.last.t.source_position,_cmd_stack.last,_cmd_stack.last->(as Type).scoped_name)
        else
          println "STACK [$] $ ($)"(_cmd_stack.last.t.source_position,_cmd_stack.last,_cmd_stack.last.type_name)
        endIf
      else
        println "STACK []"
      endIf

    method print_stack_top_2
      if (_cmd_stack.count >= 2)
        local cmd = _cmd_stack[_cmd_stack.count-2]
        if (cmd) println "STACK [$] $, $"(cmd.t.source_position,cmd,_cmd_stack.last)
        else     println "STACK null"
      else
        print_stack_top
      endIf

    method print_trace
      @trace _next_t

    method print_stack_trace
      println StackTrace()

    method _read->Token
      if (inserted_tokens.count) return inserted_tokens.remove_last
      return prior._read

    method require_rogue_version
      local v_req = _cur_t.content.after_any('v').after_any('V')
      local v_cur = VERSION.after_any('v').after_any('V')
      if (VersionNumber(v_req) > v_cur)
        throw _cur_t.error(
          "Rogue v$ is currently installed but Rogue v$ or better is required to compile this file."(v_cur,v_req)
        )
      endIf

    method rewrite_cur_token
      processed_tokens.add( _cur_t )

    method rewrite_token
      processed_tokens.add( _read )

    method rogo_directive
      if (disable_output or _cmd_stack.is_empty) return
      local directive = _cmd_stack.remove_last->(as LiteralString)
      assert directive
      local file = File("Build.rogue")
      if (file.exists or File("BuildCore.rogue").exists)
        local content = which{ file.exists:String(file) || "" }
        local new_directive = "#$ " + directive
        if (not content.contains(new_directive))
          println "ROGO: " + new_directive
          content = new_directive + "\n" + content
          file.save( content )
        endIf
      endIf

    method set_cur_token
      _cur_t = _next_t

    method store_statement_args
      if (disable_output) return

      local args = _cmd_stack.remove_last->(as Args)
      assert args?
      block access = _cmd_stack.last->(as Access)
        if (access)
          if (access.args) throw args.t.error( "Unexpected expression." )
          access.args = args
          return
        endIf
      endBlock

      block access = _cmd_stack.last->(as ContextAccess)
        if (access)
          if (not access.args) access.args = args
          else throw args.t.error( "Unexpected expression." )
          return
        endIf
      endBlock

      throw args.t.error( "Unexpected expression." )

    method use_Introspection
      Scanner.uses_Introspection = true
      Scanner.uses_autoinclude = true

    method use_Table
      Scanner.uses_Table = true
      Scanner.uses_autoinclude = true

    method use_Value
      Scanner.uses_Value = true
      Scanner.uses_autoinclude = true

endClass
