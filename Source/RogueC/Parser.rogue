class Parser
  GLOBAL PROPERTIES
    old_style_function_warnings = Set<<String>>()
    deprecation_warnings = Set<<String>>()
    is_parsing_metacode : Logical

  PROPERTIES
    reader      : TokenReader
    filepath    : String
    this_type   : Type
    this_state  : State
    this_method : Method

    local_declarations = Local[]  # repeated temporary use
    property_list = Property[]    # temp use

    cur_statement_list : CmdStatementList

    parsing_augment : Logical

    used_modules    : UsedModule

    inserted_module_prefixes : Logical

    implicit_access_used : Logical
    implicit_loop_stack  = CmdControlStructure[]

    allow_placeholder_ids : Logical
    allow_parens_operator = true

    is_api_module : Logical
    is_api_file   : Logical

    is_essential_module : Logical
    is_essential_file   : Logical

  METHODS
    method init( filepath )
      init( Preprocessor(this).process(Tokenizer().tokenize(filepath)), &skip_reprocess )

    method init( filepath, content:String )
      init( Preprocessor(this).process(Tokenizer().tokenize(filepath,content)), &skip_reprocess )

    method init( t:Token, filepath, data:String, column_delta=0:Int32 )
      init( Preprocessor(this).process(Tokenizer().tokenize(t,filepath,data,column_delta)), &skip_reprocess )

    method init( tokens:Token[], &skip_reprocess, &preprocess )
      if (preprocess)             tokens = Preprocessor(this).process( tokens )
      elseIf (not skip_reprocess) tokens = Preprocessor( this ).reprocess( tokens )
      reader = TokenReader( tokens )
      is_api_file = RogueC.all_api
      is_essential_file = RogueC.all_essential

      if (filepath and filepath.ends_with(".rogue"))
        if (not is_api_file)
          is_api_file = RogueC.api_files.contains( filepath )
          if (not is_api_file)
            forEach (pattern in RogueC.api_file_patterns)
              if (File.matches_wildcard_pattern(filepath,pattern))
                is_api_file = true
                escapeForEach
              endIf
            endForEach
          endIf
        endIf
        if (not is_essential_file)
          is_essential_file = RogueC.essential_files.contains( filepath )
          if (not is_essential_file)
            forEach (pattern in RogueC.essential_files)
              if (File.matches_wildcard_pattern(filepath,pattern))
                is_essential_file = true
                escapeForEach
              endIf
            endForEach
          endIf
        endIf
      endIf

      is_api_module = is_api_file
      is_essential_module = is_essential_file

      local exported_modules = Program.exported_modules( null )
      if (exported_modules)
        forEach (exported_module in exported_modules)
          if (used_modules is null or not used_modules.contains(exported_module))
            used_modules = UsedModule( exported_module, used_modules )
          endIf
        endForEach
      endIf

    method consume( type:TokenType )->Logical
      if (not reader.next_is(type)) return false
      reader.read
      return true

    method consume( identifier:String )->Logical
      local t = reader.peek
      if (t.type is not TokenType.identifier) return false
      if (t->String != identifier) return false
      read
      return true

    method consume_end_commands->Logical
      local found = false
      while (consume(TokenType.eol) or consume(TokenType.symbol_semicolon)) found = true
      return found

    method consume_eols->Logical
      local found_any = false
      while (consume(TokenType.eol)) found_any = true
      return found_any

    method consume_optional->Logical
      if (not consume(TokenType.symbol_open_bracket)) return false
      local is_optional = false
      while (consume("optional")) is_optional = true
      if (not next_is(TokenType.symbol_close_bracket))
        throw peek.error( "Keyword 'optional' or closing ']' expected." )
      endIf
      must_consume( TokenType.symbol_close_bracket )
      return is_optional

    method error( message:String )->RogueError
      throw reader.peek.error( message )

    method insert_module_prefixes
      if (inserted_module_prefixes) return
      inserted_module_prefixes = true

      local id_map = ModulePrefixLookup()

      local skip_next_id = false
      while (reader.has_another)

        local t = reader.read

        if (t.type is TokenType.identifier)
          if (skip_next_id)
            skip_next_id = false
          else
            local name = t->String
            if (name[0] == ':')
              # ::Name -> Name unless Name is a known global in the default module
              local base_name = name.from( 2 )
              if (not Program.module_global_map("").contains(base_name))
                reader.tokens[ reader.position - 1 ] = t.type.create_token( t, base_name )
              endIf
            else
              local mapping = id_map[ name ]
              if (mapping)
                reader.tokens[ reader.position - 1 ] = t.type.create_token( t, mapping )
              endIf
            endIf
          endIf

        elseIf (t.type is TokenType.meta_module)
          id_map.clear
          local new_module_id : String
          if (next_is_identifier)
            new_module_id = read_identifier
            id_map.use_module( new_module_id )
          else
            consume( TokenType.symbol_colon_colon )
          endIf

          if (consume(TokenType.symbol_open_bracket))
            while (not next_is(TokenType.symbol_close_bracket))
              reader.read  # skip module attributes for now
            endWhile
            must_consume( TokenType.symbol_close_bracket )
          endIf

          local exported_modules = Program.exported_modules( new_module_id )
          if (exported_modules is null and new_module_id)
            local as_name = Program.module_as_name_to_instance_name[ new_module_id ]
            if (as_name) exported_modules = Program.exported_modules( as_name )
          endIf
          if (exported_modules)
            forEach (exported_module in exported_modules)
              id_map.use_module( exported_module )
            endForEach
          endIf

        elseIf (t.type is TokenType.meta_uses)
          local module_id = read_module_id
          id_map.use_module( module_id )
          parse_uses_attributes

          local exported_modules = Program.exported_modules( module_id )
          if (exported_modules is null and module_id)
            local as_name = Program.module_as_name_to_instance_name[ module_id ]
            if (as_name) exported_modules = Program.exported_modules( as_name )
          endIf
          if (exported_modules)
            forEach (exported_module in exported_modules)
            id_map.use_module( exported_module )
            endForEach
          endIf

        elseIf (t.type is TokenType.symbol_dot or t.type is TokenType.symbol_slash_slash)
          # The 'x' in 'obj.x' and 'obj//x' is not a candidate for module (namespace) qualification
          skip_next_id = true

        elseIf (t.type is TokenType.keyword_method)
          # If a module "m" contains both "routine x" and a class with "method x" we don't want
          # "method x" being converted to "method m::x".
          skip_next_id = true

        else
          skip_next_id = false

        endIf

      endWhile
      reader.position = 0  # rewind

    method read_module_id->String
      local module_id = read_identifier.after_any( '/' )
      if (module_id.contains('<'))
        local module_instance = Program.module_instance_lookup[ module_id ]
        require module_instance
        module_id = module_instance.resolve_name
        require module_id
      endIf
      return module_id

    method must_consume( type:TokenType, error_message=null:String )
      if (consume(type)) return
      local t = peek
      if (not error_message)
        error_message = "$ expected, found $." (type.quoted_name,t.quoted_name)
      endIf
      throw t.error( error_message )

    method must_consume_eols
      must_consume( TokenType.eol )
      consume_eols

    method must_read( type:TokenType )->Token
      local t = reader.peek
      if (t.type is not type) must_consume(type)
      return reader.read

    method next_is( type:TokenType )->Logical
      return reader.next_is( type )

    method next_is_end_command->Logical
      if (not reader.has_another) return false
      local type = reader.peek.type
      return type.is_end_command

    method next_is_identifier( name=null:String )->Logical
      local t = peek
      if (t.type != TokenType.identifier) return false
      if (not name) return true
      return (t->String == name)

    method next_is_statement->Logical
      if (not reader.has_another) return false
      return reader.next_is_statement_token

    method parse_elements
      insert_module_prefixes  # no effect if called twice

      while (parse_element) noAction

      if (reader.has_another)
        local t = peek
        throw t.error( "Syntax error: unexpected $." (t.quoted_name) )
      endIf

    method parse_element->Logical
      consume_eols
      if (not reader.has_another) return false

      if (parse_native_element) return true

      local t = peek

      if (t.type is TokenType.keyword_class)
        parse_class_template
        return true

      elseIf (t.type is TokenType.keyword_routine)
        parse_routine
        return true

      elseIf (t.type is TokenType.keyword_augment)
        parse_augment
        return true

      elseIf (t.type is TokenType.keyword_enum)
        parse_enum
        return true

      elseIf (t.type is TokenType.meta_module)
        read  # 'module'
        if (next_is_identifier)
          used_modules = UsedModule( read_identifier, null )
        else
          consume( TokenType.symbol_colon_colon )
          used_modules = null
        endIf

        is_api_module = false
        is_essential_module = false
        if (consume(TokenType.symbol_open_bracket))
          while (not next_is(TokenType.symbol_close_bracket))
            if (consume("api")) is_api_module = true
            elseIf (consume("essential")) is_essential_module = true
            else throw read.error( "Unrecognized module attributes. Only [api] and/or [essential] are allowed." )
          endWhile
          must_consume( TokenType.symbol_close_bracket )
        endIf
        if (is_api_file) is_api_module = true  # override the result if the whole file is [api]
        if (is_essential_file) is_essential_module = true

        must_consume_eols
        return true

      elseIf (t.type is TokenType.meta_uses)
        read  # 'uses'
        local module_id = read_module_id
        used_modules = UsedModule( module_id, used_modules )
        parse_uses_attributes

        must_consume_eols
        return true

      elseIf (next_is_statement)
        this_type = Program.get_type_reference( peek, "Global" )
        this_method = Program.get_on_launch_method( t )
        parse_multi_line_statements( this_method.statements )
        return true

      elseIf (next_is(TokenType.keyword_global))
        this_type = Program.get_type_reference( peek, "Global" )
        this_method = Program.get_on_launch_method( t )
        if (is_parsing_metacode)
          parse_local_or_global
        else
          local prev_statement_list = cur_statement_list
          cur_statement_list = this_method.statements
          parse_local_or_global
          cur_statement_list = prev_statement_list
        endIf
        return true

      endIf

      return false

    method parse_uses_attributes->UsesAttributes
      if (not consume(TokenType.symbol_open_bracket) or consume(TokenType.symbol_close_bracket))
        return UsesAttributes()
      endIf

      local should_export = false
      local no_include    = false
      consume_eols
      while (reader.has_another and not reader.next_is(TokenType.symbol_close_bracket))
        local t = reader.peek
        local id = read_identifier
        which (id)
          case "export":    should_export = true
          case "noInclude": no_include = true
          others: throw t.error( "Illegal '$', expected 'export' or 'noInclude'." (id) )
        endWhich
        consume_eols
        consume( TokenType.symbol_comma )
        consume_eols
      endWhile
      must_consume( TokenType.symbol_close_bracket )
      return UsesAttributes( &=should_export, &=no_include )

    method parse_class_template
      local t = read  # 'class'
      local name = read_identifier
      local template = Template( t, name, Attribute.is_class )
      parse_template_tokens( template, TokenType.keyword_endClass )

    method parse_routine
      local t = peek # 'routine'
      temporarily this_type = Program.get_type_reference( peek, "Global" )
        local attributes : Attributes
        if (is_api_module) attributes = Attributes( Attribute.is_essential )
        parse_method( &as_global, &first_token=TokenType.keyword_routine, &default_attributes=attributes )
        must_consume( TokenType.keyword_endRoutine )
        if (not this_method and not this_type.method_templates)
          throw t.error("Failed to parse routine")
        endIf
      endTemporarily

    method parse_template_tokens( template:Template, end_type:TokenType )
      local is_api_class = is_api_module
      if (not is_api_class)
        forEach (pattern in RogueC.api_class_patterns)
          if (File.matches_wildcard_pattern(template.name,pattern))
            is_api_class = true
            escapeForEach
          endIf
        endForEach
      endIf

      if (is_api_class) (ensure template.attributes).add( Attribute.is_api )

      if (is_essential_module) (ensure template.attributes).add( Attribute.is_essential )

      if (consume(TokenType.symbol_open_specialize))
        local first = true
        while (first or consume(TokenType.symbol_comma))
          first = false
          local t = must_read( TokenType.placeholder_id )
          template.add_type_parameter( t, t->String )
        endWhile
        must_consume( TokenType.symbol_close_specialize )
      endIf

      # Skip past any args and base types to get to the [attributes]
      #   (autoinit) : BaseType, ... [attributes] \n
      #   ^^^^^^^^^^^^^^ leave       ^parse       ^leave
      local starting_pos = reader.position
      allow_placeholder_ids = true

      if (consume(TokenType.symbol_open_paren))
        # ( name1[=value1][:Type1] [, ...] )
        consume_eols
        if (not consume(TokenType.symbol_close_paren))
          local first = true
          while (first or consume(TokenType.symbol_comma))
            first = false
            consume_eols
            consume( TokenType.symbol_ampersand )
            read_identifier
            consume_eols
            if (consume(TokenType.symbol_equals)) parse_expression
            consume_eols
            if (consume(TokenType.symbol_colon))
              if (not consume(TokenType.placeholder_id)) parse_type_name
            endIf
            consume_eols
          endWhile
          must_consume( TokenType.symbol_close_paren )
        endIf
      endIf

      if (consume(TokenType.symbol_colon))
        parse_type_name
        while (consume(TokenType.symbol_comma)) parse_type_name
      endIf

      local final_pos = reader.position
      allow_placeholder_ids = false

      reader.position = starting_pos
      while (reader.position < final_pos) template.tokens.add( read )

      # Parse out attributes
      parse_attributes( template.attributes )

      local semi_t = peek
      if (consume(TokenType.symbol_semicolon))
        if (template.tokens.count == 0) template.tokens.add( TokenType.eol.create_token(semi_t) )
        Program.add_template( template )
        return
      endIf

      while (reader.has_another)
        local t = reader.read
        if (t.type is end_type)
          # Must wait to add_template() until finished collecting tokens because overloaded routines
          # just append their tokens to the template generated from the original routines.
          Program.add_template( template )
          return
        endIf
        template.tokens.add( t )
      endWhile

      throw reader.error( "$ expected, found end of file." (end_type.quoted_name) )

    method parse_augment
      local t = reader.read  # 'augment'

      local name = parse_type_name
      if (name.contains('$'))
        local base_name = name.before_first( '<' )
        throw t.error( "Illegal placeholder type in augment.  Write '$' without the specializers (<<...>>) to apply the augment to all template instances or write specific types such as $<<String>> to restrict the augment to that type." (base_name,base_name) )
      endIf

      local aug = Augment( t, name )
      local augments = Program.augment_lookup[ name ]
      if (not augments)
        augments = Augment[]
        Program.augment_lookup[ name ] = augments
      endIf
      augments.add( aug )

      local base_name = name.after_any("::")
      #trace name, base_name
      if (base_name.count < name.count)
        augments = Program.augment_lookup[ base_name ]
        if (not augments)
          augments = Augment[]
          Program.augment_lookup[ base_name ] = augments
        endIf
        augments.add( aug )
      endIf

      if (consume(TokenType.symbol_colon))
        aug.base_types.add( parse_type )
        consume_eols
        while (consume(TokenType.symbol_comma))
          consume_eols
          aug.base_types.add( parse_type )
          consume_eols
        endWhile
      endIf

      if (consume(TokenType.symbol_semicolon)) return
      consume_eols

      while (reader.has_another and not next_is(TokenType.keyword_endAugment))
        aug.tokens.add( reader.read )
      endWhile

      must_consume( TokenType.keyword_endAugment )


    method parse_enum
      local t = read  # 'enum'
      local name = read_identifier
      local template = Template( t, name, Attribute.is_compound | Attribute.is_enum )

      if (consume(TokenType.symbol_open_specialize))
        local first = true
        while (first or consume(TokenType.symbol_comma))
          first = false
          local t2 = must_read( TokenType.placeholder_id )
          template.add_type_parameter( t2, t2->String )
        endWhile
        must_consume( TokenType.symbol_close_specialize )
      endIf

      # Skip past any args to get to the [attributes]
      #   (autoinit) : BaseType1, ... [attributes] \n
      #   ^^leave^^^^^^^^^^^^^^^      ^parse^^^^^^ ^leave
      local starting_pos = reader.position
      allow_placeholder_ids = true

      if (consume(TokenType.symbol_open_paren))
        # ( name1[=value1][:Type1] [, ...] )
        consume_eols
        if (not consume(TokenType.symbol_close_paren))
          local first = true
          while (first or consume(TokenType.symbol_comma))
            first = false
            consume_eols
            consume( TokenType.symbol_ampersand )
            read_identifier
            consume_eols
            if (consume(TokenType.symbol_equals)) parse_expression
            consume_eols
            if (consume(TokenType.symbol_colon))
              if (not consume(TokenType.placeholder_id)) parse_type_name
            endIf
            consume_eols
          endWhile
          must_consume( TokenType.symbol_close_paren )
        endIf
      endIf

      if (consume(TokenType.symbol_colon))
        parse_type_name
        while (consume(TokenType.symbol_comma)) parse_type_name
      endIf

      local final_pos = reader.position
      allow_placeholder_ids = false

      reader.position = starting_pos
      while (reader.position < final_pos) template.tokens.add( read )

      parse_attributes( template.attributes )


      local is_api_enum = is_api_module
      if (not is_api_enum)
        forEach (pattern in RogueC.api_class_patterns)
          if (File.matches_wildcard_pattern(template.name,pattern))
            is_api_enum = true
            escapeForEach
          endIf
        endForEach
      endIf
      if (is_api_enum) template.attributes.add( Attribute.is_api )
      if (is_essential_module) (ensure template.attributes).add( Attribute.is_essential )

      t = peek
      if (consume(TokenType.symbol_semicolon))
        if (template.tokens.count == 0) template.tokens.add( TokenType.eol.create_token(t) )
        Program.add_template( template )
        return
      endIf

      template.tokens.add( TokenType.keyword_CATEGORIES.create_token(peek) )

      while (reader.has_another)
        t = reader.read
        if (t.type is TokenType.keyword_endEnum)
          Program.add_template( template )
          return
        endIf
        template.tokens.add( t )
      endWhile

      throw reader.error( "'endEnum' expected, found end of file." )


    method parse_attributes( attributes=null:Attributes )->Attributes
      if (not consume(TokenType.symbol_open_bracket)) return attributes
      if (attributes is null) attributes = Attributes()

      while (reader.has_another and not next_is(TokenType.symbol_close_bracket))
        local t = peek
        if (consume(TokenType.keyword_native))
          attributes.add( Attribute.is_native )
        elseIf (consume(TokenType.keyword_deprecated))
          attributes.add( Attribute.is_deprecated )

        elseIf (consume("abstract"))
          attributes.add( Attribute.is_abstract )
        elseIf (consume("aspect"))
          ensure_unspecialized_element_type( t, attributes )
          attributes.add( Attribute.is_aspect )
        elseIf (consume("compound"))
          ensure_unspecialized_element_type( t, attributes )
          attributes.add( Attribute.is_compound )
        elseIf (consume("fallback"))
          attributes.add( Attribute.is_fallback )
        elseIf (consume("immutable"))
          attributes.add( Attribute.is_immutable )
        elseIf (consume("macro"))
          attributes.add( Attribute.is_macro )
          #attributes.add( Attribute.is_propagated )
        elseIf (consume("mutating"))
          attributes.add( Attribute.is_mutating )
        elseIf (consume("nonAPI"))
          attributes.add( Attribute.is_nonAPI )
        elseIf (consume("override"))
          attributes.add( Attribute.is_override )
        elseIf (consume("preferred"))
          attributes.add( Attribute.is_preferred )
        elseIf (consume("primitive"))
          ensure_unspecialized_element_type( t, attributes )
          attributes.add( Attribute.is_primitive )
        elseIf (consume("propagated"))
          attributes.add( Attribute.is_propagated )
        elseIf (consume("essential"))
          attributes.add( Attribute.is_essential )
        elseIf (consume("singleton"))
          attributes.add( Attribute.is_singleton )
        elseIf (consume("special"))
          attributes.add( Attribute.is_special )
        elseIf (consume("task"))
          attributes.add( Attribute.is_task )
        elseIf (consume("api"))
          attributes.add( Attribute.is_api )
        elseIf (consume("synchronized"))
          attributes.add( Attribute.is_synchronized )
        elseIf (consume("threadLocal"))
          attributes.add( Attribute.is_thread_local )
        elseIf (consume("canOperateOnLiteralNull"))
          attributes.add( Attribute.can_operate_on_literal_null )
        elseIf (next_is(TokenType.identifier))
          attributes.add( read->String )
        else
          throw peek.error( "Invalid attribute: " + peek )
        endIf
      endWhile

      must_consume( TokenType.symbol_close_bracket )

      return attributes

    method ensure_unspecialized_element_type( t:Token, attributes:Attributes )
      if ((attributes.flags & Attribute.type_mask) != Attribute.is_class)
        throw t.error( "A class cannot be both '$' and '$'." (t->String,attributes.element_type_name) )
      endIf

    method parse_type_def( this_type )
      local t = peek

      local compound_has_create = false
      if (consume(TokenType.symbol_open_paren))
        # ( auto_property[=value][:Type, ... )
        consume_eols
        if (not consume(TokenType.symbol_close_paren))
          local m : Method
          if (not this_type.is_enum)
            if (this_type.is_compound)
              compound_has_create = true
              m = this_type.add_global_method( t, "create" )
              m.attributes.add( Attribute.is_generated )
            else
              m = this_type.add_method( t, "init" )
            endIf
            m.return_type = this_type
            local first = true
            while (first or consume(TokenType.symbol_comma))
              first = false
              consume_eols

              # [&]name[=default_value][:Type]
              t = peek
              local is_flag = consume( TokenType.symbol_ampersand )
              local p_name = read_identifier
              local param = m.add_parameter( t, p_name )
              consume_eols
              if (consume(TokenType.symbol_equals)) param.initial_value = parse_expression
              consume_eols

              local p_type : Type
              if (consume(TokenType.symbol_colon))
                consume_eols
                p_type = parse_type

                if (this_type.is_compound)
                  param.type = p_type
                endIf

                this_type.add_property( t, p_name, p_type )

              elseIf (is_flag)
                p_type = Program.type_Logical
                if (this_type.is_compound) param.type = p_type
                this_type.add_property( t, p_name, p_type )
              endIf

              if (is_flag and not param.initial_value)
                if (p_type is Program.type_Logical)
                  param.initial_value = CmdLiteralLogical( t, false )
                else
                  param.initial_value = CmdLiteralInt32( t, 0 )
                endIf
              endIf

              consume_eols
            endWhile
          else
            # enum - just add properties without generating an init() method
            local first = true
            while (first or consume(TokenType.symbol_comma))
              first = false
              consume_eols

              # &name[=default_value]:Type
              t = peek
              local is_flag_arg = consume( TokenType.symbol_ampersand )
              local p_name = read_identifier
              consume_eols
              local initial_value : Cmd
              if (consume(TokenType.symbol_equals)) initial_value = parse_expression
              consume_eols

              local p_type : Type
              if (is_flag_arg)
                if (consume(TokenType.symbol_colon))
                  consume_eols
                  p_type = parse_type
                else
                  p_type = Program.type_Logical
                endIf
                if (not initial_value) initial_value = p_type.create_default_value(t)
              else
                must_consume( TokenType.symbol_colon )
                consume_eols
                p_type = parse_type
              endIf

              this_type.add_enum_property( Property(t,this_type,p_name,p_type,initial_value) )

              consume_eols
            endWhile
          endIf
          must_consume( TokenType.symbol_close_paren )
        endIf
      endIf

      if (this_type.is_compound)
        this_type.base_types.add( Program.get_type_reference(t,"CompoundIntrospection<<$>>"(this_type.name)) )
        if (not compound_has_create)
          local m = this_type.add_global_method( t, "create" )
          m.attributes.add( Attribute.is_generated )
          m.return_type = this_type
        endIf
      endIf

      if (consume(TokenType.symbol_colon))
        # : BaseType1, BaseType2, ...
        local first = true
        while (first or consume(TokenType.symbol_comma))
          first = false
          consume_eols
          this_type.base_types.add( parse_type )
          consume_eols
        endWhile
      endIf

      while (parse_section) noAction
      consume_eols

      if (reader.has_another)
        if (next_is(TokenType.keyword_global))
          throw peek.error( "Global variables must be declared in global scope outside of any class or routine definitions." )
        else
          throw peek.error( "Syntax error: unexpected $." (peek.quoted_name) )
        endIf
      endIf


    method parse_section->Logical
      consume_eols

      local message = parse_deprecated
      if (message)
        this_type.attributes.add( Attribute.is_deprecated )
        this_type.attributes.add( Attribute.is_nonAPI )
        this_type.deprecated_message = message
        return true
      endIf

      if (consume(TokenType.keyword_DEPENDENCIES))
        while (parse_dependency) noAction
        return true
      endIf

      if (consume(TokenType.begin_augment_tokens))
        parsing_augment = true
        consume_eols
      endIf

      if (consume(TokenType.keyword_ENUMERATE))
        while (parse_definitions(true)) noAction
        return true
      endIf

      if (consume(TokenType.keyword_DEFINITIONS))
        while (parse_definitions(false)) noAction
        return true
      endIf

      if (consume(TokenType.keyword_GLOBAL))
        if (consume(TokenType.keyword_PROPERTIES))
          local attributes = parse_attributes
          while (parse_properties(&as_global, &default_attributes=attributes)) noAction
          return true
        elseIf (consume(TokenType.keyword_METHODS))
          local attributes = parse_attributes
          while (parse_method(&as_global, &default_attributes=attributes)) noAction
          return true
        endIf
      endIf

      if (consume(TokenType.keyword_PROPERTIES))
        local attributes = parse_attributes
        while (parse_properties(&default_attributes=attributes)) noAction
        return true
      endIf

      if (consume(TokenType.keyword_METHODS))
        local attributes = parse_attributes
        while (parse_method(&default_attributes=attributes)) noAction
        return true
      endIf

      if (consume(TokenType.keyword_STATES))
        while (parse_state) noAction
        return true
      endIf


      if (next_is(TokenType.keyword_CATEGORIES))
        if (not this_type.is_enum)
          throw peek.error( "Only an 'enum' type can contain a CATEGORIES section." )
        endIf

        read  # CATEGORIES
        while (parse_categories) noAction
        return true
      endIf

      return false

    method parse_categories->Logical
      consume_eols
      if (not next_is_identifier) return false

      ensure this_type.categories

      local first = true
      while (first or consume(TokenType.symbol_comma))
        consume_eols
        first = false
        local t = peek
        local def = Definition( t, read_identifier )
        local named_args : StringTable<<Cmd>>
        if (consume(TokenType.symbol_open_paren))
          consume_eols
          if (not consume(TokenType.symbol_close_paren))
            ensure def.args
            if (next_is(TokenType.symbol_comma))
              def.args.add( null )
            elseIf (consume(TokenType.symbol_ampersand))
              ensure named_args
              local is_true = not consume(TokenType.symbol_exclamation_point)
              local t2 = peek
              local name = read_identifier
              consume_eols
              if (consume(TokenType.symbol_equals)) consume_eols; named_args[ name ] = parse_expression
              else                                  named_args[ name ] = CmdLiteralLogical( t2, is_true )
            else
              def.args.add( parse_expression )
            endIf
            local expecting_arg = false
            while (consume(TokenType.symbol_comma))
              expecting_arg = true
              consume_eols
              if (next_is(TokenType.symbol_close_paren)) escapeWhile
              expecting_arg = false
              if (next_is(TokenType.symbol_comma))
                def.args.add( null )
              elseIf (consume(TokenType.symbol_ampersand))
                ensure named_args
                local t2 = peek
                local name = read_identifier
                consume_eols
                if (consume(TokenType.symbol_equals)) consume_eols; named_args[ name ] = parse_expression
                else                                  named_args[ name ] = CmdLiteralLogical( t2, true )
              else
                def.args.add( parse_expression )
              endIf
              consume_eols
            endWhile
            if (expecting_arg) def.args.add( null )
            consume_eols
            must_consume( TokenType.symbol_close_paren )

            # insert named args
            if (named_args)
              local p_list = which{ this_type.is_enum:this_type.enum_properties || this_type.property_list }
              if (p_list)
                forEach (name in named_args.keys)
                  local i = p_list.locate( $.name == name )
                  if (i.exists)
                    while (def.args.count <= i.value) def.args.add( null )
                    if (def.args[i.value]) throw named_args[name].t.error( "Multiple values given for enum property '$'." (name) )
                    def.args[i.value] = named_args[name]
                  else
                    throw named_args[name].t.error( "No such enum property '$'." (name) )
                  endIf
                endForEach
              elseIf (named_args.count)
                local names = named_args.keys
                throw named_args.first.t.error( "No such enum property '$'." (names.read) )
              endIf
            endIf

          endIf
        endIf
        if (consume(TokenType.symbol_equals))
          def.expression = parse_expression
        endIf
        this_type.categories.add( def )
        consume_eols
      endWhile
      return true


    method parse_definitions( enumerate:Logical )->Logical
      consume_eols
      if (not next_is(TokenType.identifier)) return false

      local t = peek
      local name  = read_identifier
      local value : Cmd

      if (consume(TokenType.symbol_equals))
        consume_eols
        value = parse_expression
      elseIf (not consume_eols)
        value = parse_expression
      endIf

      if (not enumerate and not value)
        throw peek.error( "Definition expected." )
      endIf

      if (value)
        if (value instanceOf CmdLiteralInt32)
          this_type.prev_enum_cmd = null
          this_type.next_enum_offset = (value->(as CmdLiteralInt32)).value + 1
        else
          this_type.prev_enum_cmd = value
          this_type.next_enum_offset = 1
        endIf
      else
        if (this_type.prev_enum_cmd)
          value = CmdAdd( t, this_type.prev_enum_cmd.cloned, CmdLiteralInt32(t,this_type.next_enum_offset) )
        else
          value = CmdLiteralInt32( t, this_type.next_enum_offset )
        endIf
        ++this_type.next_enum_offset
      endIf

      local def = Definition( t, name, value )
      this_type.definition_lookup[ name ] = def
      this_type.definition_list.add( def )

      return true

    method parse_properties( as_global=false:Logical, default_attributes=null:Attributes )->Logical
      consume_eols

      if (consume(TokenType.keyword_native))
        # Example: native "FILE* fp;"
        if (not next_is(TokenType.literal_string))
          throw peek.error( "Literal string expected." )
        endIf

        local native_t = read
        local p = this_type.add_property( native_t, native_t->String, Program.type_Int64 )
        p.mark_native
        if (default_attributes) p.attributes |= default_attributes.flags

        must_consume_eols
        return true
      endIf

      if (not next_is(TokenType.identifier)) return false

      property_list.clear
      # Stores current property declarations so that we can come back and
      # and assign a type to them.

      local first = true
      while (first or consume(TokenType.symbol_comma))
        first = false
        consume_eols
        local t = peek
        local name = read_identifier
        local p : Property
        if (as_global) p = this_type.add_global( t, name )
        else           p = this_type.add_property( t, name )
        property_list.add( p )

        # Allow per-property attributes
        if (next_is(TokenType.symbol_open_bracket))
          local attributes = Attributes()
          parse_attributes( attributes )
          p.attributes |= attributes.flags
        endIf
        # Default (section) attributes
        if (default_attributes) p.attributes |= default_attributes.flags

        if (consume(TokenType.symbol_equals))
          p.initial_value = parse_expression
        endIf
      endWhile

      consume_eols
      if (consume(TokenType.symbol_colon))
        local p_type = parse_type
        forEach (p in property_list)
          p.type = p_type
        endForEach
      else
        forEach (p in property_list)
          determine_property_type( property_list, p, &is_global=as_global )
        endForEach
      endIf

      return true

    method determine_property_type( property_list:Property[], p:Property, is_global:Logical )
      if (not p.initial_value)
        local property_type = which{ is_global:"global property" || "property" }
        throw p.t.error( ''An initial value or $ type (for example, ": Int32") must be specified.'' (property_type) )
      endIf

      p.type = p.initial_value.implicit_type( Scope(this_type,null) )
      if (p.type) return

      local access = p.initial_value->(as CmdAccess)
      if (access and not access.context and not access.args)
        # Plain variable name.
        # See if it's a previously declared property in this same line of declarations
        forEach (previous_p in property_list)
          if (previous_p is p) escapeForEach
          if (previous_p.name == access.name)
            p.type = previous_p.type
            return
          endIf
        endForEach

        # See if it's a previously declared property in this type
        local prev : Property
        if (not is_global) prev = this_type.property_lookup[ access.name ]
        if (not prev)      prev = this_type.global_lookup[ access.name ]
        if (prev and prev.type)
          p.type = prev.type
          return
        endIf
      endIf

      # Not found. Throw an error.
      local property_type = which{ is_global:"global property" || "property" }
      throw p.initial_value.t.error(
      ''Cannot determine $ type from initial value; append an explicit type declaration such as ": Int32" '' (property_type) )

    method parse_state->Logical
      consume_eols
      if (not consume(TokenType.symbol_gt)) return false

      local t = peek
      this_state = State( t, read_identifier )
      this_type.states[ this_state.name ] = this_state
      must_consume_eols

      while (parse_method(&skip_add_to_type))
        this_state.methods.add( this_method )
      endWhile

      return true

    method parse_method( as_global=false:Logical, default_attributes=null:Attributes, &skip_add_to_type, first_token=TokenType.keyword_method:TokenType )->Logical
      consume_eols
      if (not next_is(first_token)) return false

      if (parse_method_header(as_global, default_attributes) is null) return true
      # Sets up 'this_method'

      parse_attributes( this_method.attributes )
      if (parsing_augment) this_method.attributes.add( Attribute.is_augment )

      if (this_method.is_special and this_type.name == "Boxed<<String>>" and this_method.name == "to_String")
        # Boxed<<String>>.to->$DataType will end up conflicting with to->String; omit this method
        skip_add_to_type = true
      endIf

      if (not skip_add_to_type)
        if (as_global)
          this_type.add_global_method( this_method )
        else
          if (is_api_module and this_type is Program.type_Global) this_type.attributes.add( Attribute.is_api )
          this_type.add_method( this_method )
        endIf
      endIf

      consume( TokenType.symbol_colon )

      consume_eols

      local t_start_pos = reader.position

      parse_method_body

      if (this_method.is_propagated and not this_method.source_tokens)
        # [propagated] methods save the source tokens used to parse this method
        local n = reader.position - t_start_pos
        this_method.source_tokens = Token[]( n )
        forEach (i in t_start_pos..<reader.position)
          this_method.source_tokens.add( reader.tokens[i] )
        endForEach
      endIf

      return true

    method parse_method_body
      if (this_method.is_macro)

        # Kludge to bridge old macro system to new
        local is_native_macro = false
        if (next_is(TokenType.keyword_return) and reader.peek(1).type is TokenType.keyword_native) reader.read
        if (consume(TokenType.keyword_native))
          is_native_macro = true
        endIf

        if (this_method.is_native or is_native_macro)
          # macro native [(] "$this.fn($arg)" [)]

          local has_parens = consume( TokenType.symbol_open_paren )
          consume_eols

          if (not next_is(TokenType.literal_string))
            throw peek.error( "Literal string expected." )
          endIf

          local t = peek
          this_method.native_code = read->String

          if (has_parens)
            consume_eols
            must_consume( TokenType.symbol_close_paren )
          endIf

          if (next_is(TokenType.symbol_arrow))
            consume( TokenType.symbol_arrow )
            this_method.native_return_type = parse_type
          elseIf (this_method.return_type)
            this_method.native_return_type = this_method.return_type
          endIf

          # Native macros get code in two places:
          # 1. native_code and native_return_type
          # 2. statements
          # Originally there was only #1. Transitioning to system where all macros
          # are also regular methods, adding #2. In the future it should be
          # possible have #2 only.
          local cmd = CmdInlineNative( t, this_method.native_code, this_method.native_return_type ) : Cmd
          if (this_method.native_return_type) cmd = CmdReturn( t, cmd )
          this_method.statements.add( cmd )

        else
          # macro this.fn(arg)
          # macro ...
          parse_single_line_statements( this_method.statements )
          if (this_method.statements.count == 1 and this_method.return_type)
            local statement = this_method.statements.first
            if (statement not instanceOf CmdReturn)
              this_method.statements.[ clear, add(CmdReturn(statement.t,statement)) ]
            endIf
          endIf
        endIf

      else
        if (parsing_augment)
          parse_augment_statements
        else
          this_method.statements.add( this_method.begin_label(peek,"insert",false) )
          parse_multi_line_statements( this_method.statements )
          this_method.statements.add( this_method.begin_label(peek,"append",false) )
        endIf
      endIf

    method parse_method_header( as_global=false:Logical, default_attributes=null:Attributes )->Method
      local t = read  # 'routine' or 'method'
      local name = read_identifier
      local return_type : Type
      which (name)
        case "operator"
          name += reader.read->String
        case "to"
          if (consume(TokenType.symbol_arrow))
            return_type = parse_type
            name = "to_" + return_type.name
          endIf
        others
      endWhich

      local specialization_info : ValueTable
      local unspecialized_name = name
      if (next_is(TokenType.symbol_open_specialize))
        if (reader.peek(1).type is TokenType.placeholder_id)
          parse_method_template( t, name, as_global )
          return null
        else
          specialization_info = parse_specialization_info
          name += specialization_info[ "string" ]->String
        endIf
      endIf

      this_method = Method( t, this_type, name )
      if (default_attributes) this_method.attributes.add(default_attributes)
      if (as_global)
        this_method.attributes.add( Attribute.is_global )
      endIf

      this_method.return_type = return_type
      if (specialization_info)
        this_method.specializer_count = specialization_info[ "count" ]->Int32
        this_method.unspecialized_name = unspecialized_name
      endIf

      # Parse parameters
      if (consume(TokenType.symbol_open_paren))
        if (not consume(TokenType.symbol_close_paren))
          local first = true
          while (first or consume(TokenType.symbol_comma))
            first = false
            consume_eols

            local is_flag = consume( TokenType.symbol_ampersand )                  # &x

            # identifier
            t = peek
            local param = this_method.add_parameter( t, read_identifier(true) )

            if (consume(TokenType.symbol_equals))
              # = default_value
              param.initial_value = parse_expression
            endIf

            if (consume(TokenType.symbol_colon))
              # : Type
              param.type = parse_type
              if (consume(TokenType.symbol_at))
                param.is_alias = true
              endIf
            endIf

            if (is_flag)
              param.is_flag = true
              if (not param.type) param.type = Program.type_Logical
              if (not param.initial_value) param.initial_value = param.type.create_default_value( param.t )
            endIf
          endWhile
          consume_eols
          must_consume( TokenType.symbol_close_paren )
        endIf
      endIf

      # Optional ->ReturnType
      if (not return_type)
        if (consume(TokenType.symbol_arrow))
          if (consume(TokenType.keyword_this) or consume(TokenType.keyword_ThisType))
            this_method.return_type = this_type
            this_method.attributes.add( Attribute.returns_this )
          else
            this_method.return_type = parse_type
          endIf
        endIf
      endIf

      return this_method

    method parse_method_template( t:Token, name:String, is_global:Logical )
      read  # '<<'

      local m = MethodTemplate( t, this_type, name, is_global )

      local first = true
      while (first or consume(TokenType.symbol_comma))
        first = false
        local t2 = must_read( TokenType.placeholder_id )
        m.type_parameters.add( TypeParameter(t2,t2->String) )
      endWhile
      must_consume( TokenType.symbol_close_specialize )

      local tokens = m.template_tokens
      while (reader.has_another and peek.type.is_method_content)
        tokens.add( reader.read )
      endWhile

      this_type.method_templates.add( m )

    method parse_single_or_multi_line_statements( statements:CmdStatementList, end_type:TokenType )
      if (consume_eols)
        # multi-line while
        parse_multi_line_statements( statements )
        must_consume( end_type )
      else
        # single-line while
        parse_single_line_statements( statements )
        consume_eols
      endIf

    method parse_multi_line_statements( statements:CmdStatementList )
      consume_end_commands
      while (next_is_statement)
        parse_statement( statements, true )

        consume_end_commands
      endWhile

    method parse_augment_statements
      this_method.begin_label( peek, "insert", true )
      this_method.begin_label( peek, "append", true )

      local cur_label = this_method.begin_label( peek, "insert", true )

      consume_end_commands
      while (next_is_statement)

        local t = peek

        if (consume(TokenType.symbol_lt))
          cur_label = this_method.begin_label( t, read_identifier, true )
          cur_statement_list = cur_label.statements
          must_consume( TokenType.symbol_gt )
          consume_end_commands
          nextIteration
        endIf

        parse_statement( cur_label.statements, true )

        consume_end_commands
      endWhile

    method parse_single_line_statements( statements:CmdStatementList )
      while (next_is_statement)
        parse_statement( statements, false )
        if (not consume(TokenType.symbol_semicolon)) return
        while (consume(TokenType.symbol_semicolon)) noAction

        # Don't let a trailing ';' act as a next-line continuation.
        if (next_is_end_command) escapeWhile
      endWhile

      if (not consume(TokenType.eol))
        if (not peek.is_structure)
          must_consume( TokenType.eol )  # force an error
        endIf
      endIf

    method parse_statement( statements:CmdStatementList, allow_control_structures:Logical )
      local prev_statement_list = cur_statement_list
      cur_statement_list = statements

      local original_statement_count = statements.count
      local original_implicit_loop_count = implicit_loop_stack.count

      parse_statement( allow_control_structures )

      while (implicit_loop_stack.count > original_implicit_loop_count)
        forEach (original_statement_count..<statements.count)
          implicit_loop_stack.last.statements.add( statements.remove_at(original_statement_count) )
        endForEach
        statements.add( implicit_loop_stack.remove_last )
      endWhile

      cur_statement_list = prev_statement_list

    method parse_statement( allow_control_structures:Logical )
      if (parse_unit_test) return

      local deprecated_message = parse_deprecated
      if (deprecated_message)
        this_method.attributes.add( Attribute.is_deprecated )
        this_method.attributes.add( Attribute.is_nonAPI )
        this_method.deprecated_message = deprecated_message
        return
      endIf

      local t = peek

      if (consume(TokenType.keyword_nativeHeader))
        # Turn this nativeHeader into a Cmd node instead of storing the native header
        # directly so that the header is only added if the method is resolved (meaning
        # it's actually used in the program).  This is a way to have classes with native
        # dependencies that don't get pulled in if they're unused.
        cur_statement_list.add( CmdNativeHeader(t,t->String) )
        return
      endIf

      if (consume(TokenType.keyword_nativeCode))
        # Turn this nativeCode into a Cmd node instead of storing the native code
        # directly so that the code is only added if the method is resolved (meaning
        # it's actually used in the program).  This is a way to have classes with native
        # dependencies that don't get pulled in if they're unused.
        cur_statement_list.add( CmdNativeCode(t,t->String) )
        return
      endIf

      if (consume(TokenType.keyword_nativeLibrary))
        # Turn this nativeLibrary into a Cmd node instead of storing the native library
        # directly so that the library is only added if the method is resolved (meaning
        # it's actually used in the program).  This is a way to have classes with native
        # dependencies that don't get pulled in if they're unused.
        if (not next_is(TokenType.literal_string))
          throw peek.error( "String specifying native library expected." )
        endIf
        cur_statement_list.add( CmdNativeLibrary(t,read->String) )
        return
      endIf

      if (consume(TokenType.keyword_includeNativeCode))
        if (not next_is(TokenType.literal_string))
          throw peek.error( "Filepath expected." )
        endIf
        local filepath = read->String
        cur_statement_list.add( CmdIncludeNative(t,filepath,"code",consume_optional) )
        return
      endIf

      if (consume(TokenType.keyword_includeNativeHeader))
        if (not next_is(TokenType.literal_string))
          throw peek.error( "Filepath expected." )
        endIf
        local filepath = read->String
        cur_statement_list.add( CmdIncludeNative(t,filepath,"header",consume_optional) )
        return
      endIf

      if (consume(TokenType.keyword_includeSource))
        if (not next_is(TokenType.literal_string))
          throw peek.error( "Filepath expected." )
        endIf
        local filepath = read->String
        if (RogueC.include_source( t, filepath, consume_optional ))
          RogueC.parse_pending_files
        endIf
        return
      endIf

      if (consume(TokenType.keyword_includeSourceFolder))
        if (not next_is(TokenType.literal_string))
          throw peek.error( "Folder path expected." )
        endIf
        local filepath = read->String
        if (RogueC.include_source( t, filepath, consume_optional, &including_folder ))
          RogueC.parse_pending_files
        endIf
        return
      endIf

      if (consume(TokenType.keyword_compileArg))
        if (not next_is(TokenType.literal_string))
          throw peek.error( "Literal string expected (e.g. \"-pthread\")." )
        endIf
        RogueC.compiler_options.add( read->String )
        return
      endIf

      if (consume(TokenType.meta_essential))
        # Turn this $essential directive into a Cmd node so that it only takes effect
        # if the method is actually used in the program.
        cur_statement_list.add( CmdMakeRequisite(t,t->String) )
        return
      endIf
      if (allow_control_structures)
        if (next_is(TokenType.keyword_if))
          cur_statement_list.add( parse_if )
          return

        elseIf (next_is(TokenType.keyword_which))
          cur_statement_list.add( parse_which )
          return

        elseIf (next_is(TokenType.keyword_forEach))
          cur_statement_list.add( parse_for_each )
          return

        elseIf (next_is(TokenType.keyword_block))
          cur_statement_list.add( parse_block )
          return

        elseIf (next_is(TokenType.keyword_temporarily))
          cur_statement_list.add( parse_temporarily )
          return

        elseIf (consume(TokenType.keyword_compileError))
          if (next_is(TokenType.literal_string))
            throw t.error( read->String )
          else
            throw t.error( "Missing API implementation for current compile target." )
          endIf

        elseIf (next_is(TokenType.keyword_contingent))
          cur_statement_list.add( parse_contingent )
          return

        elseIf (next_is(TokenType.keyword_while))
          cur_statement_list.add( parse_while )
          return

        elseIf (next_is(TokenType.keyword_loop))
          cur_statement_list.add( parse_loop )
          return

        elseIf (next_is(TokenType.keyword_try))
          cur_statement_list.add( parse_try_statement )
          return

        elseIf (next_is(TokenType.keyword_use))
          cur_statement_list.add( parse_use_statement )
          return

        elseIf (next_is(TokenType.keyword_local) or next_is(TokenType.keyword_localize))
          parse_local_or_global( &is_local )
          return

        elseIf (is_parsing_metacode and next_is(TokenType.keyword_global))
          parse_local_or_global( &!is_local )
          return

        endIf
        #{
      else
        local err = false
        if (next_is(TokenType.keyword_if)) err = true
        if (err) throw t.error( "Control structures must begin on a separate line." )
      }#
      endIf

      if (consume(TokenType.keyword_return))
        if (next_is_end_command)
          cur_statement_list.add( CmdReturn(t) )
        else
          #if (not this_method.return_type)
          #throw peek.error( "$()() is not declared as returning a value." (this_method.name) )
          #endIf
          cur_statement_list.add( CmdReturn(t,parse_expression) )
        endIf
        return

      elseIf (consume(TokenType.keyword_await))
        # Insert a local result declaration and a statement list to hold the
        # await cmd and subsequent conversion.  Substitute the result var in
        # place of this statement.
        #
        #   await some_task(a,b)
        #
        # ->
        #
        #   {
        #     task = some_task(a,b)
        #     while (task.update) yield
        #   }
        #
        local statement_list = CmdStatementList()
        cur_statement_list.add( CmdAwait(t,parse_expression,statement_list) )
        return

      elseIf (consume(TokenType.keyword_yield))
        local result : Cmd
        if (not next_is_end_command)
          result = parse_expression
        endIf

        cur_statement_list.add( CmdYield(t,result) )
        return

      elseIf (consume(TokenType.keyword_throw))
        cur_statement_list.add( CmdThrow(t,parse_expression) )
        return

      elseIf (consume(TokenType.keyword_noAction))
        noAction
        return

      elseIf (consume(TokenType.keyword_trace) or consume(TokenType.keyword_trace_args_only))
        local exclude_position = (t.type is TokenType.keyword_trace_args_only)

        local buffer = StringBuilder()
        buffer.print('[').print( this_type.name )
        if (this_method) buffer.print( "." ).print( this_method.name ).print( "() " )
        buffer.print( File(t.filepath).filename )
        buffer.print( ':' ).print( t.line ).print( ']' )

        local data_pos = buffer.count + 2
        local args = CmdArgs()
        local needs_space = false
        local first = true
        while (reader.has_another and not next_is_end_command and (first or consume(TokenType.symbol_comma)))
          if (first)
            if (exclude_position)
              buffer.clear
            else
              buffer.print( "  " )
            endIf
          endIf
          first = false
          local start_t = peek
          local expr = parse_expression
          if (expr instanceOf CmdLiteralString)
            buffer.print((expr->(as CmdLiteralString)).value )
            needs_space = false
          else
            if (needs_space) buffer.print(' ')
            local end_t = peek

            local parse_reader = RogueC.scanners_by_filepath[ start_t.filepath ]
            if (parse_reader and start_t.line and start_t.column and start_t.filepath == end_t.filepath)
              parse_reader.seek_location( start_t.line, start_t.column )
              while (parse_reader.has_another and (parse_reader.line < end_t.line or ...
                     (parse_reader.line == end_t.line and parse_reader.column < end_t.column)))
                local ch = parse_reader.read
                if (ch=='$')
                  # Have to handle any existing dollar signs by replacing them with additional args
                  # that are also dollar signs.
                  args.add( CmdLiteralString(t,"$") )
                endIf
                buffer.print( ch )
              endWhile
              buffer.print( ":$" )
              args.add( expr )
              needs_space = true
            endIf
          endIf

        endWhile

        if (not exclude_position and args.count)
          buffer.insert_spaces( data_pos, ((data_pos+3)&!3)-data_pos )
        endIf

        if (reader.has_another and not next_is_end_command)
          throw peek.error( "A comma-separated list of values is expected." )
        endIf

        cur_statement_list.add( CmdTrace( t, CmdFormattedString(t,buffer->String,args) ) )
        return

      elseIf (consume(TokenType.keyword_assert))
        consume_eols
        local has_parens = consume( TokenType.symbol_open_paren )

        local start_t = peek
        local expr = parse_expression
        local message : Cmd
        if (consume(TokenType.symbol_double_vertical_bar)) message = parse_expression
        local end_t = peek

        if (has_parens) must_consume( TokenType.symbol_close_paren )

        if (not RogueC.debug_mode) return

        if (not message)
          local buffer = StringBuilder()
          local parse_reader = RogueC.scanners_by_filepath[ start_t.filepath ]
          if (parse_reader and start_t.line and start_t.column and start_t.filepath == end_t.filepath)
            parse_reader.seek_location( start_t.line, start_t.column )
            while (parse_reader.has_another and (parse_reader.line < end_t.line or ...
                   (parse_reader.line == end_t.line and parse_reader.column < end_t.column)))
              buffer.print( parse_reader.read )
            endWhile
          endIf
          message = CmdLiteralString( t, buffer->String )
        endIf

        local temp_var = Local( t, Program.create_unique_id )
        temp_var.type = Program.type_Int32  # temporary placeholder until CmdAssert resolves
        cur_statement_list.add( CmdLocalDeclaration(t,temp_var,&skip_initialization) )
        cur_statement_list.add( CmdAssert(t, expr, message, temp_var) )
        return

      elseIf (next_is(TokenType.keyword_ensure))
        cur_statement_list.add( parse_ensure_statement )
        return

        #{
      elseIf (consume(TokenType.keyword_tron))
        cur_statement_list.add( CmdTron(t) )
        return

      elseIf (consume(TokenType.keyword_troff))
        cur_statement_list.add( CmdTroff(t) )
        return
      }#

      endIf

      if (consume(TokenType.symbol_lt))
        if (parsing_augment)
          if (this_method.is_macro)
            throw t.error( "Macro methods cannot have augment section labels." )
          else
            throw t.error( "Augment section labels should be defined in the outer scope of the method and cannot be nested inside a control structure." )
          endIf
        else
          cur_statement_list.add( this_method.begin_label(t,read_identifier,false) )
        endIf
        must_consume( TokenType.symbol_gt )
        return
      endIf

      if (consume(TokenType.keyword_escapeWhile))
        cur_statement_list.add( CmdEscape(t,CmdControlStructure.type_while) )
        return

      elseIf (consume(TokenType.keyword_escapeForEach))
        cur_statement_list.add( CmdEscape(t,CmdControlStructure.type_forEach) )
        return

      elseIf (consume(TokenType.keyword_escapeBlock))
        cur_statement_list.add( CmdEscape(t,CmdControlStructure.type_block) )
        return

      elseIf (consume(TokenType.keyword_escapeContingent))
        cur_statement_list.add( CmdEscape(t,CmdControlStructure.type_contingent) )
        return

      elseIf (consume(TokenType.keyword_escapeLoop))
        cur_statement_list.add( CmdEscape(t,CmdControlStructure.type_loop) )
        return

      elseIf (consume(TokenType.keyword_escapeTemporarily))
        cur_statement_list.add( CmdEscape(t,CmdControlStructure.type_temporarily) )
        return

      elseIf (consume(TokenType.keyword_escapeIf))
        cur_statement_list.add( CmdEscape(t,CmdControlStructure.type_if) )
        return

      elseIf (consume(TokenType.keyword_escapeTry))
        cur_statement_list.add( CmdEscape(t,CmdControlStructure.type_try) )
        return

      elseIf (consume(TokenType.keyword_escapeUse))
        cur_statement_list.add( CmdEscape(t,CmdControlStructure.type_use) )
        return

      elseIf (consume(TokenType.keyword_escapeWhich))
        cur_statement_list.add( CmdEscape(t,CmdControlStructure.type_which) )
        return
      endIf

      if (consume(TokenType.keyword_nextIteration))
        cur_statement_list.add( CmdNextIteration(t) )
        return
      endIf

      if (consume(TokenType.keyword_necessary))
        cur_statement_list.add( CmdNecessary(t, parse_expression))
        return
      endIf

      if (consume(TokenType.keyword_sufficient))
        cur_statement_list.add( CmdSufficient(t, parse_expression))
        return
      endIf

      if (consume(TokenType.symbol_change_state))
        cur_statement_list.add( CmdChangeState(t, parse_expression) )
        must_consume( TokenType.symbol_close_bracket )
        return
      endIf

      if (consume(TokenType.keyword_swapValues))
        consume_eols
        local has_parens = consume( TokenType.symbol_open_paren )
        consume_eols
        local a = parse_expression
        consume_eols
        must_consume( TokenType.symbol_comma )
        consume_eols
        local b = parse_expression
        consume_eols
        if (has_parens) must_consume( TokenType.symbol_close_paren )
        local v = Local( t, Program.create_unique_id, null, a )
        cur_statement_list.add( CmdLocalDeclaration(t,v,a) )
        cur_statement_list.add( CmdAssign(t,a.cloned,b) )
        cur_statement_list.add( CmdAssign(t,b.cloned,CmdAccess(t,v.name)) )
        return
      endIf

      if (consume(TokenType.symbol_plus_plus))
        cur_statement_list.add( CmdStep(t, parse_expression,1) )
        return
      endIf

      if (consume(TokenType.symbol_minus_minus))
        cur_statement_list.add( CmdStep(t, parse_expression,-1) )
        return
      endIf

      consume_eols

      local println_pos : Int32
      local println_statement_count = cur_statement_list.count
      local implicit_loop_stack_count = implicit_loop_stack.count
      local cmd_println : CmdPrintln
      if (next_is_identifier("println") or next_is_identifier("print"))
        if (reader.peek(1).type is TokenType.symbol_open_paren)
          # Prepare to parse the print/println two different ways to allow a special syntax exception.
          #
          #   println (a+b)/c
          #
          # is parsed as both:
          #
          #   1.  println( (a + b) ) / c   # technically correct but probably unintended
          #   2.  println( (a + b) / c )   # probably what developer intended
          #
          # Furthermore, if Method 2 ends up being used then it accepts a comma-separated or space-separated set of
          # terms to print out, ending at the first ';' or EOL.
          #
          # If an implicit loop is parsed using Method 1 then we stop and use Method 1; otherwise a second
          # implicit loop would be generated when Method 2 is used. 'implicit_loop_stack_count' is used to check this.
          ensure cmd_println( peek )
          println_pos = reader.position

        else
          # print/println followed by no-parens comma-separated or space-separated args
          local is_println = next_is_identifier("println")
          block t = read
            if (next_is_end_command)
              cur_statement_list.add( CmdAccess(t,t->String) )
              return
            endIf
            local cmd = CmdAccess(t,"print",parse_expression) : Cmd
            while (not next_is_end_command and not peek.is_structure)
              consume( TokenType.symbol_comma )  # Commas are optional
              local expr = parse_expression
              cmd = CmdAccess( expr.t, cmd, "print", expr )
            endWhile
            if (is_println) cmd = CmdAccess( cmd.t, cmd, "println" )
            cur_statement_list.add( cmd )
            return
          endBlock
        endIf
      endIf

      local expression = parse_expression

      expression = parse_statement_with_context( expression )

      if (cmd_println and println_statement_count == cur_statement_list.count and implicit_loop_stack_count == implicit_loop_stack.count)
        # Try an alternate variation of print/println as long as no new commands, locals,
        # or implicit loops have been added to the statement list as a side-effect of
        # parsing other commands.
        local final_pos = reader.position
        cmd_println.standard = expression
        reader.position = println_pos
        t = read
        local access = CmdAccess( t, t->String, CmdArgs() )
        try
          while (not next_is_end_command and not peek.is_structure) access.args.add( parse_expression )
          cmd_println.no_parens = access
          if (reader.position == final_pos)
            # Looking for an alternate interpretation of the same parse tree and only proceed
            # if the two parsing approaches consume the same tokens.
            expression = cmd_println
          endIf
        catch ( its_not_working:RogueError )
        endTry
        reader.position = final_pos
      endIf

      cur_statement_list.add( expression )


    method parse_statement_with_context( expression:Cmd )->Cmd
      local t = peek
      if (consume(TokenType.symbol_equals))
        return CmdAssign( t,expression,parse_expression )
      endIf

      if (consume(TokenType.symbol_dot_equals))
        return CmdAssign( t, expression, parse_access(t,expression.cloned) )
      endIf

      if (t.type.is_op_with_assign)
        read
        return CmdModifyAndAssign( t, expression, t.type, parse_expression )
      endIf

      if (consume(TokenType.symbol_plus_plus))
        return CmdStep( t, expression, 1 )
      endIf

      if (consume(TokenType.symbol_minus_minus))
        return CmdStep( t, expression,-1 )
      endIf

      local t_type = t.type
      if (t_type.is_op_with_assign)
        read
        local target = expression
        local new_value = parse_expression
        return CmdModifyAndAssign( t, target, t_type, new_value )
      endIf

      # No-parens args can follow an initial expression
      if (not next_is_end_command and next_is_statement)
        local access = expression->(as CmdAccess)
        if (access and access.args is null)
          local args = CmdArgs()
          while (not next_is_end_command and not peek.is_structure)
            args.add( parse_expression )
          endWhile
          access.args = args
        endIf
      endIf

      return expression

    method parse_which->Cmd
      local t = read  # 'which'

      local expression : Cmd
      consume_eols

      if (next_is(TokenType.symbol_open_brace))
        return parse_select( t, expression )
      endIf

      expression = parse_expression

      if (next_is(TokenType.symbol_open_brace))
        return parse_select( t, expression )
      endIf

      must_consume_eols

      local cmd_which = CmdWhich( t, expression )
      while (next_is(TokenType.keyword_case) or next_is(TokenType.keyword_caseNext))
        t = read  # 'case' | 'caseNext'
        consume_eols
        local cmd_case = cmd_which.add_case( t )
        if (t.type is TokenType.keyword_case)
          local first = true
          while (first or consume(TokenType.symbol_comma))
            first = false
            cmd_case.conditions.add( parse_expression )
            consume_eols
          endWhile
        else
          cmd_case.is_case_next = true
        endIf
        if (consume(TokenType.symbol_colon)) consume_eols
        parse_multi_line_statements( cmd_case.statements )
      endWhile

      if (next_is(TokenType.keyword_others))
        t = read  # 'others'
        consume_eols
        local cmd_case = cmd_which.add_case_others( t )
        if (consume(TokenType.symbol_colon)) consume_eols
        parse_multi_line_statements( cmd_case.statements )
      endIf

      must_consume( TokenType.keyword_endWhich )
      return cmd_which

    method parse_dependency->Logical
      if (parse_unit_test) return true

      consume_eols

      local t_type = peek.type

      if ((t_type is TokenType.keyword_nativeHeader) or
          (t_type is TokenType.keyword_nativeCode) or
          (t_type is TokenType.keyword_nativeLibrary) or
          (t_type is TokenType.keyword_includeNativeCode) or
          (t_type is TokenType.keyword_includeNativeHeader) or
          (t_type is TokenType.keyword_compileArg) or
          (t_type is TokenType.keyword_includeNativeHeader) or
          (t_type is TokenType.keyword_includeSource) or
          (t_type is TokenType.keyword_includeSourceFolder) or
          (t_type is TokenType.meta_essential))
        ensure this_type.dependencies
        parse_statement( this_type.dependencies, false )
        return true

      else
        return false
      endIf

    method parse_deprecated->String
      consume_eols
      if (not consume(TokenType.keyword_deprecated)) return null
      if (not next_is(TokenType.literal_string)) return ""
      return read->String

    method parse_unit_test->Logical
      consume_eols

      local t = peek
      if (not consume(TokenType.keyword_unitTest)) return false

      local is_multi_line = consume_eols

      local original_type = this_type
      local original_method = this_method
      this_type = Program.get_type_reference( peek, "Global" )
      this_method = Program.get_run_tests_method( t )

      local cmd_block = CmdBlock( t )
      if (is_multi_line)
        parse_multi_line_statements( cmd_block.statements )
        must_consume( TokenType.keyword_endUnitTest )
      else
        parse_single_line_statements( cmd_block.statements )
      endIf
      if (RogueC.run_tests) this_method.statements.add( cmd_block )

      this_type = original_type
      this_method = original_method
      return true

    method parse_native_element->Logical
      consume_eols
      local t = peek

      if (consume(TokenType.keyword_nativeHeader))
        Program.native_header.add( t->String )
        return true

      elseIf (consume(TokenType.keyword_nativeCode))
        Program.native_code.add( t->String )
        return true

      elseIf (consume(TokenType.keyword_nativeLibrary))
        if (not next_is(TokenType.literal_string))
          throw peek.error( "String specifying native library expected." )
        endIf
        RogueC.native_libraries.add( read->String )
        return true

      elseIf (consume(TokenType.keyword_includeNativeCode))
        if (not next_is(TokenType.literal_string))
          throw peek.error( "Filepath expected." )
        endIf
        local filepath = read->String
        RogueC.include_native( t, filepath, "code", consume_optional )
        return true

      elseIf (consume(TokenType.keyword_includeNativeHeader))
        if (not next_is(TokenType.literal_string))
          throw peek.error( "Filepath expected." )
        endIf
        local filepath = read->String
        RogueC.include_native( t, filepath, "header", consume_optional )
        return true

      elseIf (consume(TokenType.keyword_includeSource))
        if (not next_is(TokenType.literal_string))
          throw peek.error( "Filepath expected." )
        endIf
        local filepath = read->String
        if (RogueC.include_source(t, filepath, consume_optional))
          RogueC.parse_pending_files
        endIf
        return true

      elseIf (consume(TokenType.keyword_includeSourceFolder))
        if (not next_is(TokenType.literal_string))
          throw peek.error( "Folder path expected." )
        endIf
        local filepath = read->String
        if (RogueC.include_source(t, filepath, consume_optional,&including_folder))
          RogueC.parse_pending_files
        endIf
        return true

      elseIf (consume(TokenType.keyword_compileArg))
        if (not next_is(TokenType.literal_string))
          throw peek.error( "Literal string expected (e.g. \"-pthread\")." )
        endIf
        RogueC.compiler_options.add( read->String )
        return true

      elseIf (consume(TokenType.meta_essential))
        local pattern = t->String
        Program.get_on_launch_method( t ).statements.add( CmdMakeRequisite(t,pattern) )
        return true

      else
        return false
      endIf

    method parse_contingent->CmdContingent
      local t = read  # 'contingent'
      local cmd_contingent = CmdContingent( t )
      parse_multi_line_statements( cmd_contingent.statements )

      if (consume(TokenType.keyword_satisfied))
        cmd_contingent.satisfied_statements = CmdStatementList()
        parse_multi_line_statements( cmd_contingent.satisfied_statements )
      endIf

      if (consume(TokenType.keyword_unsatisfied))
        cmd_contingent.unsatisfied_statements = CmdStatementList()
        parse_multi_line_statements( cmd_contingent.unsatisfied_statements )
      endIf

      must_consume( TokenType.keyword_endContingent )
      return cmd_contingent

    method parse_try_statement->CmdTry
      local t = read  # 'try'
      local cmd_try = CmdTry( t )
      if (consume_eols)
        # try
        #   multi-line commands
        # catch ([var_name:]ExceptionType)
        #   multi-line commands
        # [catch ...]*
        # endTry
        parse_multi_line_statements( cmd_try.statements )
        while (next_is(TokenType.keyword_catch))
          local cmd_catch = cmd_try.add_catch( read )
          consume_eols
          must_consume( TokenType.symbol_open_paren )
          local error_t = peek
          local error_name = parse_type_name
          consume_eols
          if (consume(TokenType.symbol_colon))
            cmd_catch.error_var = Local( error_t, error_name, parse_type )
            consume_eols
          else
            cmd_catch.error_type = Program.get_type_reference( t, error_name )
          endIf
          consume_eols
          must_consume( TokenType.symbol_close_paren )
          parse_multi_line_statements( cmd_catch.statements )
        endWhile
        must_consume( TokenType.keyword_endTry )

      else
        # try single; line; commands
        parse_single_line_statements( cmd_try.statements )
        local cmd_catch = cmd_try.add_catch( t )
        cmd_catch.error_type = Program.type_Exception
      endIf

      return cmd_try

    method parse_use_statement->CmdUse
      #   use v = expr
      #      ...
      #   endUse
      local t = read  # 'use'
      local result    : CmdUse
      local innermost : CmdUse

      local first = true
      while (first or consume(TokenType.symbol_comma))
        first = false
        consume_eols

        local expr = parse_expression
        local access = expr->(as CmdAccess)
        local v_name : String
        if (consume(TokenType.symbol_equals))
          if (access is null or access.context or access.args)
            throw expr.t.error( "Variable name expected." )
          else
            v_name = access.name
            expr = parse_expression
          endIf
        else
          v_name = Program.create_unique_id
        endIf

        local cmd_use = CmdUse( t, v_name, expr )
        if (innermost)
          innermost.statements.add( cmd_use )
          innermost = cmd_use
        else
          result = cmd_use
          innermost = cmd_use
        endIf
      endWhile

      must_consume_eols

      parse_multi_line_statements( innermost.statements )

      must_consume( TokenType.keyword_endUse )
      return result

    method parse_try_expression->Cmd
      # try expression else expression
      local t = read  # 'try'
      local try_expression = parse_expression
      must_consume( TokenType.keyword_else )
      local else_expression = parse_expression

      # type_Object here is a placeholder to prevent an error message
      local result_var = Local( t, Program.create_unique_id, Program.type_Object )
      cur_statement_list.add( CmdLocalDeclaration(t,result_var) )
      cur_statement_list.add( CmdTryExpression(t, try_expression, else_expression, result_var) )
      return CmdReadLocal( t, result_var )

    method parse_local_or_global( &is_local )
      local_declarations.clear
      local t = read   # one of: local, global, localize

      local is_localize = t.type is TokenType.keyword_localize

      if (is_localize)
        local first = true
        while (first or consume(TokenType.symbol_comma))
          first = false
          t = peek
          local name = peek_identifier
          local v = Local( t, name )
          local_declarations.add( v )

          # id(...) -> this.id(...)
          #reader.push( TokenType.symbol_dot.create_token(t) )
          #reader.push( TokenType.keyword_this.create_token(t) )
          # ^ This doesn't seem necessary plus it prevents global
          #   routines from being localized.

          v.initial_value = parse_expression
        endWhile

      else
        # Destructuring/tuple assignment
        if (not is_localize and next_is(TokenType.symbol_open_paren))
          local expression = parse_expression
          if ((expression->(as CmdTuple)) is null)
            throw expression.t.error("Expected tuple of variables for destructuring assignment.")
          endIf
          (expression->(as CmdTuple)).synthesize_variables = true
          must_consume(TokenType.symbol_equals)
          t = peek
          cur_statement_list.add( CmdAssign(t,expression,parse_expression) )
          return
        endIf

        # name[=initial_value] [, ...]
        local first = true
        while (first or consume(TokenType.symbol_comma))
          first = false
          t = peek
          local name = read_identifier
          local v = Local( t, name )
          local_declarations.add( v )
          if (consume(TokenType.symbol_equals))
            v.initial_value = parse_expression
          endIf
          if (not is_local and next_is(TokenType.symbol_comma))
            throw peek.error( "Only one global variable can be declared at a time. Use multiple 'global' commands as needed." )
          endIf
        endWhile
      endIf

      # [: Type]
      if (consume(TokenType.symbol_colon))
        local type = parse_type
        forEach (v in local_declarations) v.type = type
      else
        forEach (v in local_declarations)
          if (v.type is null and v.initial_value)
            v.type = v.initial_value.implicit_type( Scope(this_type,null) )
          endIf
        endForEach
      endIf

      # Turn each declaration into a separate CmdLocalDeclaration
      if (is_local)
        # locals
        forEach (v in local_declarations)
          cur_statement_list.add( CmdLocalDeclaration(v.t,v) )
        endForEach
      elseIf (is_parsing_metacode)
        forEach (v in local_declarations)
          cur_statement_list.add( CmdMetacodeGlobalDeclaration(v.t,v) )
        endForEach
      else
        # global properties
        forEach (v in local_declarations)
          if (v.type is null)
            if (v.initial_value)
              throw v.t.error( ''Cannot determine global variable type from initial value; append an explicit type declaration such as ": Int32" '' )
            else
              throw v.t.error( ''An initial value or global variable type (for example, ": Int32") must be specified.'' )
            endIf
          else
            if (not v.initial_value)
              v.initial_value = v.type.create_default_value( v.t )
            endIf
          endIf
          cur_statement_list.add( CmdAssign( v.t, CmdAccess(v.t,"Global",v.name), v.initial_value ) )
          v.initial_value = null
          Program.add_global_var( Property(v.t,Program.type_Global,v.name,v.type) )
        endForEach
      endIf

    method parse_type->Type
      local t = peek
      return Program.get_type_reference( t, parse_type_name )

    method parse_type_name( allow_at_sign=false:Logical )->String
      local t = peek
      local name : String

      if (consume(TokenType.symbol_open_paren))
        # Allow parens around everything before '?' and '[]'; necessary to be able to
        # disambiguate template methods that return optional function types and function
        # type lists.  For example, in Template<<$X>> with a method m->$X?, if $X is
        # Function()->Logical, then $X? reads->(as Function())->(Logical?) when you may
        # want Function()->(Logical)?.  We can write ->($X)? as an alternative.

        if (consume("Function"))   # (Function...
          local parameter_types : Type[]
          local return_type : Type
          if (consume(TokenType.symbol_open_paren))
            if (not consume(TokenType.symbol_close_paren))
              parameter_types = Type[]
              local first = true
              while (first or consume(TokenType.symbol_comma))
                first = false
                local type_t = peek
                local type_name = parse_type_name
                if (consume(TokenType.symbol_colon))
                  # Discard the name of the callback parameter
                  parameter_types.add( parse_type )
                else
                  parameter_types.add( Program.get_type_reference(type_t,type_name) )
                endIf
              endWhile
              must_consume( TokenType.symbol_close_paren )
            endIf
          endIf

          if (consume(TokenType.symbol_arrow))
            consume_eols
            local has_parens = consume( TokenType.symbol_open_paren )
            consume_eols
            return_type = parse_type
            consume_eols
            if (has_parens) must_consume( TokenType.symbol_close_paren )
          endIf

          must_consume( TokenType.symbol_close_paren )

          name = Program.get_callback_type_reference( t, parameter_types, return_type ).name

        else
          # Tuple
          name = parse_type_name
          if (next_is(TokenType.symbol_comma))
            while (next_is(TokenType.symbol_comma))
              read # comma
              name += "," + parse_type
            endWhile
            name = "Tuple<<$>>" (name)
          endIf
          must_consume( TokenType.symbol_close_paren )
        endIf

      elseIf (consume(TokenType.symbol_at_brace))
        # 'allow_at_sign' refers to allowing direct variable access; regardless of
        # that we still need to check for @{} and @[]
        name = "ValueTable"
        must_consume( TokenType.symbol_close_brace )

      elseIf (consume(TokenType.symbol_at_bracket))
        name = "ValueList"
        must_consume( TokenType.symbol_close_bracket )

      else
        name = read_identifier( allow_at_sign )

        if (name == "operator")
          name += reader.read->String  # add on next token
        endIf

        if (next_is(TokenType.symbol_open_specialize))
          name += parse_specialization_string

        elseIf (name == "Function")
          local parameter_types : Type[]
          local return_type : Type
          if (consume(TokenType.symbol_open_paren))
            if (not consume(TokenType.symbol_close_paren))
              parameter_types = Type[]
              local first = true
              while (first or consume(TokenType.symbol_comma))
                first = false
                local type_t = peek
                local type_name = parse_type_name
                if (consume(TokenType.symbol_colon))
                  # Discard the name of the callback parameter
                  parameter_types.add( parse_type )
                else
                  parameter_types.add( Program.get_type_reference(type_t,type_name) )
                endIf
              endWhile
              must_consume( TokenType.symbol_close_paren )
            endIf
          endIf

          if (consume(TokenType.symbol_arrow))
            consume_eols
            local has_parens = consume( TokenType.symbol_open_paren )
            if (has_parens) consume_eols
            return_type = parse_type
            if (has_parens)
              consume_eols
              must_consume( TokenType.symbol_close_paren )
              print_old_style_function_warning( t )
            endIf
          endIf

          name = Program.get_callback_type_reference( t, parameter_types, return_type ).name
        endIf
      endIf

      loop
        if (consume(TokenType.symbol_empty_brackets))
          name += "[]"
        elseIf (consume(TokenType.symbol_question_mark))
          name += "?"
        else
          escapeLoop
        endIf
      endLoop

      return name

    method parse_if->CmdIf
      local t = read
      local cmd_if = CmdIf( t )

      cmd_if.condition = parse_expression( &no_parens_operator )

      consume( "then" )

      if (consume_eols)
        # multi-line if
        parse_multi_line_statements( cmd_if.statements )

        t = peek
        local cur_if = cmd_if
        while (next_is(TokenType.keyword_elseIf))
          # Need logic to avoid dangling elseIf problems.
          local starting_position = reader.position
          read  # 'elseIf'

          local elseIf_condition = parse_expression

          if (consume(TokenType.eol))
            # This elseIf IS part of the current multiline 'if'
            local cmd_else_if = CmdIf( t, elseIf_condition, CmdControlStructure.type_else_if  )
            parse_multi_line_statements( cmd_else_if.statements )
            cur_if.else_statements = CmdStatementList()
            cur_if.else_statements.add( cmd_else_if )
            cur_if = cmd_else_if
          else
            # This elseIf actually belongs to something else; undo and abort
            reader.position = starting_position
            escapeWhile
          endIf
          t = peek
        endWhile

        if (next_is(TokenType.keyword_else) and reader.peek(1).type is TokenType.eol)
          read
          cur_if.else_statements = CmdStatementList()
          parse_multi_line_statements( cur_if.else_statements )
        endIf

        must_consume( TokenType.keyword_endIf )

      else
        # single-line if
        parse_single_line_statements( cmd_if.statements )
        consume_eols

        t = peek
        local cur_if = cmd_if
        while (next_is(TokenType.keyword_elseIf))
          # Need logic to avoid dangling elseIf problems.
          local starting_position = reader.position
          read  # 'elseIf'

          local elseIf_condition = parse_expression

          if (next_is(TokenType.eol))
            # This elseIf belongs to another if statement - undo and abort
            reader.position = starting_position
            escapeWhile
          else
            local cmd_else_if = CmdIf( t, elseIf_condition, CmdControlStructure.type_else_if )
            parse_single_line_statements( cmd_else_if.statements )
            cur_if.else_statements = CmdStatementList()
            cur_if.else_statements.add( cmd_else_if )
            cur_if = cmd_else_if
            must_consume_eols
          endIf
          t = peek
        endWhile

        if (next_is(TokenType.keyword_else) and reader.peek(1).type is not TokenType.eol)
          read
          cur_if.else_statements = CmdStatementList()
          parse_single_line_statements( cur_if.else_statements )
        endIf
      endIf

      return cmd_if

    method parse_loop->CmdGenericLoop
      local t = read  # 'loop'
      local cmd_loop = CmdGenericLoop( t, CmdControlStructure.type_loop, null )

      if (consume(TokenType.keyword_do))
        if (consume_eols)
          parse_multi_line_statements( cmd_loop.statements )
          must_consume( TokenType.keyword_endLoop )
        else
          parse_single_line_statements( cmd_loop.statements )
        endIf
        return cmd_loop
      endIf

      if (not consume_eols)
        # loop N
        #   ...
        # endLoop
        local control_var = Local( t, Program.create_unique_id )
        control_var.initial_value = CmdLiteralInt32( t, 1 )

        local last_var = Local( t, Program.create_unique_id )
        last_var.initial_value = parse_expression( &no_parens_operator )

        local step_cmd = CmdStepLocal( t, control_var, 1 )

        cmd_loop.condition = CmdCompareLE(t,CmdReadLocal(t,control_var),CmdReadLocal(t,last_var))

        cmd_loop.add_control_var( control_var )
        cmd_loop.add_control_var( last_var )
        cmd_loop.add_upkeep( step_cmd )

        consume(TokenType.keyword_do)
        if (not consume_eols)
          parse_single_line_statements( cmd_loop.statements )
          return cmd_loop
        endIf
      endIf

      parse_multi_line_statements( cmd_loop.statements )
      must_consume( TokenType.keyword_endLoop )

      return cmd_loop

    method parse_block->Cmd
      # block
      #   ...
      # endBlock
      #
      # block x [, y=a, ...]
      #   ...
      # endBlock
      local t = read  # 'block'

      if (next_is_end_command)
        local cmd_block = CmdBlock( t )

        must_consume_eols
        parse_multi_line_statements( cmd_block.statements )
        must_consume( TokenType.keyword_endBlock )

        return cmd_block
      else
        local result    : CmdBlockWithLocal
        local innermost : CmdBlockWithLocal

        local first = true
        while (first or consume(TokenType.symbol_comma))
          first = false
          consume_eols

          local var_name = read_identifier
          local expr : Cmd
          if (consume(TokenType.symbol_equals))
            expr = parse_expression
          endIf

          local cmd_block = CmdBlockWithLocal( t, var_name, expr )
          if (innermost)
            innermost.statements.add( cmd_block )
            innermost = cmd_block
          else
            result = cmd_block
            innermost = cmd_block
          endIf
        endWhile

        must_consume_eols
        parse_multi_line_statements( innermost.statements )
        must_consume( TokenType.keyword_endBlock )
        return result
      endIf

    method parse_temporarily->Cmd
      # temporarily x=a [, y=b, ...]
      #   ...
      # endTemporarily
      local t = read  # 'block'

      local result    : CmdTemporarily
      local innermost : CmdTemporarily

      local first = true
      while (first or consume(TokenType.symbol_comma))
        first = false
        consume_eols

        local target = parse_expression
        must_consume( TokenType.symbol_equals )
        local temp_value = parse_expression

        local cmd_block = CmdTemporarily( t, target, temp_value )
        if (innermost)
          innermost.statements.add( cmd_block )
          innermost = cmd_block
        else
          result = cmd_block
          innermost = cmd_block
        endIf
      endWhile

      must_consume_eols
      parse_multi_line_statements( innermost.statements )
      must_consume( TokenType.keyword_endTemporarily )
      return result

    method parse_while->CmdGenericLoop
      local t = read
      local cmd_while = CmdGenericLoop( t, CmdControlStructure.type_while, parse_expression(&no_parens_operator) )

      consume(TokenType.keyword_do)

      if (consume_eols)
        # multi-line while
        parse_multi_line_statements( cmd_while.statements )
        must_consume( TokenType.keyword_endWhile )
      else
        # single-line while
        parse_single_line_statements( cmd_while.statements )
        consume_eols
      endIf

      return cmd_while

    method parse_for_each->Cmd
      local t = read  # 'forEach'

      local has_parens = consume( TokenType.symbol_open_paren )

      local expr = parse_expression
      local access = expr->(as CmdAccess)
      local access_tuple = expr->(as CmdTuple)
      if (access or access_tuple)
        if (access and (access.context or access.args))
          throw access.t.error( "Single identifier expected for control variable name." )
        else
          local index_var_name : String
          if (access and access.name == "at")
            # forEach (at index in list) - variant of forEach (value at index in list)
            throw access.t.error( "Missing element name before 'at'." )
          elseIf (consume("at"))
            index_var_name = read_identifier
          endIf

          local collection_var_name : String
          if (consume(TokenType.keyword_in))
            local collection = parse_expression
            if (consume(TokenType.symbol_equals))
              contingent
                local var_name = collection->(as CmdAccess)
                necessary (var_name)
                necessary (var_name.context is null)
                necessary (var_name.args is null)
                collection_var_name = var_name.name
                collection = parse_expression
              unsatisfied
                throw collection.t.error( "Variable name expected before '='." )
              endContingent
            endIf

            local range = collection->(as CmdRange)
            if (range)
              if (index_var_name ) throw range.t.error( "Cannot use 'at' with a range." )
              if (not access) throw range.t.error( "Cannot use 'at' with destructuring." )

              local cmd_for_each = create_generic_loop_from_range( t, access.name, range )

              if (has_parens) must_consume( TokenType.symbol_close_paren )
              consume(TokenType.keyword_do)
              parse_single_or_multi_line_statements( cmd_for_each.statements, TokenType.keyword_endForEach )

              return cmd_for_each

            else
              local first_cmd, last_cmd, step_cmd : Cmd

              if (consume("from"))
                local from_cmd = parse_expression
                local from_range = from_cmd->(as CmdRange)
                if (from_range)
                  if (from_range instanceOf CmdRangeUpToLessThan)
                    throw from_range.t.error( "'..<' isn't supported here - use '..' instead." )
                  endIf
                  first_cmd = from_range.first
                  last_cmd = from_range.last
                  step_cmd = from_range.step_cmd
                else
                  first_cmd = from_cmd
                endIf
              endIf

              if (not step_cmd and consume(TokenType.keyword_step))
                step_cmd = parse_expression
              endIf

              if (has_parens) must_consume( TokenType.symbol_close_paren )
              consume(TokenType.keyword_do)

              local cmd_for_each : CmdForEach
              if (access)
                cmd_for_each = CmdForEach( t, access.name, index_var_name, collection, step_cmd )
              else
                cmd_for_each = CmdForEach( t, access_tuple, index_var_name, collection, step_cmd )
              endIf
              cmd_for_each.first_cmd = first_cmd
              cmd_for_each.last_cmd = last_cmd
              cmd_for_each.collection_var_name = collection_var_name
              parse_single_or_multi_line_statements( cmd_for_each.statements, TokenType.keyword_endForEach )
              return cmd_for_each
            endIf

          elseIf (consume(TokenType.keyword_of))
            if (index_var_name ) throw t.error( "Cannot use 'at' with forEach-of." )
            local collection = parse_expression
            if (consume(TokenType.symbol_equals))
              contingent
                local var_name = collection->(as CmdAccess)
                necessary (var_name)
                necessary (var_name.context is null)
                necessary (var_name.args is null)
                collection_var_name = var_name.name
                collection = parse_expression
              unsatisfied
                throw collection.t.error( "Variable name expected before '='." )
              endContingent
            endIf

            local range = collection->(as CmdRange)
            if (range)
              throw t.error( "Use forEach-in with a literal range instead of forEach-of." )
            else
              local first_cmd, last_cmd, step_cmd : Cmd

              if (consume("from"))
                local from_cmd = parse_expression
                local from_range = from_cmd->(as CmdRange)
                if (from_range)
                  first_cmd = from_range.first
                  last_cmd = from_range.last
                  step_cmd = from_range.step_cmd
                else
                  first_cmd = from_cmd
                endIf
              endIf

              if (not step_cmd and consume(TokenType.keyword_step))
                step_cmd = parse_expression
              endIf

              if (has_parens) must_consume( TokenType.symbol_close_paren )
              consume(TokenType.keyword_do)

              local cmd_for_each = CmdForEach(t, null->(as String), access.name, collection, step_cmd, &is_foreach_of)
              cmd_for_each.first_cmd = first_cmd
              cmd_for_each.last_cmd = last_cmd
              cmd_for_each.collection_var_name = collection_var_name
              parse_single_or_multi_line_statements( cmd_for_each.statements, TokenType.keyword_endForEach )
              return cmd_for_each
            endIf

          else
            throw t.error( "Syntax error in forEach - keyword 'in' or 'of' expected." )
          endIf
        endIf

      else
        # forEach (expr) e.g. forEach (1..n)
        local range = expr->(as CmdRange)
        if (range)
          local cmd_for_each = create_generic_loop_from_range( t, Program.create_unique_id, range )
          if (has_parens) must_consume( TokenType.symbol_close_paren )
          consume(TokenType.keyword_do)
          parse_single_or_multi_line_statements( cmd_for_each.statements, TokenType.keyword_endForEach )

          return cmd_for_each

        else
          throw t.error( "Invalid syntax in forEach." )
        endIf

      endIf

      trace
      throw expr.t.error( "[INTERNAL ERROR]" )

    method create_generic_loop_from_range( t:Token, control_var_name:String, range:CmdRange )->CmdGenericLoop
      local control_var = Local( t, control_var_name )
      control_var.initial_value = range.first

      local last_var = Local( t, Program.create_unique_id )
      last_var.initial_value = range.last

      local step_cmd = null : Cmd
      if (range.step_size)
        step_cmd = CmdModifyAndAssignLocal( range.t, control_var, TokenType.symbol_plus_equals, range.step_size )
      else
        if (range instanceOf CmdRangeUpTo or range instanceOf CmdRangeUpToLessThan)
          step_cmd = CmdStepLocal( range.t, control_var, 1 )
        else
          step_cmd = CmdStepLocal( range.t, control_var, -1 )
        endIf
      endIf

      local compare_cmd : Cmd
      if (range instanceOf CmdRangeUpTo)
        compare_cmd = CmdCompareLE( t, CmdReadLocal(t,control_var), CmdReadLocal(t,last_var) )
      elseIf (range instanceOf CmdRangeUpToLessThan)
        compare_cmd = CmdCompareLT( t, CmdReadLocal(t,control_var), CmdReadLocal(t,last_var) )
      else
        compare_cmd = CmdCompareGE( t, CmdReadLocal(t,control_var), CmdReadLocal(t,last_var) )
      endIf

      local cmd_for_each = CmdGenericLoop( t, CmdControlStructure.type_forEach, compare_cmd )

      cmd_for_each.add_control_var( control_var )
      cmd_for_each.add_control_var( last_var )
      cmd_for_each.add_upkeep( step_cmd )
      return cmd_for_each


    method peek->Token
      return reader.peek

    method read->Token
      return reader.read

    method peek_identifier->String
      if (not next_is(TokenType.identifier))
        if (next_is(TokenType.type_identifier))
          local result = peek->Type.name
          return result
        endIf
        if (peek.type is TokenType.placeholder_id and allow_placeholder_ids)
          # Template tokens are being searched through; allow placeholder ids
          # to act as regular ids for now
          return peek->String
        endIf
        throw error( "Identifier expected, found $." (peek.quoted_name) )
      endIf

      return peek->String

    method read_identifier( allow_at_sign=false:Logical )->String
      local direct_access = false
      if (allow_at_sign) direct_access = consume( TokenType.symbol_at )

      if (not next_is(TokenType.identifier))
        if (next_is(TokenType.type_identifier))
          local result = read->Type.name
          if (direct_access) result = "@" + result
          return result
        endIf
        if (peek.type is TokenType.placeholder_id and allow_placeholder_ids)
          # Template tokens are being searched through; allow placeholder ids
          # to act as regular ids for now
          return read->String
        endIf
        throw error( "Identifier expected, found $." (peek.quoted_name) )
      endIf

      local result = read->String
      if (direct_access) result = "@" + result
      return result

    method parse_expression( &no_parens_operator )->Cmd
      temporarily allow_parens_operator = not no_parens_operator
        consume_eols
        return parse_range
      endTemporarily

    method parse_range->Cmd
      return parse_range( parse_logical_xor )

    method parse_range( lhs:Cmd )->Cmd
      local t = peek
      if (consume(TokenType.symbol_upTo))
        local result = CmdRangeUpTo( t, lhs, parse_logical_xor )
        if (consume(TokenType.keyword_step)) result.step_size = parse_expression
        return result
      elseIf (consume(TokenType.symbol_upToLessThan))
        local result = CmdRangeUpToLessThan( t, lhs, parse_logical_xor )
        if (consume(TokenType.keyword_step)) result.step_size = parse_expression
        return result
        #{
      elseIf (consume(TokenType.symbol_downToGreaterThan))
        return CmdRangeDownToGreaterThan( t, lhs, parse_logical_xor )
        }#
      elseIf (consume(TokenType.keyword_downTo))
        local result = CmdRangeDownTo( t, lhs, parse_logical_xor )
        if (consume(TokenType.keyword_step)) result.step_size = parse_expression
        return result
      else
        return lhs
      endIf

    method parse_logical_xor->Cmd
      return parse_logical_xor( parse_logical_or )

    method parse_logical_xor( lhs:Cmd )->Cmd
      local t = peek
      if (consume(TokenType.keyword_xor))
        consume_eols
        return parse_logical_xor( CmdLogicalXor(t, lhs, parse_logical_or) )
      endIf
      return lhs

    method parse_logical_or->Cmd
      return parse_logical_or( parse_logical_and )

    method parse_logical_or( lhs:Cmd )->Cmd
      local t = peek
      if (consume(TokenType.keyword_or))
        consume_eols
        return parse_logical_or( CmdLogicalOr(t, lhs, parse_logical_and) )
      endIf
      return lhs

    method parse_logical_and->Cmd
      return parse_logical_and( parse_comparison )

    method parse_logical_and( lhs:Cmd )->Cmd
      local t = peek
      if (consume(TokenType.keyword_and))
        consume_eols
        return parse_logical_and( CmdLogicalAnd(t, lhs, parse_comparison) )
      endIf
      return lhs

    method parse_comparison->Cmd
      return parse_comparison( parse_bitwise_xor )

    method parse_comparison( lhs:Cmd )->Cmd
      local t = peek
      if (consume(TokenType.symbol_eq))
        consume_eols
        return parse_comparison( CmdCompareEQ(t, lhs, parse_bitwise_xor) )
      elseIf (consume(TokenType.keyword_is))
        consume_eols
        if (consume(TokenType.keyword_not))
          return parse_comparison( CmdCompareIsNot(t, lhs, parse_bitwise_xor) )
        endIf
        return parse_comparison( CmdCompareIs(t, lhs, parse_bitwise_xor) )
      elseIf (consume(TokenType.symbol_ne))
        consume_eols
        return parse_comparison( CmdCompareNE(t, lhs, parse_bitwise_xor) )
      elseIf (consume(TokenType.symbol_lt))
        consume_eols
        return parse_comparison( CmdCompareLT(t, lhs, parse_bitwise_xor) )
      elseIf (consume(TokenType.symbol_gt))
        consume_eols
        return parse_comparison( CmdCompareGT(t, lhs, parse_bitwise_xor) )
      elseIf (consume(TokenType.symbol_le))
        consume_eols
        return parse_comparison( CmdCompareLE(t, lhs, parse_bitwise_xor) )
      elseIf (consume(TokenType.symbol_ge))
        consume_eols
        return parse_comparison( CmdCompareGE(t, lhs, parse_bitwise_xor) )
      elseIf (consume(TokenType.symbol_compare))
        consume_eols
        return parse_comparison( CmdCompare(t, lhs, parse_bitwise_xor) )
      elseIf (consume(TokenType.keyword_instanceOf))
        consume_eols
        return CmdInstanceOf( t, lhs, parse_type )
      elseIf (consume(TokenType.keyword_isType))
        consume_eols
        return CmdIsType( t, lhs, parse_type )
      elseIf (next_is(TokenType.keyword_not))
        local t2 = reader.peek(1)
        if (t2)
          if (t2.type is TokenType.keyword_instanceOf)
            read
            read
            consume_eols
            return CmdLogicalNot( t, CmdInstanceOf( t, lhs, parse_type ) )
          elseIf (t2.type is TokenType.keyword_isType)
            read
            read
            consume_eols
            return CmdLogicalNot( t, CmdIsType( t, lhs, parse_type ) )
          endIf
        endIf
      endIf
      return lhs

    method parse_bitwise_xor->Cmd
      return parse_bitwise_xor( parse_bitwise_or )

    method parse_bitwise_xor( lhs:Cmd )->Cmd
      local t = peek
      if (consume(TokenType.symbol_tilde))
        consume_eols
        return parse_bitwise_xor( CmdBitwiseXor(t,lhs,parse_bitwise_or) )
      endIf
      return lhs

    method parse_bitwise_or->Cmd
      return parse_bitwise_or( parse_bitwise_and )

    method parse_bitwise_or( lhs:Cmd )->Cmd
      local t = peek
      if (consume(TokenType.symbol_vertical_bar))
        consume_eols
        local rhs = parse_bitwise_and
        return parse_bitwise_or( CmdBitwiseOr(t,lhs,rhs) )
      endIf
      return lhs

    method parse_bitwise_and->Cmd
      return parse_bitwise_and( parse_bitwise_shift )

    method parse_bitwise_and( lhs:Cmd )->Cmd
      local t = peek
      if (consume(TokenType.symbol_ampersand))
        consume_eols
        return parse_bitwise_and( CmdBitwiseAnd(t,lhs,parse_bitwise_shift) )
      endIf
      return lhs

    method parse_bitwise_shift->Cmd
      return parse_bitwise_shift( parse_add_subtract )

    method parse_bitwise_shift( lhs:Cmd )->Cmd
      local t = peek
      if (consume(TokenType.symbol_shift_left))
        consume_eols
        return parse_add_subtract( CmdBitwiseShiftLeft(t,lhs,parse_add_subtract) )
      elseIf (consume(TokenType.symbol_shift_right))
        consume_eols
        return parse_add_subtract( CmdBitwiseShiftRight(t,lhs,parse_add_subtract) )
      elseIf (consume(TokenType.symbol_shift_right_x))
        consume_eols
        return parse_add_subtract( CmdBitwiseShiftRightX(t,lhs,parse_add_subtract) )
      endIf
      return lhs

    method parse_add_subtract->Cmd
      return parse_add_subtract( parse_multiply_divide_mod )

    method parse_add_subtract( lhs:Cmd )->Cmd
      local t = peek
      if (consume(TokenType.symbol_plus))
        consume_eols
        return parse_add_subtract( CmdAdd(t,lhs,parse_multiply_divide_mod) )
      elseIf (consume(TokenType.symbol_minus))
        consume_eols
        return parse_add_subtract( CmdSubtract(t,lhs,parse_multiply_divide_mod) )
      endIf
      return lhs

    method parse_multiply_divide_mod->Cmd
      return parse_multiply_divide_mod( parse_power )

    method parse_multiply_divide_mod( lhs:Cmd )->Cmd
      local t = peek
      if (consume(TokenType.symbol_times))
        consume_eols
        return parse_multiply_divide_mod( CmdMultiply(t,lhs,parse_power) )
      elseIf (consume(TokenType.symbol_slash))
        consume_eols
        return parse_multiply_divide_mod( CmdDivide(t,lhs,parse_power) )
      elseIf (consume(TokenType.symbol_percent))
        consume_eols
        return parse_multiply_divide_mod( CmdMod(t,lhs,parse_power) )
      endIf
      return lhs

    method parse_power->Cmd
      return parse_power( parse_pre_unary )

    method parse_power( lhs:Cmd )->Cmd
      local t = peek
      if (consume(TokenType.symbol_caret))
        consume_eols
        return parse_power( CmdPower(t,lhs,parse_pre_unary) )
      endIf

      return lhs

    method parse_pre_unary->Cmd
      local t = peek

      if (consume(TokenType.symbol_minus))
        consume_eols
        return CmdNegate( t, parse_pre_unary )

      elseIf (consume(TokenType.keyword_not))
        consume_eols
        return CmdLogicalNot( t, parse_pre_unary )

      elseIf (consume(TokenType.symbol_exclamation_point))
        consume_eols
        return CmdBitwiseNot( t, parse_pre_unary )

      elseIf (consume(TokenType.symbol_percent))
      # %value -> String.describe(value)
        consume_eols
        return CmdDescribe( t, parse_pre_unary )
      endIf
      return parse_post_unary

    method parse_post_unary->Cmd
      return parse_post_unary( parse_member_access )

    method parse_post_unary( operand:Cmd )->Cmd
      local t = peek
      if (consume(TokenType.symbol_question_mark))
        return parse_post_unary( CmdLogicalize(t,operand) )
      elseIf (allow_parens_operator and next_is(TokenType.symbol_open_paren))
        local result = CmdAccess( t, operand, "call", CmdArgs() )
        parse_args( result.args )
        return result
      else
        return operand
      endIf

    method parse_member_access->Cmd
      return parse_member_access( parse_term )

    method parse_member_access( context:Cmd )->Cmd
      local t = peek

      # **NOTE** any new token types handled should also be checked for in parse_context_block().
      if (consume(TokenType.symbol_dot))
        consume_eols
        if (consume(TokenType.symbol_empty_brackets)) return parse_member_access( context )
        if (next_is(TokenType.symbol_open_bracket))   return parse_member_access( parse_context_block(context) )

        # obj.value
        # obj.value(...)
        local access = parse_access( t, context )
        return parse_member_access( access )

      elseIf (consume(TokenType.symbol_slash_slash))
        # Identifier access, e.g. table//key -> table["key"]
        local name = read_identifier
        local result = parse_member_access( CmdElementAccess(t, context, CmdLiteralString(t,name)) ) : Cmd
        if (next_is(TokenType.symbol_open_paren))
          local args = CmdArgs()
          parse_args( args )
          result = CmdAccess( t, result, "call", args )
        endIf
        return result

      elseIf (consume(TokenType.symbol_open_bracket))
        # context[index]
        consume_eols
        local access = CmdElementAccess( t, context, parse_expression_allowing_query )
        consume_eols
        must_consume( TokenType.symbol_close_bracket )
        return parse_member_access( access )

      elseIf (consume(TokenType.symbol_arrow))
        # Conversion cast (cast-to):  value->String
        # Reinterpret cast (cast-as): value->(as String)
        consume_eols
        if (consume(TokenType.symbol_open_paren))
          # cast-as
          must_consume( TokenType.keyword_as )
          local as_type = parse_type
          must_consume( TokenType.symbol_close_paren )
          return parse_member_access( CmdAs(t,context,as_type) )
        endIf

        local to_type = parse_type

        if (next_is(TokenType.symbol_open_paren))
          local access = CmdAccess( t, context, "to_" + to_type.name, CmdArgs() )
          access.named_args = parse_args( access.args )
          return parse_member_access( access )
        endIf
        return parse_member_access( CmdConvertToType(t,context,to_type) )

      elseIf (consume(TokenType.symbol_fat_arrow))
        # Callback creator e.g. obj=>method_name or Type=>routine_name
        consume_eols
        local name = read_identifier
        local arg_types : Type[]
        consume_eols
        if (consume(TokenType.symbol_open_paren))
          arg_types = Type[]
          local first = true
          while (first or consume(TokenType.symbol_comma))
            first = false
            consume_eols
            arg_types.add( parse_type )
            consume_eols
          endWhile
          must_consume( TokenType.symbol_close_paren )
          consume_eols
        endIf
        local return_type : Type
        if (consume(TokenType.symbol_arrow)) return_type = parse_type
        local is_dynamically_specialized : Logical
        local specializing_signature : Cmd
        if (consume(TokenType.symbol_open_bracket))
          is_dynamically_specialized = true
          if (not consume(TokenType.symbol_close_bracket))
            specializing_signature = parse_expression
            must_consume( TokenType.symbol_close_bracket )
          endIf
        endIf
        return CmdCreateCallback( t, context, name, Program.get_callback_type_signature(arg_types), return_type,
        is_dynamically_specialized, specializing_signature )

      elseIf (consume(TokenType.keyword_as))
        # Deprecated cast-as operation e.g. actor as Hero
        consume_eols
        local as_type = parse_type

        local filename = File.filename( t.filepath )
        if (not deprecation_warnings.contains("$:$"(filename,t.line)))
          deprecation_warnings.add( "$:$"(filename,t.line) )
          println ''[DEPRECATION] "$" line $: Replace '(expression as $)' with 'expression->(as $)'.'' ...
            (filename,t.line,as_type,as_type)
        endIf
        return parse_member_access( CmdAs(t,context,as_type) )

        # **NOTE** any new token types handled should also be checked for in parse_context_block().

      endIf

      return context

    method parse_access( t:Token, context=null:Cmd )->Cmd
      consume_eols

      if (consume(TokenType.keyword_meta))
        # TODO: need to wrap the following in a Cmd and defer checking for the implicit type until after parsing is over
        local context_type : Type
        if (context) context_type = context.implicit_type( Scope(this_type,null) )
        else         context_type = this_type
        if (not context_type)
          throw t.error( "Unable to determine type for metadata access." )
        endIf

        must_consume( TokenType.symbol_dot )
        t = peek
        local id = read_identifier
        which (id)
          case "default_value"
            return CmdDefaultValue( t, context_type )
          others
            throw t.error( "'default_value' expected after 'meta.'." )
        endWhich
      endIf

      # In parse_access()
      local access = CmdAccess( t, parse_type_name(true) )
      if (next_is(TokenType.symbol_open_paren))
        access.args = CmdArgs()
        access.named_args = parse_args( access.args )
      endIf

      if (context)
        access.context = context
      elseIf (access.args and consume(TokenType.keyword_subclass))
        # In-line class definition
        local type_name = access.name
        local i1 = type_name.locate( "<<" )
        local i2 = type_name.locate_last( ">>" )
        while (i1.exists and i2.exists)
          local left = type_name.leftmost( i1.value )
          local right = type_name.from( i2.value+2 )
          local mid = type_name.from( i1.value+2, i2.value-1 )
          type_name = "$_of_$__$" (left,mid,right)
          i1 = type_name.locate( "<<" )
          i2 = type_name.locate_last( ">>" )
        endWhile
        type_name = type_name.replacing( '$', 'T' ) + "_" + Program.create_unique_id

        local inline_type = Program.get_type_reference( t, type_name )
        local template = Template( t, type_name, Attribute.is_class )
        parse_template_tokens( template, TokenType.keyword_endSubclass )
        inline_type.base_types.add( Program.get_type_reference(t,access.name) )
        access.name = type_name
      else
        access.used_modules = used_modules
      endIf

      return access

    # TODO: Add multi-line handling
    method parse_args( args:CmdArgs )->CmdNamedArg[]
      local named_args : CmdNamedArg[]
      local end_type   = TokenType.symbol_close_paren

      consume( TokenType.symbol_open_paren )
      consume_eols

      if (not consume(end_type))
        local first = true
        while (first or consume(TokenType.symbol_comma))
          first = false
          consume_eols
          local is_passthrough_arg = consume( TokenType.symbol_ampersand_equals )
          local is_named_arg = is_passthrough_arg or consume( TokenType.symbol_ampersand )
          if (is_named_arg)
            if (not named_args) named_args = CmdNamedArg[]
            local is_negative = consume( TokenType.symbol_exclamation_point )
            local arg_t = peek
            local arg = CmdNamedArg( arg_t, read_identifier )
            arg.is_negative = is_negative
            named_args.add( arg )
            if (is_passthrough_arg)
              arg.value = CmdAccess( arg.t, arg.name )   # &=x -> &x=x
            elseIf (consume(TokenType.symbol_equals))
              arg.value = parse_expression_allowing_query
            endIf
          else
            args.add( parse_expression_allowing_query )
          endIf
        endWhile
        consume_eols
        must_consume( end_type )
      endIf

      return named_args

    method parse_expression_allowing_query->Cmd
      local prior_setting = implicit_access_used
      implicit_access_used = false
      local expr = parse_expression

      if (implicit_access_used)
        expr = CmdCreateFunction( expr.t, FnParam[][FnParam("value")], null, null, CmdStatementList(), null, &is_generic, &query_cmd=expr )
      endIf

      implicit_access_used = prior_setting
      return expr

    method parse_specialization_string->String
      use buffer = StringBuilder.pool
        parse_specializer_list( buffer )
        return buffer->String
      endUse

    method parse_specialization_type( index:Int32 )->Type
      read   # '<<'

      use string_buffer = StringBuilder.pool
        local i = index
        local first = true
        while (first or consume(TokenType.symbol_comma))
          if (first) first = false
          else       string_buffer.print(',')

          local t = peek
          parse_specializer( string_buffer.clear )

          if (i == 0) return Program.get_type_reference( t, string_buffer->String )
          --i
        endWhile
      endUse

      @trace
      throw peek.error( "[INTERNAL] Invalid specializer index: $." (index) )

    method parse_specialization_info->ValueTable
      use string_buffer = StringBuilder.pool
        local count = parse_specializer_list( string_buffer )
        return @{string:string_buffer->String,count:count}
      endUse

    method parse_specializer_count->Int32
      local num_specializers = 0
      read   # '<<'

      use string_buffer = StringBuilder.pool
        local first = true
        while (first or consume(TokenType.symbol_comma))
          if (first) first = false
          parse_specializer( string_buffer.clear )
          ++num_specializers
        endWhile
      endUse

      must_consume( TokenType.symbol_close_specialize )

      return num_specializers

    method parse_specializer_list( buffer=null:StringBuilder, tokens=null:Token[] )->Int32
      # We know the next token is '<<'.
      # Returns: The count of how many specializers were parsed.
      use pool_buffer = StringBuilder.pool
        if (buffer is null) buffer = pool_buffer

        local count = 0
        local t = read   # '<<'
        if (tokens) tokens.add( t )
        buffer.print( "<<" )

        local first = true
        while (first or next_is(TokenType.symbol_comma))
          if (first)
            first = false
          else
            t = read  # ','
            if (tokens) tokens.add( t )
            buffer.print(',')
          endIf
          ++count
          parse_specializer( buffer, tokens )
        endWhile

        t = peek
        if (tokens) tokens.add( t )
        must_consume( TokenType.symbol_close_specialize )
        buffer.print( ">>" )

        return count
      endUse


    method parse_specializer( buffer=null:StringBuilder, tokens=null:Token[] )
      if (buffer is null) buffer = StringBuilder.pool.on_use
      use pool_buffer = StringBuilder.pool
        if (buffer is null) buffer = pool_buffer

        local start_position = reader.position
        try
          local type_name = parse_type_name
          buffer.print( type_name )
          if (tokens)
            local end_position = reader.position
            reader.position = start_position
            while (reader.position < end_position) tokens.add( reader.read )
          endIf
          return
        catch (not_a_type_name:RogueError)
          reader.position = start_position
        endTry


        while (reader.has_another)
          local t = peek

          if (t.type is TokenType.eol)
            throw peek.error( "Closing '>>' expected before end of line." )

          elseIf (consume(TokenType.symbol_backslash))
            buffer.print("\\")

            if (not reader.has_another) throw t.error( "Unexpected end of input." )

            t = read
            buffer.print( t )
            if (tokens) tokens.add( t )

          elseIf (t.type is TokenType.symbol_open_specialize)
            parse_specializer_list( buffer, tokens )

          elseIf (t.type is TokenType.symbol_comma or next_is(TokenType.symbol_close_specialize))
            return

          elseIf (t.type is TokenType.keyword_ThisType)
            read
            local this_type_name = which{ this_type:this_type.name || "ThisType" }
            if (tokens) tokens.add( TokenType.identifier.create_token(t,this_type_name) )
            buffer.print( this_type_name )

          else
            if (tokens) tokens.add( t )

            local st = read->String
            if (t.type is TokenType.literal_string)
              buffer.print( '"' ).print( st ).print( '"' )
            else
              buffer.print( st )
            endIf

          endIf
        endWhile
      endUse


    method parse_term->Cmd
      local t = peek

      local rewind_pos = reader.position  # if this (expression) is followed by => we have a function definition
      if (consume(TokenType.symbol_open_paren))
        if (consume("Function"))
          # (Function()->ReturnType)
          reader.position = rewind_pos

          # We have to handle an ambiguous case where the outer parens on "(Function(...))"
          # are part of the surrounding expression, not the Function type name. Specific case:
          # in "not ((Function)[] isReference)", the leading paren is assumed to be
          # part of the Function type name but it's not.
          try
            return parse_access( t )
          catch (e:Error)
            reader.position = rewind_pos
            consume( TokenType.symbol_open_paren )
            # fall through and carry on with parsing a parenthesized expression
          endTry
        endIf

        consume_eols
        contingent
          # Parse this (expression) while possibly aborting and switching to parsing
          # a (generic,function)=>definition.
          if (consume(TokenType.symbol_close_paren))
            sufficient (next_is(TokenType.symbol_fat_arrow))
            sufficient (next_is(TokenType.keyword_with))
            throw t.error( "Value expected, found empty parentheses ()." )
          endIf

          local result = null : Cmd
          if (not next_is(TokenType.symbol_comma))
            result = parse_expression
            consume_eols
          endIf

          if (next_is(TokenType.symbol_comma))
            local elements = Cmd[]
            if (result is null) result = CmdNoAction(peek)
            elements.add(result)
            while (consume(TokenType.symbol_comma))
              consume_eols
              if (next_is(TokenType.symbol_comma))
                # For skipping values in destructuring assignment.
                # Currently illegal for value (non-assignment) tuples, but could also
                # be used for Python-style single-element tuples: "(1,)".
                # We insert a NoAction as a placeholder which we can identify in
                # resolve(), and which lets us carry the token through.
                elements.add(CmdNoAction(peek))
              elseIf (next_is(TokenType.symbol_close_paren))
               # They skipped the last item.
                elements.add(CmdNoAction(peek))
                escapeWhile
              else
                elements.add(parse_expression())
              endIf
              consume_eols
            endWhile
            result = CmdTuple(t, elements)
          endIf

          must_consume( TokenType.symbol_close_paren )

          sufficient (next_is(TokenType.keyword_with))
          sufficient (next_is(TokenType.symbol_fat_arrow))

          if (result instanceOf CmdTuple)
            sufficient (next_is(TokenType.symbol_empty_brackets))
            sufficient (next_is(TokenType.symbol_question_mark))
          endIf

          return result

        satisfied
          if (next_is(TokenType.symbol_empty_brackets) or next_is(TokenType.symbol_question_mark))
            # Rewind and parse a type instead
            reader.position = rewind_pos
            return parse_access( t )
          endIf

          # Rewind and parse a generic function instead.
          reader.position = rewind_pos
          return parse_function( t )

        endContingent

      elseIf (next_is(TokenType.identifier) or next_is(TokenType.symbol_at) or next_is(TokenType.keyword_meta))
        local result = parse_access( t )
        local access = result->(as CmdAccess)
        if (access)
          if (access.args)
            if (consume(TokenType.symbol_empty_braces))
              # context{} -> context
              return access
            elseIf (next_is(TokenType.symbol_open_brace))
              # context{ x:y, :z } -> { context.x=y, context//z = z }
              return parse_literal_table( access )
            endIf
          else
            if (next_is(TokenType.symbol_open_bracket))
              if (access.name.ends_with("[]")) return parse_typed_literal_list( access )
            elseIf (consume(TokenType.symbol_empty_braces))
              # TableType{} -> TableType()
              access.args = CmdArgs()
              return access
            elseIf (next_is(TokenType.symbol_open_brace))
              # TableType{...} TableType(){...}
              access.args = CmdArgs()
              return parse_literal_table( access )
            endIf
          endIf
        endIf
        return result

      elseIf (consume(TokenType.literal_string))

        if (consume(TokenType.symbol_open_paren))
          local first = true
          local args = CmdArgs()
          while (first or consume(TokenType.symbol_comma))
            first = false
            args.add( parse_expression )
          endWhile
          consume_eols
          must_consume( TokenType.symbol_close_paren )
          return CmdFormattedString( t, t->String, args )
        endIf

        return CmdLiteralString( t, t->String )

      elseIf (consume(TokenType.keyword_null))
        return CmdLiteralNull(t)

      elseIf (consume(TokenType.literal_real64))
        return CmdLiteralReal64( t, t->Real64 )

      elseIf (consume(TokenType.literal_int32))
        local value = t->Int32
        return CmdLiteralInt32( t, value )

      elseIf (consume(TokenType.literal_int64))
        local value = t->Int64
        return CmdLiteralInt64( t, value )

      elseIf (consume(TokenType.literal_character))
        local value = t->Character
        return CmdLiteralCharacter( t, value->Character )

      elseIf (consume(TokenType.keyword_this))
        local result = CmdLiteralThis( t, this_type ) : Cmd
        if (consume(TokenType.symbol_open_paren))
          local args = CmdArgs()
          parse_args( args )
          result = CmdAccess( t, result, "call", args )
        endIf
        return result

      elseIf (consume(TokenType.keyword_true))
        return CmdLiteralLogical( t, true )

      elseIf (consume(TokenType.keyword_false))
        return CmdLiteralLogical( t, false )

      elseIf (consume(TokenType.keyword_pi))
        return CmdLiteralReal64( t, pi )

      elseIf (consume(TokenType.keyword_infinity))
        return CmdLiteralReal64.create_infinity( t )

      elseIf (consume(TokenType.keyword_NaN))
        return CmdLiteralReal64.create_NaN( t )

      elseIf (consume(TokenType.symbol_open_bracket))
        # [ literal, list ]
        local elements = CmdArgs()
        consume_eols
        if (not consume(TokenType.symbol_close_bracket))
          local has_another = true
          while (has_another)
            has_another = false
            elements.add( parse_expression )
            contingent
              consume_eols
              sufficient (consume(TokenType.symbol_comma))
              necessary  (not next_is(TokenType.symbol_close_bracket))
            satisfied
              has_another = true
              consume_eols
            endContingent
          endWhile
          must_consume( TokenType.symbol_close_bracket )
        endIf

        return CmdCreateList( t, elements )

      elseIf (consume(TokenType.symbol_at_brace))
        return parse_value_table( t )

      elseIf (consume(TokenType.symbol_at_bracket))
        if (consume(TokenType.symbol_close_bracket))
          local result = CmdAccess( t, "ValueList",  CmdArgs() )
          if (next_is(TokenType.symbol_open_paren)) parse_args( result.args )
          return result
        else
          return parse_value_list( t )
        endIf

      elseIf (consume(TokenType.symbol_empty_braces))
        return CmdAccess( t, "ValueTable", CmdArgs() )

      elseIf (consume(TokenType.symbol_empty_brackets))
        return CmdAccess( t, "ValueList",  CmdArgs() )

      elseIf (consume(TokenType.keyword_prior))
        consume_eols
        local name : String
        if (consume(TokenType.symbol_arrow))
          consume_eols
          name = "to_" + parse_type.name
        else
          must_consume( TokenType.symbol_dot )
          consume_eols
          name = read_identifier
          if (next_is(TokenType.symbol_open_specialize)) name += parse_specialization_string
        endIf
        local args : CmdArgs
        local named_args : CmdNamedArg[]
        if (next_is(TokenType.symbol_open_paren))
          args = CmdArgs()
          named_args = parse_args( args )
        endIf
        return CmdCallPriorMethod( t, name, args, named_args )

      elseIf (consume(TokenType.keyword_await))
        # Insert a local result declaration and a statement list to hold the
        # await cmd and subsequent conversion.  Substitute the result var in
        # place of this term.
        #
        #   x = await some_task(a,b)
        #
        # ->
        #
        #   local result : TBD
        #   {
        #     task = some_task(a,b)   # result.type = task result type
        #     while (task.update) yield
        #     result = task.result
        #   }
        #   x = result
        #
        local result_var = Local( t, Program.create_unique_id, Program.type_Object )
        local statement_list = CmdStatementList()
        cur_statement_list.add( CmdLocalDeclaration(t,result_var) )
        cur_statement_list.add( CmdAwait(t,parse_expression,statement_list,result_var) )
        return CmdAccess( t, result_var.name )

      elseIf (consume(TokenType.keyword_function))
        return parse_function( t )

      elseIf (next_is(TokenType.symbol_fat_arrow))
        return parse_function( t )

      elseIf (consume(TokenType.keyword_native))
        consume_eols
        local has_parens = consume( TokenType.symbol_open_paren )
        if (has_parens) consume_eols

        if (not next_is(TokenType.literal_string))
          throw peek.error( "Literal string expected." )
        endIf
        local code = read->String

        if (has_parens)
          consume_eols
          must_consume( TokenType.symbol_close_paren )
        endIf

        local result_type : Type
        if (consume(TokenType.symbol_arrow)) result_type = parse_type

        return CmdInlineNative( t, code, result_type )

      elseIf (consume(TokenType.symbol_select) or consume(TokenType.keyword_which))
        consume_eols

        local expression : Cmd
        if (consume(TokenType.symbol_open_paren))
          consume_eols
          expression = parse_expression
          consume_eols
          must_consume( TokenType.symbol_close_paren )
          consume_eols
        endIf
        return parse_select( t, expression )

      elseIf (consume(TokenType.symbol_dollar))
        # Implicit query arg access.  E.g. list.discard( $.is_dead ) -> list.discard( (x)=>x.is_dead )
        implicit_access_used = true
        return CmdImplicitAccess( t )

      elseIf (consume(TokenType.keyword_forEach))
        # Implicit loop
        local var_name = Program.create_unique_id
        local control_var_name, index_var_name : String
        if (consume(TokenType.keyword_in))     control_var_name = var_name
        elseIf (consume(TokenType.keyword_of)) index_var_name = var_name
        else throw t.error( "'in' or 'of' expected after 'forEach'." )

        local collection = parse_expression
        local range = collection->(as CmdRange)
        if (range)
          if (index_var_name) throw t.error( "Illegal use of forEach-of with literal range." )
          local cmd_for_each = create_generic_loop_from_range( t, var_name, range )
          implicit_loop_stack.add( cmd_for_each )

        else
          local first_cmd, last_cmd, step_cmd : Cmd

          if (consume("from"))
            local from_cmd = parse_expression
            local from_range = from_cmd->(as CmdRange)
            if (from_range)
              first_cmd = from_range.first
              last_cmd = from_range.last
              step_cmd = from_range.step_cmd
            else
              first_cmd = from_cmd
            endIf
          endIf

          if (not step_cmd and consume(TokenType.keyword_step))
            step_cmd = parse_expression
          endIf

          local cmd_for_each = CmdForEach( t, control_var_name, index_var_name, collection, step_cmd )
          cmd_for_each.first_cmd = first_cmd
          cmd_for_each.last_cmd = last_cmd
          implicit_loop_stack.add( cmd_for_each )
        endIf

        return CmdAccess( t, var_name )

      elseIf (next_is(TokenType.keyword_try))
        return parse_try_expression

      elseIf (next_is(TokenType.keyword_ensure))
        return parse_ensure_expression

      elseIf (next_is(TokenType.keyword_ThisType))
        t = read
        local result = CmdThisType( t, this_type, null )
        if (next_is(TokenType.symbol_open_paren))
          result.args = CmdArgs()
          parse_args( result.args )
        endIf
        return result

      elseIf (consume(TokenType.keyword_assert))
        consume_eols
        local has_parens = consume( TokenType.symbol_open_paren )

        local start_t = peek
        local expr = parse_expression
        local message : Cmd
        if (consume(TokenType.symbol_double_vertical_bar)) message = parse_expression
        local end_t = peek

        if (has_parens) must_consume( TokenType.symbol_close_paren )

        if (not RogueC.debug_mode) return expr

        if (not message)
          local buffer = StringBuilder()
          local parse_reader = RogueC.scanners_by_filepath[ start_t.filepath ]
          if (parse_reader and start_t.line and start_t.column and start_t.filepath == end_t.filepath)
            parse_reader.seek_location( start_t.line, start_t.column )
            while (parse_reader.has_another and (parse_reader.line < end_t.line or ...
                   (parse_reader.line == end_t.line and parse_reader.column < end_t.column)))
              buffer.print( parse_reader.read )
            endWhile
          endIf
          message = CmdLiteralString( t, buffer->String )
        endIf

        local temp_var = Local( t, Program.create_unique_id )
        temp_var.type = Program.type_Int32  # temporary placeholder until CmdAssert resolves
        cur_statement_list.add( CmdLocalDeclaration(t,temp_var,&skip_initialization) )
        return CmdAssert(t, expr, message, temp_var)

      elseIf (consume(TokenType.keyword_require))
        consume_eols
        local has_parens = consume( TokenType.symbol_open_paren )

        local start_t = peek
        local expr = parse_expression
        local message : Cmd
        if (consume(TokenType.symbol_double_vertical_bar)) message = parse_expression
        local end_t = peek

        if (has_parens) must_consume( TokenType.symbol_close_paren )

        if (not message)
          local buffer = StringBuilder()
          local parse_reader = RogueC.scanners_by_filepath[ start_t.filepath ]
          if (parse_reader and start_t.line and start_t.column and start_t.filepath == end_t.filepath)
            parse_reader.seek_location( start_t.line, start_t.column )
            while (parse_reader.has_another and (parse_reader.line < end_t.line or ...
                   (parse_reader.line == end_t.line and parse_reader.column < end_t.column)))
              buffer.print( parse_reader.read )
            endWhile
          endIf
          buffer.print( " in " ).print( this_type.name ).print( "." ).print( this_method.name ).print( "()" )
          message = CmdLiteralString( t, buffer->String )
        endIf

        local temp_var = Local( t, Program.create_unique_id )
        temp_var.type = Program.type_Int32  # temporary placeholder until CmdRequire resolves
        cur_statement_list.add( CmdLocalDeclaration(t,temp_var,&skip_initialization) )
        return CmdRequire(t, expr, message, temp_var)

      elseIf (consume(TokenType.meta_methodSignature))
        return CmdMetaMethodSignature( t )

      elseIf (consume(TokenType.symbol_open_specialize))
        local type = parse_type
        local result = CmdTypeSelector( t, type )
        must_consume( TokenType.symbol_close_specialize )
        return result

      elseIf (consume(TokenType.keyword_isComparable))
        consume_eols
        must_consume( TokenType.symbol_open_paren )
        consume_eols
        local a = parse_expression
        consume_eols
        must_consume( TokenType.symbol_comma )
        consume_eols
        local b = parse_expression
        consume_eols
        must_consume( TokenType.symbol_close_paren )
        return CmdIsComparable( t, a, b )

      elseIf (consume(TokenType.keyword_isAspect))
        return CmdIsAspect( t, parse_isType_expression )
      elseIf (consume(TokenType.keyword_isClass))
        return CmdIsClass( t, parse_isType_expression )
      elseIf (consume(TokenType.keyword_isCompound))
        return CmdIsCompound( t, parse_isType_expression )
      elseIf (consume(TokenType.keyword_isPrimitive))
        return CmdIsPrimitive( t, parse_isType_expression )
      elseIf (consume(TokenType.keyword_isReference))
        return CmdIsReference( t, parse_isType_expression )
      elseIf (consume(TokenType.keyword_isString))
        return CmdIsString( t, parse_isType_expression )

      elseIf (consume(TokenType.meta_string))
        use builder=StringBuilder.pool
          must_consume( TokenType.symbol_open_paren )

          local depth = 1
          while (reader.has_another)
            local t2 = reader.read
            if (t2.type is TokenType.symbol_open_paren)
              ++depth
            elseIf (t2.type is TokenType.symbol_close_paren)
              --depth
              if (depth == 0) escapeWhile
            endIf
            builder.print( t2->String )
          endWhile

          if (depth > 0) must_consume( TokenType.symbol_close_paren )  # generate error

          return CmdLiteralString( t, builder->String )
        endUse

      else
        throw peek.error( "Syntax error: unexpected '" + peek + "'." )
      endIf

    method parse_select( t:Token, expression=null:Cmd )->CmdSelect
      local cmd_select = CmdSelect( t )

      if (expression)
        local comparison_var = Local( t, Program.create_unique_id )
        local cmd_declaration = CmdLocalDeclaration( t, comparison_var, &skip_initialization )
        cur_statement_list.add( cmd_declaration )
        comparison_var.initial_value = expression
        cmd_select.local_declaration = cmd_declaration
        cmd_select.local_info = comparison_var
        cmd_select.expression = comparison_var.initial_value
      endIf

      must_consume( TokenType.symbol_open_brace )
      local first = true
      while (first or consume(TokenType.symbol_double_vertical_bar))
        first = false
        consume_eols
        local select_case = CmdSelectCase( peek )
        cmd_select.cases.add( select_case )

        if (consume(TokenType.keyword_others))
          consume_eols
          must_consume( TokenType.symbol_colon )
          consume_eols

          # If we don't use the 'others' keyword then the last value
          # will end up in 'conditions' to begin with so stick to that
          # pattern.
          select_case.conditions.add( parse_expression )

          escapeWhile

        else
          select_case.conditions.add( parse_expression )
          while (consume(TokenType.symbol_comma))
            consume_eols
            select_case.conditions.add( parse_expression )
            consume_eols
          endWhile

          if (consume(TokenType.symbol_colon))
            consume_eols
            select_case.value = parse_expression
            consume_eols
          elseIf (select_case.conditions.count > 1)
            must_consume( TokenType.symbol_colon )  # Force an error
          endIf
        endIf
      endWhile

      # Convert any `which{ x || z }` to `local temp=x; which{ x:x || z }`
      forEach (i in 0..<cmd_select.cases.count - 1)
        local select_case = cmd_select.cases[i]
        if (not select_case.value)
          local temp_var = Local( t, Program.create_unique_id )
          temp_var.initial_value = select_case.conditions.remove_last
          cur_statement_list.add( CmdLocalDeclaration(t,temp_var) )
          select_case.local_info = temp_var
          select_case.conditions.add( CmdReadLocal(t,temp_var) )
          select_case.value = CmdReadLocal(t,temp_var)
          select_case.condition_is_value = true
        endIf
      endForEach

      if (cmd_select.cases.last.conditions.count > 1)
        throw t.error( "The last part of a which{} must be a single expression." )
      elseIf (cmd_select.cases.last.value)
        throw t.error( "The last part of a which{} cannot have a condition." )
      else
        cmd_select.cases.last.value = cmd_select.cases.last.conditions.remove_first
        cmd_select.cases.last.conditions.clear
      endIf

      must_consume( TokenType.symbol_close_brace )

      return cmd_select


    method parse_isType_expression->Cmd
      consume_eols
      must_consume( TokenType.symbol_open_paren )
      consume_eols
      local expr = parse_expression
      consume_eols
      must_consume( TokenType.symbol_close_paren )
      return expr

    method parse_ensure_statement->Cmd
      local t = read  # 'ensure'

      local has_parens = consume( TokenType.symbol_open_paren )
      local cmd_block = CmdBlock( t )

      local first = true
      while (first or consume(TokenType.symbol_double_ampersand))
        first = false

        local expr = parse_expression

        local cmd_ensure : CmdEnsure
        if (next_is(TokenType.symbol_open_paren))
          # The args haven't been parsed yet because they're invalid outside the context
          # of this ensure command.
          local args = CmdArgs()
          local named_args = parse_args( args )
          cmd_ensure = CmdEnsure( t, expr, args, named_args )

        else
          local access = expr->(as CmdAccess)
          if (access)
            local args = access.args
            if (not args) args = CmdArgs()
            local named_args = access.named_args
            access.args = null
            access.named_args = null
            cmd_ensure = CmdEnsure( t, access, args, named_args )
          else
            cmd_ensure = CmdEnsure( t, expr, CmdArgs() )
          endIf
        endIf

        cmd_block.statements.add( cmd_ensure )

      endWhile

      if (has_parens) must_consume( TokenType.symbol_close_paren )

      if (cmd_block.statements.count == 1) return cmd_block.statements.first
      else                                 return cmd_block

    method parse_ensure_expression->Cmd
      local t = read  # 'ensure'

      local has_parens = consume( TokenType.symbol_open_paren )

      local expr = parse_expression

      local cmd_ensure : CmdEnsure
      if (next_is(TokenType.symbol_open_paren))
        # The args haven't been parsed yet because they're invalid outside the context
        # of this ensure command.
        local args = CmdArgs()
        local named_args = parse_args( args )
        cmd_ensure = CmdEnsure( t, expr, args, named_args )

      else
        local access = expr->(as CmdAccess)
        if (access)
          local args = access.args
          if (not args) args = CmdArgs()
          local named_args = access.named_args
          access.args = null
          access.named_args = null
          cmd_ensure = CmdEnsure( t, access, args, named_args )
        else
          cmd_ensure = CmdEnsure( t, expr, CmdArgs() )
        endIf
      endIf

      if (has_parens) must_consume( TokenType.symbol_close_paren )

      # The actual 'ensure' operation goes before the current statement.  This
      # current expression resolves to just the variable being ensured.
      cur_statement_list.add( cmd_ensure )

      return cmd_ensure.operand.cloned

    method parse_function( t:Token )->Cmd
      local parameters : FnParam[]
      local return_type : Type
      local is_generic = false
      if (consume(TokenType.symbol_open_paren))
        if (not consume(TokenType.symbol_close_paren))
          parameters = FnParam[]
          local first = true
          while (first or consume(TokenType.symbol_comma))
            first = false
            local param = FnParam( read_identifier )
            local t2 = peek
            local cur_generic = false
            if (consume(TokenType.symbol_colon)) param.type = parse_type
            else                                 cur_generic = true

            if (parameters.count and (is_generic != cur_generic))
              throw t2.error( "function parameters must all be typed or all be generic." )
            endIf

            is_generic = cur_generic
            parameters.add( param )
          endWhile
          must_consume( TokenType.symbol_close_paren )
        endIf
      endIf

      local parsed_arrow = false
      local t2 = peek
      if (consume(TokenType.symbol_arrow))
        if (is_generic) throw t2.error( "A function with generic parameters must use '=>' to define its body." )
        parsed_arrow = true
        consume_eols
        local has_parens = consume( TokenType.symbol_open_paren )
        if (has_parens) consume_eols
        return_type = parse_type
        if (has_parens)
          consume_eols
          must_consume( TokenType.symbol_close_paren )
          print_old_style_function_warning( t )
        endIf
      endIf

      local with_args : FnArg[]
      if (consume(TokenType.keyword_with))
        must_consume( TokenType.symbol_open_paren )
        if (not consume(TokenType.symbol_close_paren))
          with_args = FnArg[]
          local first = true
          while (first or consume(TokenType.symbol_comma))
            first = false
            t2 = peek
            local name  = read_identifier
            local value : Cmd
            if (consume(TokenType.symbol_equals))
              value = parse_expression
            else
              # Function definition
              value = CmdAccess( t2, name )
            endIf
            local arg = FnArg( name, value )
            if (consume(TokenType.symbol_colon)) arg.type = parse_type
            with_args.add( arg )
          endWhile
          must_consume(TokenType.symbol_close_paren)
        endIf
      endIf

      consume( TokenType.symbol_colon )  # totally optional

      if (not parsed_arrow)
        t2 = peek
        if (consume(TokenType.symbol_fat_arrow))
          if (parameters and parameters.count and not is_generic)
            # Note: if there are no parameters then 'is_generic' is not valid and we can accept
            # the generic arrow
            throw t2.error( "A function with typed parameters must use '->' to define its return type (if desired) and cannot use the generic function definition symbol '=>'." )
          endIf

          is_generic = true
        endIf
      endIf

      local statements : CmdStatementList
      local tokens : Token[]
      if (not is_generic and consume_eols)
        ensure tokens
        local depth = 1
        while (reader.has_another)
          t2 = reader.read
          if (t2.type is TokenType.keyword_endFunction)
            --depth
            if (depth == 0) escapeWhile
            tokens.add( t2 )
          elseIf (t2.type is TokenType.keyword_function)
            ++depth
            tokens.add( t2 )
          else
            tokens.add( t2 )
          endIf
        endWhile
        if (depth) throw t.error( "End of file looking for 'endFunction'." )
      else
        ensure statements
        parse_single_line_statements( statements )
      endIf

      return CmdCreateFunction( t, parameters, return_type, with_args, statements, tokens, is_generic )

    method print_old_style_function_warning( t:Token )
      local warning = ''**WARNING** Old-style Function type syntax in "$", line $.  Use (Function()->Type) rather than Function()->(Type).'' (File.filename(t.filepath),t.line)
      if (not old_style_function_warnings.contains(warning))
        println warning
        old_style_function_warnings.add( warning )
      endIf

    method parse_value_table( t:Token )->Cmd
      # '{' already consumed
      local table = CmdTypedLiteralTable( CmdAccess(t,"ValueTable") )
      consume_eols
      if (consume(TokenType.symbol_close_brace)) return table

      local has_another = true
      while (has_another)
        has_another = false
        consume_eols

        t = peek
        if (consume(TokenType.symbol_colon))
          # :x -> "x":x
          consume_eols
          local name = read_identifier
          table.add( CmdLiteralString(t,name), CmdAccess(t,name) )
        else
          local key : Cmd
          if (next_is_identifier)
            t = peek
            key = CmdLiteralString( t, read_identifier )
          else
            key = parse_expression
          endIf
          consume_eols

          local value : Cmd
          if (consume(TokenType.symbol_colon))
            consume_eols
            t = peek
            if (consume(TokenType.symbol_open_brace))
              value = parse_value_table( t )
            elseIf (consume(TokenType.symbol_open_bracket))
              value = parse_value_list( t )
            else
              value = parse_expression
            endIf
          else
            value = CmdLiteralLogical( t, true )
          endIf

          table.add( key, value )
        endIf

        consume_eols

        contingent
          sufficient (consume(TokenType.symbol_comma))
          necessary  (not next_is(TokenType.symbol_close_brace))
        satisfied
          has_another = true
          consume_eols
        endContingent
      endWhile

      must_consume( TokenType.symbol_close_brace )
      return table

    method parse_value_list( t:Token )->Cmd
      # '[' already consumed
      consume_eols
      if (consume(TokenType.symbol_close_bracket)) return CmdAccess( t, "ValueList", CmdArgs() )

      local elements = CmdArgs()
      local has_another = true
      while (has_another)
        has_another = false
        consume_eols

        local value : Cmd
        t = peek
        if (consume(TokenType.symbol_open_brace))
          value = parse_value_table( t )
        elseIf (consume(TokenType.symbol_open_bracket))
          value = parse_value_list( t )
        else
          value = parse_expression
        endIf

        elements.add( value )

        contingent
          consume_eols
          sufficient (consume(TokenType.symbol_comma))
          necessary  (not next_is(TokenType.symbol_close_bracket))
        satisfied
          has_another = true
          consume_eols
        endContingent
      endWhile

      must_consume( TokenType.symbol_close_bracket )
      return CmdTypedLiteralList( CmdAccess(t,"ValueList"), elements )

    method parse_typed_literal_list( context:CmdAccess )->Cmd
      must_consume( TokenType.symbol_open_bracket )
      consume_eols

      local elements = CmdArgs()

      local has_another = true
      while (has_another)
        has_another = false
        consume_eols
        local t = peek
        if (next_is(TokenType.symbol_open_bracket))
          # Nested list - propagate the type
          if (context.name.ends_with("[][]"))
            local item = parse_typed_literal_list( CmdAccess(t,context.name.leftmost(-2)) )
            elements.add( item )
          else
            throw t.error( "Literal list content contains more dimensions than literal list type." )
          endIf
        else
          elements.add( parse_expression )
        endIf

        contingent
          consume_eols
          sufficient (consume(TokenType.symbol_comma))
          necessary  (not next_is(TokenType.symbol_close_bracket))
        satisfied
          has_another = true
          consume_eols
        endContingent

      endWhile
      must_consume( TokenType.symbol_close_bracket )

      return CmdTypedLiteralList( context, elements )

    method parse_context_block( context:Cmd )->Cmd
      local t = peek

      must_consume( TokenType.symbol_open_bracket )
      consume_eols
      if (consume(TokenType.symbol_close_bracket)) return context

      local cmd_block = CmdContextBlock( t, context )

      local first = true
      local consumed_eol = false
      while (first or consume(TokenType.symbol_comma) or (consumed_eol and not next_is(TokenType.symbol_close_bracket)))
        consume_eols
        consumed_eol = false

        first = false
        t = peek

        contingent
          local t_type = t.type
          sufficient (t_type is TokenType.symbol_dot)
          sufficient (t_type is TokenType.symbol_slash_slash)
          sufficient (t_type is TokenType.symbol_open_bracket)
          sufficient (t_type is TokenType.symbol_arrow)
          sufficient (t_type is TokenType.symbol_fat_arrow)
          sufficient (t_type is TokenType.keyword_as)
          necessary false

        satisfied
          # .x -> context.x, etc.
          local cmd = CmdAccess( t, cmd_block.context_var_name ) : Cmd
          cmd_block.add( parse_statement_with_context( parse_member_access(cmd) ) )

        unsatisfied
          # x -> context.x
          local cmd = CmdAccess( t, cmd_block.context_var_name ) : Cmd
          local access = parse_access( t, cmd )
          cmd_block.add( parse_statement_with_context(access) )
        endContingent

        consumed_eol = consume_eols
      endWhile

      must_consume( TokenType.symbol_close_bracket )
      return parse_member_access( cmd_block )

    method parse_literal_table( context:CmdAccess )->Cmd
      local t = peek

      must_consume( TokenType.symbol_open_brace )
      consume_eols
      if (consume(TokenType.symbol_close_brace)) return context

      local cmd_block = CmdContextBlock( t, context )

      local has_another = true
      while (has_another)
        consume_eols

        has_another = false
        t = peek

        if (consume(TokenType.symbol_colon))
          # :x -> context["x"] = x
          local name = read_identifier
          local cmd = CmdAccess( t, cmd_block.context_var_name ) : Cmd
          cmd = CmdElementAccess( t, cmd, CmdLiteralString(t,name) )
          cmd_block.add( CmdAssign(t,cmd,CmdAccess(t,name)) )

        else
          # x:y -> context[x] = y
          local cmd = CmdAccess( t, cmd_block.context_var_name ) : Cmd
          cmd = CmdElementAccess( t, cmd, parse_expression )
          consume_eols
          must_consume( TokenType.symbol_colon )
          consume_eols
          cmd_block.add( CmdAssign(t,cmd,parse_expression) )
        endIf

        consume_eols

        contingent
          sufficient (consume(TokenType.symbol_comma))
          necessary  (not next_is(TokenType.symbol_close_brace))
        satisfied
          has_another = true
          consume_eols
        endContingent
      endWhile

      must_consume( TokenType.symbol_close_brace )
      return parse_member_access( cmd_block )

endClass

class FnParam( name:String )
  PROPERTIES
    type : Type
endClass

class FnArg( name:String, value:Cmd )
  PROPERTIES
    type : Type

  METHODS
    method set_type( @type )->FnArg
      return this
endClass

class ModulePrefixLookup
  PROPERTIES
    id_map = StringTable<<String>>()

  METHODS
    method clear
      id_map.clear

    method get( name:String )->String [macro]
      (this.id_map[name])

    method use_module( name:String )
      id_map.add( Program.module_id_map(name) )

endClass

class UsedModule( name:String, previous:UsedModule )
  METHODS
    method contains( module_name:String )->Logical
      local cur = this
      while (cur)
        if (cur.name == module_name) return true
        cur = cur.previous
      endWhile
      return false

    method find( global_var_name:String )->String
      local result = Program.module_global_map( name )[ global_var_name ]
      if (result)   return result
      if (previous) return previous.find( global_var_name )
      return null

    method to->String
      return name
endClass

