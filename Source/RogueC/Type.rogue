$include "Definition.rogue"

class Type
  GLOBAL PROPERTIES
    # Useful for printing out to help debug compiler crashes
    configure_chain = Type[]
    organize_chain = Type[]
    resolve_chain = Type[]

  PROPERTIES
    t               : Token
    name            : String
    attributes      = Attributes()
    index           = -1

    source_template : Template
    specializers    : TypeSpecializer[]

    is_defined        : Logical
    configured        : Logical
    organized         : Logical
    organizing        : Logical
    resolved          : Logical
    culled            : Logical

    base_class         : Type
    base_types         = Type[]
    extended_types     = Type[]

    aspect_base_class  : Type
    # This aspect specifies a base class for incorporating classes to adopt.

    is_array     : Logical
    is_list      : Logical
    is_optional  : Logical
    element_type : Type

    is_used      : Logical

    simplify_name : Logical
      # RogueInt32 instead of RoguePrimitiveInt32, etc. - used for classes that are predefined
      # in the infrastructure and that developers will often use directly.

    categories        : Definition[] # For enums

    definition_list   = Definition[]
    definition_lookup = Table<<String,Definition>>()
    prev_enum_cmd     : Cmd
    next_enum_offset  = 0

    global_list   = Property[]
    global_lookup = Table<<String,Property>>() : Table<<String,Property>>

    property_list   = Property[]
    property_lookup = Table<<String,Property>>() : Table<<String,Property>>
    enum_properties : Property[]

    global_method_list                = Method[]                   : Method[]
    global_method_lookup_by_name      = Table<<String,Method[]>>() : Table<<String,Method[]>>
    global_method_lookup_by_signature = Table<<String,Method>>()   : Table<<String,Method>>

    method_list                = Method[]                   : Method[]
    method_lookup_by_name      = Table<<String,Method[]>>() : Table<<String,Method[]>>
    method_lookup_by_signature = Table<<String,Method>>()   : Table<<String,Method>>

    dynamic_method_table_index : Int32
    dynamic_method_table_count : Int32

    is_function = false
    callback_parameter_types : Type[]
    callback_return_type     : Type

    method_templates = MethodTemplates(this)

    dependencies : CmdStatementList

    deprecated_message : String

  METHODS
    method init( t, name )

    method add_method( m_t:Token, m_name:String )->Method
      return add_method( Method(m_t, this, m_name) )

    method add_method( m:Method )->Method
      method_list.add( m )
      local list = method_lookup_by_name[ m.name ]
      if (not list)
        list = Method[]
        method_lookup_by_name[ m.name ] = list
      endIf
      list.add( m )

      return m

    method replace_method( existing:Method, m_t:Token, m_name:String )->Method
      local m = Method( m_t, this, m_name )
      m.index = existing.index
      method_list[ m.index ] = m
      local list = method_lookup_by_name[ m_name ]
      list.remove( existing )
      list.add( m )
      return m

    method add_global_method( r_t:Token, r_name:String )->Method
      return add_global_method( Method(r_t, this, r_name) )

    method add_global_method( m:Method )->Method
      m.attributes.add( Attribute.is_global )

      if (organized and not organizing) inject_global_method( m ); return m

      global_method_list.add( m )
      local list = global_method_lookup_by_name[ m.name ]
      if (not list)
        list = Method[]
        global_method_lookup_by_name[ m.name ] = list
      endIf
      list.add( m )

      return m

    method add_global( s_t:Token, s_name:String )->Property
      return add_global( Property(s_t,this,s_name) )

    method add_global( p:Property )->Property
      p.attributes |= Attribute.is_global
      global_list.add( p )
      global_lookup[p.name] = p
      return p

    method add_property( p_t:Token, p_name:String, p_type=null:Type, initial_value=null:Cmd )->Property
      return add_property( Property(p_t, this, p_name, p_type, initial_value) )

    method add_property( p:Property )->Property
      property_list.add( p )
      property_lookup[p.name] = p
      return p

    method add_enum_property( p:Property )->Property
      ensure enum_properties
      if (enum_properties.find($.name==p.name)) throw p.t.error( ''An enum property named "$" already exists.'' (p.name) )
      enum_properties.add( p )
      return p

    method compile_type->Type
      return this

    method create_default_value( _t:Token )->Cmd
      if (this.is_reference) return CmdLiteralNull( _t )
      if (this.is_compound) return CmdCreateCompound( _t, this, null )
      if (this is Program.type_Logical) return CmdLiteralLogical( _t, false )
      return CmdLiteralInt32( _t, 0 )

    method create_flag_value( _t:Token )->Cmd
      if (this.is_reference) return CmdLiteralNull( _t )
      if (this.is_compound) return CmdCreateCompound( _t, this, null )
      if (this is Program.type_Logical) return CmdLiteralLogical( _t, false )
      return CmdLiteralInt32( _t, 0 )

    method dispatch( v:Visitor )
      v.visit( this )

    method extends_object->Logical
      return instance_of( Program.type_Object )

    method collect_aspect_base_classes
      forEach (base_type in base_types)
        if (base_type.aspect_base_class)
          if (not base_types.contains(base_type.aspect_base_class))
            base_types.add( base_type.aspect_base_class )
          endIf
        endIf
      endForEach

    method find_method( signature:String )->Method
      local m = method_lookup_by_signature[signature]
      if (m) return m

      return find_global_method( signature )

    method find_global_method( signature:String )->Method
      local m = global_method_lookup_by_signature[signature]
      if (m) return m

      return null

    method find_property( p_name:String, used_modules=null:UsedModule )->Property
      if (p_name[0] == '@') p_name = p_name.rightmost(-1)

      if (this is Program.type_Global)
        if (p_name[0] == ':')
          # ::name -> name
          return find_property( p_name.from(2) )
        endIf

        if (used_modules)
          local qualified_name = used_modules.find( p_name )
          if (qualified_name) return find_property( qualified_name )
        endIf
      endIf

      local result = property_lookup[p_name]
      if (result) return result

      return null

    method find_global( s_name:String )->Property
      if (s_name[0] == '@') s_name = s_name.rightmost(-1)
      local result = global_lookup[s_name]
      if (result) return result

      forEach (base_type in base_types)
        result = base_type.find_global( s_name )
        if (result) return result
      endForEach

      return null

    method has_extended_class->Logical
      return extended_types.count?

    method has_method_named( m_name:String, arg_count=null:Int32? )->Logical
      local list = method_lookup_by_name[m_name]
      if (not list or list.is_empty) return false
      if (not arg_count.exists) return true

      forEach (m in list)
        if (m.parameters.count == arg_count.value) return true
      endForEach

      return false

    method has_compatible_method_named( m_name:String, arg_type:Type )->Logical
      organize
      arg_type.organize

      local list = method_lookup_by_name[m_name]
      if (list and list.count)
        forEach (m in list)
          if (m.min_args == 1)
            if (arg_type.is_compatible_with(m.parameters[0].type)) return true
          endIf
        endForEach
      endIf

      if (is_aspect) return Program.type_Object.has_compatible_method_named( m_name, arg_type )
      else           return false

    method has_global_method_named( m_name:String, arg_count=null:Int32? )->Logical
      local list = global_method_lookup_by_name[m_name]
      if (not list or list.is_empty) return false
      if (not arg_count.exists) return true

      forEach (m in list)
        if (m.parameters.count == arg_count.value) return true
      endForEach

      return false

    method has_compatible_global_method_named( m_name:String, arg_1_type:Type, arg_2_type:Type )->Logical
      organize
      arg_1_type.organize
      arg_2_type.organize

      local list = global_method_lookup_by_name[m_name]
      if (not list or list.is_empty) return false

      forEach (m in list)
        if (m.min_args == 2)
          if (arg_1_type.is_compatible_with(m.parameters[0].type) and arg_2_type.is_compatible_with(m.parameters[1].type))
            return true
          endIf
        endIf
      endForEach

      return false

    method instance_of( ancestor_type:Type )->Logical
      if (this is ancestor_type) return true
      if (this is Program.type_null and ancestor_type.is_reference) return true
      if (this.is_reference and ancestor_type is Program.type_Object) return true

      forEach (base_type in base_types)
        if (base_type.instance_of(ancestor_type)) return true
      endForEach

      return false

    method is_compatible_with( other:Type )->Logical
      if (this is other) return true

      if (this.is_primitive and other.is_primitive)
        if (this is Program.type_Logical xor other is Program.type_Logical) return false
        return true
      endIf

      if (other.is_optional)
        if (other.element_type is this) return true
        if (this is Program.type_null) return true

        if (other.element_type.is_primitive)
          if (this.is_primitive)
            return not (this is Program.type_Logical xor other.element_type is Program.type_Logical)
          elseIf (this.is_optional and this.element_type.is_primitive)
            return not (this.element_type is Program.type_Logical xor other.element_type is Program.type_Logical)
          endIf
        endIf
      endIf

      if (this.is_aspect and other is Program.type_Object) return true
      return (this.instance_of(other))

    method is_synchronizable->Logical
      return (attributes.flags & Attribute.is_synchronizable)

    method is_deprecated->Logical
      return (attributes.flags & Attribute.is_deprecated)

    method is_enum->Logical
      return (attributes.flags & Attribute.is_enum)

    method is_real->Logical
      return this is Program.type_Real64 or this is Program.type_Real32

    method is_tuple->Logical
      return name.begins_with("Tuple<<")

    method widening_distance_to( other:Type )->Int32
      if (this is other) return 0
      if (this.is_primitive and other.is_primitive)
        return other.primitive_rank - this.primitive_rank
      endIf
      if (other.is_optional)
        if (other.element_type is this) return 1
        if (this is Program.type_null) return 1
      endIf
      if (this.is_aspect and other is Program.type_Object) return 1

      if (this is Program.type_null and other.is_reference) return 1

      forEach (base_type in base_types)
        if (base_type.instance_of(other)) return 1 + base_type.widening_distance_to( other )
      endForEach

      if (this.is_reference and other is Program.type_Object) return 1

      return -10

    method is_equivalent_or_more_specific_than( other:Type )->Logical
      if (this is other) return true
      if (this.is_primitive and other.is_primitive)
        return this.primitive_rank >= other.primitive_rank
      endIf
      if (this.instance_of(other)) return true
      if (other.is_list and other.element_type is this) return true
      return false

    method is_direct->Logical
      return not is_reference

    method is_abstract->Logical
      return (attributes.flags & Attribute.is_abstract)

    method is_aspect->Logical
      return (attributes.flags & Attribute.type_mask) == Attribute.is_aspect

    method is_class->Logical
      return (attributes.flags & Attribute.type_mask) == Attribute.is_class

    method is_compound->Logical
      return (attributes.flags & Attribute.type_mask) == Attribute.is_compound

    method is_immutable->Logical
      return (attributes.flags & Attribute.is_immutable)

    method is_native->Logical
      return (attributes.flags & Attribute.is_native)

    method is_primitive->Logical
      return (attributes.flags & Attribute.type_mask) == Attribute.is_primitive

    method is_reference->Logical
      which (attributes.flags & Attribute.type_mask)
        case Attribute.is_class, Attribute.is_aspect
          return true
        others
          return false
      endWhich

    method is_api->Logical
      return (attributes.flags & Attribute.is_api)

    method is_essential->Logical
      return (attributes.flags & Attribute.is_essential) or is_api

    method is_nonAPI->Logical
      return (attributes.flags & Attribute.is_nonAPI)

    method is_singleton->Logical
      return (attributes.flags & Attribute.is_singleton)

    method is_special->Logical
      return (attributes.flags & Attribute.is_special)

    method make_api->this
      attributes.add( Attribute.is_api )
      return this

    method make_essential->this
      attributes.add( Attribute.is_essential )
      return this

    method make_synchronizable->this
      attributes.add( Attribute.is_synchronizable )
      return this

    method configure( scope=null:Scope, reference_t=null:Token )->Type
      if (configured) return this
      configured = true
      configure_chain.add( this )

      if (reference_t is null) reference_t = t

      index = Program.type_list.count
      Program.type_list.add( this )

      if (RogueC.all_essential)
        attributes.add( Attribute.is_api )
        attributes.add( Attribute.is_essential )
      endIf

      Program.invoke_metacode( "Type.configure", this )
      Program.invoke_metacode( "$.configure"(name), this )

      if (not is_defined)
        is_defined = true
        local template = Program.find_template( name )
        if (template)
          template.instantiate( this, scope, reference_t )
        else
          throw reference_t.error( "Reference to undefined type '$'." (name) )
        endIf
      endIf

      if (is_enum)
        add_global( t, "names" ).type = Program.get_type_reference( t, "String[]" )
        local g_values = add_global( t, "values" )
        g_values.type = Program.get_type_reference( t, "Int32[]" )
        #g_values.initial_value = CmdAccess( t, "Int32[]" )
        add_property( t, "value", Program.type_Int32 )
      endIf

      local inherited_categories : Definition[]
      use rewriter = base_types.rewriter
        forEach (base_type in rewriter)
          base_type.configure( scope, reference_t )

          if (not base_type.is_aspect)
            if (is_aspect)
              if (aspect_base_class)
                throw t.error( "An aspect can only specify one base class ($ and $ are both specified)." (base_type,aspect_base_class))
              else
                aspect_base_class = base_type
              endIf
            elseIf (is_enum)
              # Inherit category definitions while discarding the base type
              if (not base_type.is_enum)
                throw t.error( "Base type $ is not an enum - an enum can only extend other enums." (base_type.name) )
              endIf

              if (base_type.enum_properties)
                ensure enum_properties
                if (enum_properties.count)
                  # If this extended enum defines properties, make sure they begin with the same
                  # properties as the base enum defines.
                  contingent
                    necessary (enum_properties.count >= base_type.enum_properties.count)
                    forEach (base_p at index in base_type.enum_properties)
                      local this_p = enum_properties[ index ]
                      necessary (this_p.name == base_p.name and this_p.type.instance_of(base_p.type))
                    endForEach
                  unsatisfied
                    throw t.error( "Extended enum $ must begin its property declarations with the same properties declared in base enum $." (name,base_type.name))
                  endContingent
                else
                  forEach (base_p in base_type.enum_properties)
                    enum_properties.add( base_p.cloned(this) )
                  endForEach
                endIf
              endIf

              if (base_type.categories)
                ensure inherited_categories( base_type.categories.count )
                inherited_categories.reserve( base_type.categories.count )
                forEach (c in base_type.categories) inherited_categories.add( c.cloned )
              endIf
            elseIf (is_compound)
              throw t.error( "Compounds can only extend aspects." )
            else
              rewriter.write( base_type )
            endIf
          else
            rewriter.write( base_type )
          endIf

          if (base_type is this)
            throw t.error( "Class $ cannot extend itself." (this) )
          endIf

          if (base_type.instance_of(this))
            throw t.error( "Cyclic inheritance attempted - $ cannot extend $ because $ already extends $." ...
                (this,base_type,base_type,this) )
          endIf

          # Inherit [api]
          if (base_type.is_api) attributes.add( Attribute.is_api )
        endForEach
      endUse

      if (inherited_categories)
        ensure categories
        inherited_categories.add( categories )
        categories = inherited_categories
      endIf

      if (is_class)
        collect_aspect_base_classes

        forEach (base_type in base_types)
          if (base_type.is_class)
            if (base_class and base_class is not base_type)
              throw t.error( "Class $ can only have one base class ($ and $ are both specified as base classes)." (name,base_class,base_type) )
            else
              base_class = base_type
            endIf
          endIf
        endForEach

        if (not base_class and this is not Program.type_Object)
          # Use Object
          Program.type_Object.configure( &=reference_t )
          base_class = Program.type_Object
          base_types.insert( base_class )
        endIf

        if (base_class)
          base_types.insert( base_types.remove(base_class) )
          if (base_class.is_synchronizable)
            make_synchronizable
          endIf
        endIf
        forEach (m in method_list)
          if (m.is_synchronized)
            make_synchronizable
            escapeForEach
          endIf
        endForEach

        if (is_topmost_synchronizable and RogueC.thread_mode != ThreadMode.NONE)
          # We need to add the synchronization type
          add_property( t, "_object_mutex", Program.type_NativeLock )
        endIf
      endIf

      # Mark classes that are extended
      forEach (base_type in base_types)
        base_type.extended_types.add( this )
      endForEach

      local reset_ref_t = (not name.contains("[]") and not name.contains("<<"))
      # If A uses B uses C, A sends its reference token in while resolving referenced types.
      # The reference token will be reset to reference any class along the way that is not a list or template.

      if (element_type)            element_type.configure( &=reference_t )
      forEach (p in global_list)   p.type.configure( &reference_t=which{ reset_ref_t:p.t || reference_t} )
      forEach (p in property_list) p.type.configure( &reference_t=which{ reset_ref_t:p.t || reference_t} )

      Program.invoke_metacode( "Type.configured", this )
      Program.invoke_metacode( "$.configured"(name), this )

      configure_chain.remove_last
      return this

    method organize_enum( scope:Scope )
      # create(Int32)
      local m_create = add_global_method( t, "create" )
      m_create.attributes.add( Attribute.is_generated )
      m_create.return_type = this
      m_create.add_parameter( t, "value", Program.type_Int32 )
      m_create.organize

      ensure categories

      local category_scope = Scope( this, m_create )

      # First turn categories into integer definitions
      local g_values = global_lookup//values
      local cmd_literal_list = CmdTypedLiteralList( CmdAccess(t,"Int32[]") )
      g_values.initial_value = cmd_literal_list

      local cur_value = 0
      forEach (def in categories)
        if (def.expression)
          def.expression = def.expression.resolve( category_scope )
          if (def.expression not instanceOf CmdLiteralInt32)
            throw def.t.error( "Assigned value must resolve to a literal Int32." )
          endIf
          cur_value = (def.expression as CmdLiteralInt32).value
          def.value = cur_value
        else
          def.value = cur_value
          def.expression = CmdLiteralInt32( t, cur_value )
        endIf

        if (definition_lookup.contains(def.name))
          throw def.t.error( ''A category named "$" already exists.'' (def.name) )
        endIf

        definition_lookup[ def.name ] = def
        definition_list.add( def )

        cmd_literal_list.elements.add( CmdLiteralInt32(t,def.value) )

        ++cur_value
      endForEach

      # Make a second pass and replace the integer value definitions with EnumType(value)
      # constructors.
      forEach (def in categories)
        def.expression = CmdAccess( t, name, def.expression )
      endForEach

      block
        local def = Definition( t, "count", CmdLiteralInt32(t,categories.count) )
        definition_lookup[ def.name ] = def
        definition_list.add( def )
      endBlock

      block
        # create(String)
        local m_create_with_name = add_global_method( t, "create" )
        m_create_with_name.add_parameter( t, "name", Program.type_String )
        m_create_with_name.return_type = this
        local cmd_which = CmdWhich( t, CmdAccess(t,"name") )
        m_create_with_name.statements.add( cmd_which )
        forEach (def in categories)
          local cmd_case = cmd_which.add_case( def.t )
          cmd_case.conditions.add( CmdLiteralString(def.t,def.name) )
          cmd_case.statements.add( CmdReturn(def.t,CmdAccess(def.t,name,CmdLiteralInt32(def.t,def.value))) )
        endForEach
        local cmd_others = cmd_which.add_case_others( t )
        if (categories.count)
          cmd_others.statements.add( CmdReturn(t,CmdAccess(t,name,CmdLiteralInt32(t,categories.first.value))) )
        else
          cmd_others.statements.add( CmdReturn(t,CmdAccess(t,name,CmdLiteralInt32(t,0))) )
        endIf
        m_create_with_name.organize( scope )
      endBlock

      block
        # get(Int32)->ThisType
        local m_get = add_global_method( t, "get" )
        m_get.add_parameter( t, "index", Program.type_Int32 )
        m_get.return_type = this
        local cmd_which = CmdWhich( t, CmdAccess(t,"index") )
        m_get.statements.add( cmd_which )
        forEach (def at index in categories)
          local cmd_case = cmd_which.add_case( def.t )
          cmd_case.conditions.add( CmdLiteralInt32(def.t,index) )
          cmd_case.statements.add( CmdReturn(def.t,CmdAccess(def.t,name,CmdLiteralInt32(def.t,def.value))) )
        endForEach
        local cmd_others = cmd_which.add_case_others( t )
        if (categories.count)
          cmd_others.statements.add( CmdReturn(t,CmdAccess(t,name,CmdLiteralInt32(t,categories.first.value))) )
        else
          cmd_others.statements.add( CmdReturn(t,CmdAccess(t,name,CmdLiteralInt32(t,0))) )
        endIf
        m_get.organize( scope )
      endBlock

      block
        # index()->Int32?
        local m_index = add_method( t, "index" )
        m_index.attributes.add( Attribute.is_generated )
        m_index.return_type = Program.get_type_reference( t, "Int32?" )
        m_index.statements.add( CmdReturn( t, CmdAccess( t, "names", "locate", CmdAccess(t,"to_String")) ) )
        m_index.organize( scope )
      endBlock

      block
        # name()->String
        local m_name = add_method( t, "name" )
        m_name.attributes.add( Attribute.is_generated )
        m_name.return_type = Program.get_type_reference( t, "String" )
        m_name.statements.add( CmdReturn( t, CmdAccess(t,"to_String")) )
        m_name.organize( scope )
      endBlock

      if (not has_method_named( "operator+" ))
        # operator+(Int32)->ThisType
        local m_plus = add_method( t, "operator+" )
        m_plus.attributes.add( Attribute.is_generated )
        m_plus.add_parameter( t, "offset", Program.type_Int32 )
        m_plus.return_type = this
        m_plus.statements.add( CmdReturn(t,CmdAccess(t,name,
          CmdAdd(t,CmdAccess(t,"value"),CmdAccess(t,"offset"))
        )) )
        m_plus.organize( scope )

        # operator+(ThisType)->ThisType
        m_plus = add_method( t, "operator+" )
        m_plus.attributes.add( Attribute.is_generated )
        m_plus.add_parameter( t, "other", this )
        m_plus.return_type = this
        m_plus.statements.add( CmdReturn(t,CmdAccess(t,name,
          CmdAdd(t,CmdAccess(t,"value"),CmdAccess(t,"other","value"))
        )) )
        m_plus.organize( scope )
      endIf

      if (not has_method_named( "operator-" ))
        # operator-(Int32)->ThisType
        local m_minus = add_method( t, "operator-" )
        m_minus.attributes.add( Attribute.is_generated )
        m_minus.add_parameter( t, "offset", Program.type_Int32 )
        m_minus.return_type = this
        m_minus.statements.add( CmdReturn(t,CmdAccess(t,name,
          CmdSubtract(t,CmdAccess(t,"value"),CmdAccess(t,"offset"))
        )) )
        m_minus.organize( scope )

        # operator-(ThisType)->ThisType
        m_minus = add_method( t, "operator-" )
        m_minus.attributes.add( Attribute.is_generated )
        m_minus.add_parameter( t, "other", this )
        m_minus.return_type = this
        m_minus.statements.add( CmdReturn(t,CmdAccess(t,name,
          CmdSubtract(t,CmdAccess(t,"value"),CmdAccess(t,"other","value"))
        )) )
        m_minus.organize( scope )
      endIf

      if (not has_method_named( "operator%" ))
        # operator%(Int32)->ThisType
        local m_op = add_method( t, "operator%" )
        m_op.attributes.add( Attribute.is_generated )
        m_op.add_parameter( t, "n", Program.type_Int32 )
        m_op.return_type = this
        m_op.statements.add( CmdReturn(t,CmdAccess(t,name,
          CmdMod(t,CmdAccess(t,"value"),CmdAccess(t,"n"))
        )) )
        m_op.organize( scope )

        # operator%(ThisType)->ThisType
        m_op = add_method( t, "operator%" )
        m_op.attributes.add( Attribute.is_generated )
        m_op.add_parameter( t, "other", this )
        m_op.return_type = this
        m_op.statements.add( CmdReturn(t,CmdAccess(t,name,
          CmdMod(t,CmdAccess(t,"value"),CmdAccess(t,"other","value"))
        )) )
        m_op.organize( scope )
      endIf

      if (not has_method_named( "operator|" ))
        # operator|(Int32)->ThisType
        local m_op = add_method( t, "operator|" )
        m_op.attributes.add( Attribute.is_generated )
        m_op.add_parameter( t, "n", Program.type_Int32 )
        m_op.return_type = this
        m_op.statements.add( CmdReturn(t,CmdAccess(t,name,
          CmdBitwiseOr(t,CmdAccess(t,"value"),CmdAccess(t,"n"))
        )) )
        m_op.organize( scope )

        # operator|(ThisType)->ThisType
        m_op = add_method( t, "operator|" )
        m_op.attributes.add( Attribute.is_generated )
        m_op.add_parameter( t, "other", this )
        m_op.return_type = this
        m_op.statements.add( CmdReturn(t,CmdAccess(t,name,
        CmdBitwiseOr(t,CmdAccess(t,"value"),CmdAccess(t,"other","value"))
        )) )
        m_op.organize( scope )
      endIf

      if (not has_method_named( "operator&" ))
        # operator&(Int32)->ThisType
        local m_op = add_method( t, "operator&" )
        m_op.attributes.add( Attribute.is_generated )
        m_op.add_parameter( t, "n", Program.type_Int32 )
        m_op.return_type = this
        m_op.statements.add( CmdReturn(t,CmdAccess(t,name,
          CmdBitwiseAnd(t,CmdAccess(t,"value"),CmdAccess(t,"n"))
        )) )
        m_op.organize( scope )

        # operator&(ThisType)->ThisType
        m_op = add_method( t, "operator&" )
        m_op.attributes.add( Attribute.is_generated )
        m_op.add_parameter( t, "other", this )
        m_op.return_type = this
        m_op.statements.add( CmdReturn(t,CmdAccess(t,name,
        CmdBitwiseAnd(t,CmdAccess(t,"value"),CmdAccess(t,"other","value"))
        )) )
        m_op.organize( scope )
      endIf

      if (not has_method_named( "operator~" ))
        # operator~(Int32)->ThisType
        local m_op = add_method( t, "operator~" )
        m_op.attributes.add( Attribute.is_generated )
        m_op.add_parameter( t, "n", Program.type_Int32 )
        m_op.return_type = this
        m_op.statements.add( CmdReturn(t,CmdAccess(t,name,
          CmdBitwiseXor(t,CmdAccess(t,"value"),CmdAccess(t,"n"))
        )) )
        m_op.organize( scope )

        # operator~(ThisType)->ThisType
        m_op = add_method( t, "operator~" )
        m_op.attributes.add( Attribute.is_generated )
        m_op.add_parameter( t, "other", this )
        m_op.return_type = this
        m_op.statements.add( CmdReturn(t,CmdAccess(t,name,
        CmdBitwiseXor(t,CmdAccess(t,"value"),CmdAccess(t,"other","value"))
        )) )
        m_op.organize( scope )
      endIf

      if (not has_method_named( "operator!" ))
        # operator!()->ThisType
        local m_op = add_method( t, "operator!" )
        m_op.attributes.add( Attribute.is_generated )
        m_op.return_type = this
        m_op.statements.add( CmdReturn(t,CmdAccess(t,name,
          CmdBitwiseNot(t,CmdAccess(t,"value"))
        )) )
        m_op.organize( scope )
      endIf

      block
        # names()->String[]
        local m_names = add_global_method( t, "names" )
        m_names.attributes.add( Attribute.is_generated )
        m_names.return_type = Program.get_type_reference( t, "String[]" )
        local names_list_args = CmdArgs()
        forEach (def in categories)
          names_list_args.add( CmdLiteralString(def.t,def.name) )
        endForEach
        local cmd_if = CmdIf( t, CmdLogicalNot(t,CmdAccess(t,"@names")) )
        local list_declaration = CmdAccess( t, "String[]" )
        cmd_if.statements.add( CmdAssign(t, CmdAccess(t,"names"), CmdTypedLiteralList(list_declaration,names_list_args)) )
        m_names.statements.add( cmd_if )
        m_names.statements.add( CmdReturn(t,CmdAccess(t,"@names")) )
        m_names.organize( scope )
      endBlock

      if (not has_method_named( "contains" ))
        # contains(String)->Logical
        local m_contains = add_global_method( t, "contains" )
        m_contains.return_type = Program.type_Logical
        m_contains.add_parameter( t, "name", Program.type_String )
        m_contains.statements.add( CmdReturn( t,
            CmdAccess( t, CmdAccess(t,"names","locate",CmdAccess(t,"name")), "exists" ) ) )
        m_contains.organize( scope )
      endIf

      block
        # hash_code()->Int32
        local m_hash_code = add_method( t, "hash_code" )
        m_hash_code.attributes.add( Attribute.is_generated )
        m_hash_code.return_type = Program.type_Int32
        m_hash_code.statements.add( CmdReturn(t,CmdAccess(t,"value")) )
        m_hash_code.organize( scope )
      endBlock

      block
        # to->Int32
        local m_to_Int32 = add_method( t, "to_Int32" )
        m_to_Int32.attributes.add( Attribute.is_generated )
        m_to_Int32.return_type = Program.type_Int32
        m_to_Int32.statements.add( CmdReturn(t,CmdAccess(t,"value")) )
        m_to_Int32.organize( scope )
      endBlock

      block
        # to->Logical
        local m_to_Logical = add_method( t, "to_Logical" )
        m_to_Logical.attributes.add( Attribute.is_generated )
        m_to_Logical.return_type = Program.type_Logical
        m_to_Logical.statements.add( CmdReturn(t,CmdLogicalize(t,CmdAccess(t,"value"))) )
        m_to_Logical.organize( scope )
      endBlock

      block
        # description->String
        local m_description = add_method( t, "description" )
        m_description.attributes.add( Attribute.is_generated )
        m_description.return_type = Program.type_String
        if (categories.is_empty)
          m_description.statements.add( CmdReturn(t,CmdLiteralString(t,name)) )
        else
          local cmd_which = CmdWhich( t, CmdAccess(t,"value") )
          m_description.statements.add( cmd_which )
          local handled_cases = Set<<Int32>>()
          forEach (def in categories)
            if (not handled_cases.contains(def.value))
              handled_cases.add( def.value )
              local cmd_case = cmd_which.add_case( def.t )
              cmd_case.conditions.add( CmdLiteralInt32(def.t,def.value) )
              cmd_case.statements.add( CmdReturn(def.t,CmdLiteralString(def.t,def.name)) )
            endIf
          endForEach
          local cmd_others = cmd_which.add_case_others( t )
          cmd_others.statements.add( CmdReturn(t,CmdLiteralString(t,"(undefined)")) )
        endIf
        m_description.organize( scope )
      endBlock

      block
        # to->String
        local m_to_String = add_method( t, "to_String" )
        m_to_String.attributes.add( Attribute.is_generated )
        m_to_String.return_type = Program.type_String
        m_to_String.statements.add( CmdReturn(t,CmdAccess(t,"description")) )
        m_to_String.organize( scope )
      endBlock

      # Slice:
      #   enum EnumName(a:A,b:B)
      #     ALPHA(1,2)
      #     BETA(3,4)
      #
      # into:
      #   enum EnumName
      #     CATEGORIES
      #       ALPHA, BETA
      #     METHODS
      #       method a->A
      #         which (this)
      #           case ALPHA: 1
      #           case BETA:  2
      #   ...
      #
      if (enum_properties)
        forEach (def in categories)
          ensure def.args( enum_properties.count )
          forEach (arg at index in def.args)
            if (arg is null)
              # Null values passed in when dev skips expression and writes comma
              local sub = enum_properties[ index ]
              if (sub.initial_value is null)
                throw def.t.error( "Missing $ property argument; no default specified for '$'." ((index+1).th,sub.name) )
              endIf
            endIf
          endForEach
          while (def.args.count < enum_properties.count)
            local i = def.args.count
            local sub = enum_properties[ def.args.count ]
            if (sub.initial_value is null)
              throw def.t.error( "Missing $ property argument; no default specified for '$'." ((i+1).th,sub.name) )
            endIf
            def.args.add( sub.initial_value.cloned )
          endWhile
          if (def.args.count > enum_properties.count)
            throw def.args[ enum_properties.count ].t.error(
              "More property arguments ($) than enum properties ($)." (def.args.count,enum_properties.count) )
          endIf
        endForEach

        forEach (sub at index in enum_properties)
          local m = find_method( sub.name + "()" )
          if (not m)
            local w = CmdWhich( t, CmdAccess(t,"value") )
            forEach (def in categories)
              local value = def.args[index]
              if (value)
                w.add_case( def.t, CmdLiteralInt32(def.t,def.value), CmdReturn(def.t,value) )
              endIf
            endForEach
            local default_value = ?:{ sub.initial_value:sub.initial_value.cloned || sub.type.create_default_value(sub.t) }
            w.add_case_others( sub.t, CmdReturn(sub.t,default_value) )

            # property()->PropertyType
            m = add_method( sub.t, sub.name )
            m.return_type = sub.type
            m.statements.add( w )
            m.organize( scope )
          endIf
        endForEach

      endIf


    method organize( scope=null:Scope, reference_t=null:Token )->Type
      if (organized) return this
      organize_chain.add( this )
      organized = true
      organizing = true

      if (reference_t is null) reference_t = t

      configure( &=reference_t )

      Program.invoke_metacode( "Type.organize", this )
      Program.invoke_metacode( "$.organize"(name), this )

      forEach (base_type in base_types)
        base_type.organize( scope, reference_t )
      endForEach

      if (this is not Program.type_Object) Program.type_Object.organize

      # Inherit definitions
      forEach (base_type in base_types)
        inherit_definitions( base_type )
      endForEach

      # Inherit properties
      local full_property_list = Property[]
      property_lookup.clear
      inherit_properties( full_property_list, property_lookup )
      property_list = full_property_list

      Program.invoke_metacode( "Type.organize_properties", this )
      Program.invoke_metacode( "$.organize_properties"(name), this )

      create_introspection_methods( scope )

      inherit_methods( scope )

      # Clear base_types list for compounds - they can incorporate aspects for
      # modularization but compounds are not polymorphic.
      if (this.is_compound) base_types.clear

      if (is_enum) organize_enum( scope )

      # Mark any existing init_class() as essential
      local m_init_class = find_global_method( "init_class()" )
      if (m_init_class)
        if (m_init_class.type_context is this)
          m_init_class.make_essential
        endIf
      else
        m_init_class = find_method( "init_class()" )
        if (m_init_class)
          throw m_init_class.t.error( "$::init_class() must be declared under GLOBAL METHODS." (name) )
        endIf
      endIf

      # Mark any existing init_class_thread_local() as essential
      local m_init_class_thread_local = find_global_method( "init_class_thread_local()" )
      if (m_init_class_thread_local)
        if (m_init_class_thread_local.type_context is this)
          m_init_class_thread_local.make_essential
        endIf
      else
        m_init_class_thread_local = find_method( "init_class_thread_local()" )
        if (m_init_class_thread_local)
          throw m_init_class_thread_local.t.error( "$::init_class_thread_local() must be declared under GLOBAL METHODS." (name) )
        endIf
      endIf

      if (global_list.count)
        # We may or may not need init_class or init_class_thread_local to initialize global properties
        local needs_ic = false
        local needs_tl = false
        local is_android = RogueC.compile_targets[ "Android" ]
        # Android .so libraries persist between runs so Android needs to be able to reset all global state on launch.
        # Thus we force an explicit initialization of even default values.
        forEach (s in global_list)
          if (s.initial_value or is_android)
            if (s.is_thread_local)
              needs_tl = true
            else
              needs_ic = true
            endIf
            if (needs_tl and needs_ic) escapeForEach
          endIf
        endForEach

        if (needs_tl or needs_ic)
          local m,mtl : Method

          if (needs_ic)
            # Create or locate init_class() to initialize global properties
            m = find_global_method( "init_class()" )
            if (not m or m.type_context is not this) m = add_global_method( t, "init_class" ).organize( scope )
            m.make_essential
          endIf
          if (needs_tl)
            mtl = find_global_method( "init_class_thread_local()" )
            if (not mtl or mtl.type_context is not this) mtl = add_global_method( t, "init_class_thread_local" ).organize( scope )
            mtl.make_essential
          endIf

          # Insert global initializations
          local i = global_list.count - 1
          while (i >= 0)
            local s = global_list[i]
            if (s.initial_value)
              if (s.is_thread_local)
                mtl.statements.insert( CmdWriteGlobal(s.t, s, s.initial_value.cloned) )
              else
                m.statements.insert( CmdWriteGlobal(s.t, s, s.initial_value.cloned) )
              endIf
            elseIf (is_android)
              if (s.is_thread_local)
                mtl.statements.insert( CmdWriteGlobal(s.t, s, s.type.create_default_value(s.t)) )
              else
                m.statements.insert( CmdWriteGlobal(s.t, s, s.type.create_default_value(s.t)) )
              endIf
            endIf
            --i
          endWhile
        endIf
      endIf

      # Create or find init_object() method to initialize properties
      if (is_class and not is_native)
        local m = find_method( "init_object()" )
        local prior_m = m
        if (m and m.type_context is this)
          m.make_essential
        else
          m = add_method( t, "init_object" ).organize( scope )
          m.make_essential

          # The regular system won't figure out that init_object() is
          # dynamically called so give it a flag.
          m.attributes.add( Attribute.is_dynamic )

          if (prior_m)
            method_list.remove( m )
            method_list[ method_list.locate( prior_m ).value ] = m
            method_lookup_by_name[ m.name ].remove( prior_m )
            method_lookup_by_signature[ m.signature ] = m
            m.overridden_method = prior_m
            prior_m.overriding_methods.add( m )
          endIf
        endIf
        m.return_type = this

        # Insert property initializations
        local i = property_list.count - 1
        while (i >= 0)
          local p = property_list[i]
          if (p.is_thread_local)
            throw p.t.error( "only global properties can be thread local." )
          endIf
          if (p.initial_value and p.type_context is this)
            m.statements.insert( CmdWriteProperty(p.t, CmdLiteralThis(p.t,p.type_context), p, p.initial_value.cloned) )
          endIf
          --i
        endWhile

        # Insert prior.init_object()
        if (m.overridden_method)
          m.statements.insert( CmdCallPriorMethod(t, "init_object", null, null) )
        endIf

        # Append return this
        m.statements.add( CmdReturn(t,CmdLiteralThis(t,this)) )

        # Add synchronization object initialization if required
        if (is_topmost_synchronizable)
          m.statements.insert( CmdSyncObjectInit(t) )
        endIf

        m.statements.dispatch( UpdateThisTypeVisitor(this,m) )
      endIf

      # Mark any on_cleanup() method as essential
      if (is_class and not is_native)
        local m = find_method( "on_cleanup()" )
        local prior_m = m
        if (m and m.type_context is this)
          if (m.return_type)
            throw m.t.error( "on_cleanup() cannot return a value." )
          endIf
          m.make_essential
        elseIf (is_topmost_synchronizable)
          m = add_method( t, "on_cleanup" ).organize( scope )
          m.make_essential

          # The regular system won't figure out that on_cleanup() is
          # dynamically called so give it a flag.
          m.attributes.add( Attribute.is_dynamic )

          if (prior_m)
            method_list.remove( m )
            method_list[ method_list.locate( prior_m ).value ] = m
            method_lookup_by_name[ m.name ].remove( prior_m )
            method_lookup_by_signature[ m.signature ] = m
            m.overridden_method = prior_m
            prior_m.overriding_methods.add( m )
          endIf

          # Insert prior.on_cleanup()
          if (m.overridden_method)
            m.statements.insert( CmdCallPriorMethod(t, "on_cleanup", null, null) )
          endIf
          m.statements.insert( CmdSyncObjectCleanup(t) )

          m.statements.dispatch( UpdateThisTypeVisitor(this,m) )
        endIf
      endIf

      # to->String is essential for Exception and extended classes
      if (is_class and instance_of(Program.type_Exception))
        local m = find_method( "to_String()" )
        if (m) m.make_essential
      endIf

      # Add a default description->String to compounds
      if ((is_compound or is_primitive) and this is not Program.type_NativeLock)
        local m = find_method( "description()" )
        if (not m)
          m = add_method( t, "description" )
          m.return_type = Program.type_String
          m.statements.add( CmdReturn(t,CmdLiteralString(t,"($)"(name))) )
          m.organize( scope )
        endIf
      endIf

      # Add a default to->String to compounds
      if ((is_compound or is_primitive) and this is not Program.type_NativeLock)
        local m = find_method( "to_String()" )
        if (not m)
          m = add_method( t, "to_String" )
          m.return_type = Program.type_String
          m.statements.add( CmdReturn(t,CmdAccess(t,"description")) )
          m.organize( scope )
        endIf

      endIf


      # Add a default global from_value(Value) to compounds and classes
      if (is_compound)
        local m = find_global_method( "from_value(Value)" )
        if (not m)
          m = add_global_method( t, "from_value" )
          m.attributes.add( Attribute.is_nonAPI )
          m.add_parameter( t, "value", Program.type_Value )
          m.return_type = this

          local boxed_type = Program.get_type_reference( t, "Boxed<<$>>" (name) )

          # if (value.is_object and value->Object instanceOf Boxed<<CompoundType>>)
          #   return value->Object as Boxed<<CompoundType>>->CompoundType
          # endIf
          local cmd_lhs = CmdConvertToType( t, CmdAccess(t,"value"), Program.type_Object ) : Cmd
          local cmd_rhs = CmdInstanceOf( t, cmd_lhs, boxed_type )
          local cmd_condition = CmdLogicalAnd( t, CmdAccess( t, "value", "is_object" ), cmd_rhs )
          local cmd_if = CmdIf( t, cmd_condition )

          local cmd_return = CmdConvertToType( t, CmdAccess(t,"value"), Program.type_Object ) : Cmd
          cmd_return = CmdAs( t, cmd_return, boxed_type )
          cmd_return = CmdConvertToType( t, cmd_return, this )
          cmd_if.statements.add( CmdReturn(t,cmd_return) )

          m.statements.add( cmd_if )

          # return CompoundType(args)
          local args = CmdArgs()
          forEach (p in property_list)
            if (not p.is_native)
              local arg = CmdAccess( t, "value", "get", CmdArgs(CmdLiteralString(t,p.name)) )
              if (p.type is Program.type_String)
                args.add( CmdAccess( t, arg, "to_String" ) )
              elseIf (p.type.is_reference)
                args.add( CmdAs( t, CmdAccess(t,arg,"to_Object"), p.type ) )
              elseIf (p.type.is_primitive)
                args.add( CmdAccess(t,p.type.name,CmdArgs(arg)) )
              else
                # compound
                args.add( CmdAccess(t,p.type.name,"from_value",CmdArgs(arg)) )
              endIf
            endIf
          endForEach

          m.statements.add( CmdReturn( t, CmdCreateCompound(t,this,args) ) )

          m.organize( scope )
        endIf

      elseIf (is_class)
        local m = find_global_method( "from_value(Value)" )
        if (not m or m.type_context is not this)
          local prior_m = m

          m = add_global_method( t, "from_value" )
          m.attributes.add( Attribute.is_nonAPI )
          m.add_parameter( t, "values", Program.type_Value )
          m.return_type = this

          m.statements.add(
            CmdReturn( t,
              CmdAs( t,
                CmdAccess( t,
                  CmdAccess( t,
                    CmdAccess(t,"TypeInfo"),
                    "get", CmdArgs(CmdLiteralString(t,name))
                  ),
                  "create_object", CmdAccess(t,"values")
                ),
                this
              )
            )
          )

          m.organize( scope )

          if (prior_m)
            global_method_list.remove( m )
            global_method_list[ global_method_list.locate( prior_m ).value ] = m
            global_method_lookup_by_name[ m.name ].remove( prior_m )
            global_method_lookup_by_signature[ m.signature ] = m
          endIf
        endIf

      endIf

      # Add a default to->Object to compounds that returns a Boxed<<CompoundType>>
      if (is_compound)
        local m = find_method( "to_Object()" )
        if (not m)
          m = add_method( t, "to_Object" )
          local boxed_name = "Boxed<<$>>" (name)
          m.return_type = Program.get_type_reference( t, boxed_name )
          m.statements.add( CmdReturn(t,CmdAccess(t,boxed_name,CmdArgs(CmdLiteralThis(t,this)))) )
          m.organize( scope )
        endIf
      endIf

      # Add default operator== to compounds
      if (is_compound)
        if (not find_method("operator==($)" (name)))
          local m = add_method( t, "operator==" )
          m.attributes.add( Attribute.is_generated )
          m.return_type = Program.get_type_reference( t, "Logical" )
          m.add_parameter( t, "other", this )

          forEach (p in property_list)
            if (not p.is_native)
              local cmd_condition = CmdCompareNE( t, CmdAccess(t,p.name), CmdAccess(t,"other",p.name) )
              local cmd_if = CmdIf( t, cmd_condition )
              cmd_if.statements.add( CmdReturn(t,CmdLiteralLogical(t,false)) )
              m.statements.add( cmd_if )
            endIf
          endForEach

          m.statements.add( CmdReturn(t,CmdLiteralLogical(t,true)) )
          m.organize( scope )
        endIf
      endIf

      # Add fallback property getters and setters to aspects
      if (is_aspect)
        forEach (p in property_list)
          local m = find_method( p.name + "()" )
          if (not m)
            m = add_method( p.t, p.name )
            m.attributes.add( Attribute.is_fallback )
            m.return_type = p.type
            m.statements.add( CmdReturn(p.t,CmdAccess(p.t,"@"+p.name)) )
            m.organize( scope )
          endIf

          m = find_method( "set_$($)" (p.name,p.type) )
          if (not m)
            m = add_method( p.t, "set_" + p.name )
            m.add_parameter( p.t, "@"+p.name )
            m.attributes.add( Attribute.is_fallback )
            m.organize( scope )
          endIf
        endForEach
      endIf

      if (this is not Program.type_Array)
        is_array = this.instance_of( Program.type_Array )
        if (is_array)
          local cur_type = this
          while (not cur_type.name.begins_with("Array<<"))
            cur_type = cur_type.base_class
            if (cur_type is null) throw t.error( "A class that is instanceOf Array must also be instanceOf Array<<DataType>>." )
          endWhile

          local element_type_name = cur_type.name.after_first("<<").before_last(">>")
          element_type = Program.get_type_reference( t, element_type_name ).organize( scope )
        endIf
      endIf

      index_methods( global_method_list )
      index_methods( method_list )

      Program.invoke_metacode( "Type.organized", this )
      Program.invoke_metacode( "$.organized"(name), this )

      organizing = false

      organize_chain.remove_last
      return this

    method primitive_rank->Int32
      if (this is Program.type_Real64)    return 7
      if (this is Program.type_Real32)    return 6
      if (this is Program.type_Int64)     return 5
      if (this is Program.type_Int32)     return 4
      if (this is Program.type_Character) return 3
      if (this is Program.type_Byte)      return 2
      if (this is Program.type_Logical)   return 1
      return 0

    method collect_base_types( list:Type[] )
      if (list.contains(this)) return
      list.add( this )
      forEach (base_type in base_types)
        base_type.collect_base_types( list )
      endForEach

    method cull_unused_methods
      if (culled) return
      culled = true

      forEach (base_type in base_types) base_type.cull_unused_methods

      if (not has_extended_class)
        # Don't mess up the slots for extended classes.  No big deal since
        # code isn't actually generated for unused methods; cull_unused_methods()
        # merely prevents some extra 0's in the dynamic call table.

        local i = method_list.count - 1
        while (i >= 0)
          local m = method_list[i]
          if (not m.is_used)
            if (not base_class or base_class.method_list.count <= i)
              method_list.remove( m )
            endIf
          endIf
          --i
        endWhile
      endIf

      forEach (m at i in method_list) m.index = i

    method has_global_references->Logical
      forEach (g in global_list)
        if (g.type.is_reference) return true
        if (g.type.is_compound and g.type.has_object_references) return true
      endForEach

      return false

    method has_object_references->Logical
      # Returns true when:
      # - This class has a property that is a reference
      # - This class is a reference array
      # - This class is a compound array and the compound type contains references

      forEach (p in property_list)
        if (p.type.is_reference) return true
        if (p.type.is_compound and p.type.has_object_references) return true
      endForEach

      return (is_array and element_type.has_object_references)

    method is_reference_array->Logical
      return (is_array and element_type.is_reference)

    method inherit_definitions( from_type:Type )
      forEach (def in from_type.definition_list)
        if (not definition_lookup.contains(def.name))
          definition_list.add( def )
          definition_lookup[ def.name ] = from_type.definition_lookup[ def.name ]
        endIf
      endForEach

      forEach (base_type in from_type.base_types)
        inherit_definitions( base_type )
      endForEach

    method inherit_properties( list:Property[], lookup:Table<<String,Property>> )
      forEach (base_type in base_types)
        forEach (base_p in base_type.property_list)
          inherit_property( base_p, list, lookup )
        endForEach
      endForEach

      forEach (p in property_list)
        inherit_property( p, list, lookup )
      endForEach

    method inherit_property( p:Property, list:Property[], lookup:Table<<String,Property>> )
      local existing_p = lookup[ p.name ]
      if (existing_p)
        local i = list.locate( existing_p ).value

        if (p.type_context is existing_p.type_context and not p.is_incorporated and not existing_p.is_incorporated)
          throw p.t.error( ''A property named "$" already exists.'' (p.name) )
        else
          if (p.type is existing_p.type)
            if (p.initial_value)
              if (existing_p.initial_value)
                if (p.type.instance_of(existing_p.type))
                  # Use the new declaration with its updated initial value
                  if (p.type_context.is_aspect)
                    p = p.cloned.set_type_context( this )
                    p.mark_incorporated
                  endIf
                  list[i] = p
                  lookup[p.name] = p
                else
                  throw p.t.error( ''Conflicting initial values are given for property "$" in unrelated types $ and $.'' ...
                      (p.name,p.type_context,existing_p.type_context) )
                endIf
              else
                # Use newer property with its existing value instead of old property without a value
                if (p.type_context.is_aspect)
                  p = p.cloned.set_type_context( this )
                  p.mark_incorporated
                endIf
                list[i] = p
                lookup[p.name] = p
              endIf

              # Else either the original property is the one with the initial value or neither of them
              # has an initial value.  In either case leave the original property definition as the one
              # in the list.
            endIf
          else
            throw p.t.error( ''Conflicting types given for property "$" - $:$ in $ and $:$ in $.'' ...
              (p.name,p.name,p.type,p.type_context,p.name,existing_p.type,existing_p.type_context) )
          endIf
        endIf

      else
        if (p.type_context.is_aspect)
          p = p.cloned.set_type_context( this )
          p.mark_incorporated
        endIf
        list.add( p )
        lookup[p.name] = p
      endIf

    method create_introspection_methods( scope:Scope )
      if (this is Program.type_NativeLock) return # Don't introspect NativeLock

      # Create type_name() method
      local m_type_name = add_method( t, "type_name" )
      m_type_name.return_type = Program.type_String
      m_type_name.statements.add( CmdReturn( t, CmdLiteralString(t,name) ) )

      if (this.is_compound or this.is_primitive)
        local m_type_info = add_method( t, "type_info" )
        m_type_info.attributes.add( Attribute.is_nonAPI )
        m_type_info.return_type = Program.get_type_reference( t, "TypeInfo" )
        m_type_info.statements.add( CmdReturn( t, CmdAccess( t, CmdAccess(t,"TypeInfo"), "get",
          CmdArgs(CmdLiteralString(t,name)) ) ) )
      endIf

    method inherit_methods( scope=null:Scope )
      # Inherit method templates
      forEach (base_type in base_types)
        method_templates.inherit( base_type.method_templates )
      endForEach

      # Organize methods and create signatures
      forEach (m in global_method_list)
        m.organize( scope )
      endForEach

      forEach (m in method_list)
        m.organize( scope )
      endForEach

      global_method_lookup_by_signature.clear
      global_method_lookup_by_name.clear
      method_lookup_by_signature.clear
      method_lookup_by_name.clear

      # Inherit methods and global methods
      local full_routine_list = Method[]
      inherit_global_methods( full_routine_list, global_method_lookup_by_signature )
      global_method_list = full_routine_list
      forEach (r in global_method_list)
        local list = global_method_lookup_by_name[r.name]
        if (not list)
          list = Method[]
          global_method_lookup_by_name[r.name] = list
        endIf
        list.add( r )
      endForEach

      local full_method_list = Method[]
      inherit_methods( full_method_list, method_lookup_by_signature )
      method_list = full_method_list
      forEach (m in method_list)
        local list = method_lookup_by_name[m.name]
        if (not list)
          list = Method[]
          method_lookup_by_name[m.name] = list
        endIf
        list.add( m )
      endForEach

      # Let metacode add or modify methods
      Program.invoke_metacode( "Type.organize_methods", this )
      Program.invoke_metacode( "$.organize_methods"(name), this )

      # Attempt to instantiate our own overrides of any method templates.
      if (method_templates)
        forEach (m in method_list)
          if (m.type_context is not this)
            local st = m.source_template
            if (st)
              method_templates.instantiate( st.name, st.type_parameters.count, st.t, m.name, null )
            endIf
          endIf
        endForEach
      endIf

      # Ensure that non-abstract classes do not contain abstract methods
      check_abstract_methods( method_list )
      check_abstract_methods( global_method_list )

    method check_abstract_methods( list:Method[] )
      if (is_abstract or is_aspect) return
      forEach (m in list)
        if (m.is_abstract)
          throw t.error( "Class $ does not supply a concrete definition for abstract method $.  Either mark the class [abstract] or define the method." (name,m.signature) )
        endIf
      endForEach

    method inherit_methods( list:Method[], lookup:Table<<String,Method>> )
      forEach (base_type in base_types)
        forEach (base_m in base_type.method_list)
          inherit_method( base_m, list, lookup )
        endForEach
      endForEach

      forEach (m in method_list)
        inherit_method( m, list, lookup )
      endForEach

    method inherit_method( m:Method, list:Method[], lookup:Table<<String,Method>> )->Method
      local existing_m = global_method_lookup_by_signature[ m.signature ]
      if (existing_m)
        throw m.t.error( "A global method already exists with signature $." (m.signature) )
      endIf

      existing_m = lookup[ m.signature ]
      if (existing_m)
        if (m.return_type is not existing_m.return_type)
          contingent
            sufficient (m.name == "init_object")  # return type will be fixed later

            necessary (m.return_type)
            necessary (existing_m.return_type)

            sufficient (m.return_type.instance_of(existing_m.return_type))

            # Make sure both return types are organized and try one more time.
            # We don't do this to begin with to avoid instantiating types that aren't actually
            # used.
            m.return_type.organize
            existing_m.return_type.organize
            sufficient (m.return_type.instance_of(existing_m.return_type))

            # An aspect method returning this that is apparently overriding a this-type method
            # will ultimately be treated as an overridden method instead.
            sufficient (m.type_context.is_aspect and m.returns_this and
              existing_m.return_type.instance_of(m.return_type) and existing_m.type_context is this)

            necessary (false)

          unsatisfied
            throw m.t.error( "In $.$ the overridden return type ($) is not compatible with the prior definition return type ($)." (m.type_context.name, m.signature,m.return_type,existing_m.return_type) )
          endContingent
        endIf

        if (existing_m.is_macro xor m.is_macro)
          if (m.is_macro) throw existing_m.t.error( "A macro method cannot override an existing non-macro method." )
          else            throw existing_m.t.error( "Macro methods cannot be overridden by a non-macro method." )
        endIf

        local i = list.locate( existing_m ).value

        if (not existing_m.is_incorporated)
          if (m.type_context is existing_m.type_context)
            if (m.is_augment)
              apply_augment_labels( m, existing_m )
              return m
            elseIf (existing_m.is_propagated)
              # Replace propagated method with this "overriding" method
              existing_m.attributes.flags &= !Attribute.is_propagated
              existing_m.statements = m.statements
              return existing_m
            else
              throw m.t.error( "Type $ already defines method $." (m.type_context,m.signature) )
            endIf
          endIf
        endIf

        if (m.type_context.is_aspect)
          m.overriding_methods.add( existing_m )
          m.add_incorporating_class( this )
          if (m.is_abstract) return m

          m = m.incorporate( this )

        elseIf (m.is_augment)
          m.convert_augment_to_standalone

        endIf

        m.overridden_method = existing_m
        while (m.overridden_method and m.type_context is m.overridden_method.type_context)
          # Make sure that the overridden method is in a different type context - if it's
          # not then we're replacing an aspect method and need to dig down further to get
          # the actual overridden method.
          if (m.overridden_method.overridden_method)
            # Remove the aspect method from the list of overriding methods since it won't
            # be reachable or resolved otherwise.
            m.overridden_method.overridden_method.overriding_methods.remove( m.overridden_method )
          endIf
          m.overridden_method = m.overridden_method.overridden_method
        endWhile
        if (m.overridden_method)
          m.overridden_method.overriding_methods.add( m )
        endIf

        # Inherit select attributes
        if (existing_m.is_essential) m.make_essential

        list[i] = m
        lookup[m.signature] = m
        m = override_inherited_propagated_method( m, list, lookup )

      else
        # No existing method
        if (m.type_context.is_aspect)
          m.add_incorporating_class( this )
          m = m.incorporate( this )
          m.statements.dispatch( UpdateThisTypeVisitor(this,m) )
        elseIf (m.is_augment)
          m.convert_augment_to_standalone
        endIf

        list.add( m )
        lookup[m.signature] = m
        m = override_inherited_propagated_method( m, list, lookup )

      endIf

      return m

    method override_inherited_propagated_method( m:Method, list:Method[], lookup:Table<<String,Method>> )->Method
      if (m.is_propagated and m.type_context is not this)
        # Override a copy of the method which will have the correct 'this' context.
        m = m.cloned( &skip_body ).set_type_context( this )

        # Re-parse cloned method from source tokens, which will update 'ThisType'
        require m.source_tokens
        local parser = Parser( m.source_tokens, &skip_reprocess )
        parser.this_type = m.type_context
        parser.this_method = m
        parser.parse_method_body

        inherit_method( m, list, lookup )
      endIf
      return m

    method inherit_global_methods( list:Method[], lookup:Table<<String,Method>> )
      forEach (base_type in base_types)
        forEach (base_m in base_type.global_method_list)
          inherit_global_method( base_m, list, lookup )
        endForEach
      endForEach

      forEach (m in global_method_list)
        inherit_global_method( m, list, lookup )
      endForEach

    method inherit_global_method( m:Method, list:Method[], lookup:Table<<String,Method>> )
      local existing_m = lookup[ m.signature ]

      if (existing_m)
        if (m.type_context is existing_m.type_context)
          if (m.is_augment)
            apply_augment_labels( m, existing_m )
            return
          else
            throw m.t.error( "Type $ already defines global method $." (m.type_context,m.signature) )
          endIf
        endIf

        local i = list.locate( existing_m ).value

        # Global aspect methods can only be incorporated into the aspects themselves
        if (m.type_context.is_aspect and m.type_context is not this) return

        if (m.is_augment)
          m.convert_augment_to_standalone
        endIf

        # New method replaces old method in lookup
        list[i] = m
        lookup[m.signature] = m

      else
        # Global aspect methods can only be incorporated into the aspects themselves
        if (m.type_context.is_aspect and m.type_context is not this) return

        if (m.is_augment)
          m.convert_augment_to_standalone
        endIf

        list.add( m )
        lookup[m.signature] = m
      endIf

    method inject_global_method( m:Method, at_index=null:Int32? )
      if (this.is_aspect) return

      m.organize( &!add_to_lookup )

      local existing_m = find_global_method( m.signature )
      if (existing_m)
        if (m is existing_m)
          if (at_index.value)
            global_method_list.remove( m )
            global_method_list.insert( m, at_index.value )
            forEach (adjust_i in at_index.value..<global_method_list.count) global_method_list[ adjust_i ].index = adjust_i

            forEach (extended_class in extended_types)
              if (extended_class.organized)
                extended_class.inject_global_method( m, at_index )
              endIf
            endForEach
          endIf

        elseIf (m.type_context.instance_of(existing_m.type_context))
          # Our injected method overrides the existing one
          local overrides = existing_m.overriding_methods
          existing_m.overriding_methods = Method[]

          if (at_index.value)
            global_method_list.remove( existing_m )
            global_method_list.insert( existing_m, at_index.value )
            forEach (adjust_i in at_index.value..<global_method_list.count) global_method_list[ adjust_i ].index = adjust_i
          endIf

          inherit_method( m, global_method_list, global_method_lookup_by_signature )

          m.overriding_methods = overrides
          forEach (overriding_m in overrides) overriding_m.overridden_method = m

          global_method_lookup_by_name[m.name].remove( existing_m )
          global_method_lookup_by_name[m.name].add( m )

          forEach (extended_class in extended_types)
            if (extended_class.organized)
              extended_class.inject_global_method( m, at_index )
            endIf
          endForEach

        else
          # The existing method overrides the one we're trying to inject - leave
          # the existing one but set up the links and ensure the indices are correct.
          existing_m.overridden_method = m
          m.overriding_methods.add( existing_m )

          if (at_index.value)
            global_method_list.remove( existing_m )
            global_method_list.insert( existing_m, at_index.value )
            forEach (adjust_i in at_index.value..<global_method_list.count) global_method_list[ adjust_i ].index = adjust_i
          endIf

          forEach (extended_class in extended_types)
            if (extended_class.organized)
              extended_class.inject_global_method( existing_m, at_index )
            endIf
          endForEach
        endIf

      elseIf (at_index.exists)
        inherit_method( m, global_method_list, global_method_lookup_by_signature )
        global_method_list.insert( global_method_list.remove_last, at_index.value )
        forEach (adjust_i in at_index.value..<global_method_list.count) global_method_list[ adjust_i ].index = adjust_i
        (ensure global_method_lookup_by_name[m.name]).add( m )

        if (extended_types.count)
          forEach (extended_class in extended_types)
            if (extended_class.organized)
              extended_class.inject_global_method( m, at_index )
            endIf
          endForEach
        endIf
      else
        m.index = global_method_list.count
        at_index = global_method_list.count
        inherit_method( m, global_method_list, global_method_lookup_by_signature )
        (ensure global_method_lookup_by_name[m.name]).add( m )
        if (extended_types.count)
          forEach (extended_class in extended_types)
            if (extended_class.organized)
              extended_class.inject_global_method( m, at_index )
            endIf
          endForEach
        endIf
      endIf

      if (resolved) Program.methods_requiring_resolve.add( m )

    method injectGlobalMethod [api]
      local t = Program.vm.t
      local src = Program.vm.inject->String
      Program.vm.inject.clear
      local filepath = "$ - Meta:$" (t.filepath,t.line)
      local parser = Parser( t, filepath, src )
      parser.this_type = this
      parser.parse_method( &as_global, &skip_add_to_type )  # sets this_method
      inject_global_method( parser.this_method )
      Program.resolve_pending_methods

    method injectMethod [api]
      local t = Program.vm.t
      local src = Program.vm.inject->String
      Program.vm.inject.clear
      local filepath = "$ - Meta:$" (t.filepath,t.line)
      local parser = Parser( t, filepath, src )
      parser.this_type = this
      parser.parse_method( &skip_add_to_type )  # sets this_method
      inject_method( parser.this_method )
      Program.resolve_pending_methods

    method inject_method( m:Method, at_index=null:Int32? )
      if (this.is_aspect) return
      if (m.is_global) inject_global_method( m, at_index ); return

      m.organize( &!add_to_lookup )

      ensure method_lookup_by_name[m.name]

      local existing_m = find_method( m.signature )
      if (existing_m)
        if (m is existing_m)
          if (at_index.value)
            # Method already exists in class but make sure it's at the correct index
            method_list.remove( m )
            method_list.insert( m, at_index.value )
            forEach (adjust_i in at_index.value..<method_list.count) method_list[ adjust_i ].index = adjust_i

            forEach (extended_class in extended_types)
              if (extended_class.organized)
                extended_class.inject_method( m, at_index )
              endIf
            endForEach
          endIf

        elseIf (m.type_context.instance_of(existing_m.type_context))
          # Our injected method overrides the existing one
          local overrides = existing_m.overriding_methods
          existing_m.overriding_methods = Method[]

          if (at_index.value)
            method_list.remove( existing_m )
            method_list.insert( existing_m, at_index.value )
            forEach (adjust_i in at_index.value..<method_list.count) method_list[ adjust_i ].index = adjust_i
          endIf

          m = inherit_method( m, method_list, method_lookup_by_signature )

          m.overriding_methods = overrides
          forEach (overriding_m in overrides) overriding_m.overridden_method = m

          method_lookup_by_name[m.name].remove( existing_m )
          method_lookup_by_name[m.name].add( m )

          forEach (extended_class in extended_types)
            if (extended_class.organized)
              extended_class.inject_method( m, at_index )
            endIf
          endForEach

        else
          # The existing method overrides the one we're trying to inject - leave
          # the existing one but set up the links and ensure the indices are correct.
          existing_m.overridden_method = m
          m.overriding_methods.add( existing_m )

          if (at_index.value)
            method_list.remove( existing_m )
            method_list.insert( existing_m, at_index.value )
            forEach (adjust_i in at_index.value..<method_list.count) method_list[ adjust_i ].index = adjust_i
          endIf

          forEach (extended_class in extended_types)
            if (extended_class.organized)
              extended_class.inject_method( existing_m, at_index )
            endIf
          endForEach
        endIf

      elseIf (at_index.exists)
        # Method slot does not exist but specific index given
        m = inherit_method( m, method_list, method_lookup_by_signature )
        method_list.insert( method_list.remove_last, at_index.value )
        forEach (adjust_i in at_index.value..<method_list.count) method_list[ adjust_i ].index = adjust_i
        method_lookup_by_name[m.name].add( m )

        if (extended_types.count)
          forEach (extended_class in extended_types)
            if (extended_class.organized)
              extended_class.inject_method( m, at_index )
            endIf
          endForEach
        endIf
      else
        # Method slot does not exist and no index given
        m.index = method_list.count
        at_index = method_list.count
        inherit_method( m, method_list, method_lookup_by_signature )
        method_lookup_by_name[m.name].add( m )
        if (extended_types.count)
          forEach (extended_class in extended_types)
            if (extended_class.organized)
              extended_class.inject_method( m, at_index )
            endIf
          endForEach
        endIf
      endIf

      if (resolved)
        Program.methods_requiring_resolve.add( m )
      endIf

    method apply_augment_labels( aug_m:Method, existing_m:Method )
      # Apply augment to existing method
      local replace_label = aug_m.label_lookup[ "replace" ]
      if (replace_label)
        # Clear base statements and contents of all labels; add <replace> statements to base statements,
        # then proceed normally so that the augment's <insert> will still go in the correct place etc.
        replace_label.is_referenced = true
        existing_m.statements.clear
        forEach (method_label at index in existing_m.label_list)
          method_label.statements.clear
          existing_m.statements.add( method_label )  # put CmdLabel statements back in statements list
          if (index == 0)
            existing_m.statements.add( replace_label.statements )  # <insert>
          endIf
        endForEach
      endIf

      forEach (method_label in existing_m.label_list)
        local aug_label = aug_m.label_lookup[ method_label.name ]
        if (aug_label)
          method_label.statements.add( aug_label.statements )
          aug_label.is_referenced = true
        endIf
      endForEach

      forEach (label in aug_m.label_list)
        if (not label.is_referenced)
          throw label.t.error( "No corresponding label <$> in augmented code." (label.name) )
        endIf
      endForEach

    method index_methods( list:Method[] )
      forEach (m at index in list)
        m.index = index
      endForEach

    method omit_output->Logical
      return is_native or not is_used

    method resolve->Type
      if (resolved) return this
      resolved = true
      resolve_chain.add( this )

      organize

      Program.invoke_metacode( "Type.resolve", this )
      Program.invoke_metacode( "$.resolve"(name), this )

      resolve_methods

      Program.invoke_metacode( "Type.resolved", this )
      Program.invoke_metacode( "$.resolved"(name), this )

      resolve_chain.remove_last
      return this

    method resolve_methods( &final_pass )->Logical
      local resolved_any = false

      local i = 0
      while (i < global_method_list.count)
        local m = global_method_list[i]
        if (not m.resolved)
          if (final_pass) throw m.t.error( "[Internal] Unresolved method: " + m )
          m.resolve
          resolved_any = true
        endIf
        ++i
      endWhile

      i = 0
      while (i < method_list.count)
        local m = method_list[i]
        if (not m.resolved)
          if (final_pass) throw m.t.error( "[Internal] Unresolved method: " + m )
          m.resolve
          resolved_any = true
        endIf
        ++i
      endWhile

      return resolved_any


    method root_name->String
      return root_type.name

    method root_type->Type
      # This method is used to generate introspection call handlers. The mechanism
      # treats Value and String differently.
      if (this.is_reference)
        if (this is Program.type_String) return this
        if (this.instance_of(Program.type_Value)) return Program.type_Value
        return Program.type_Object
      endIf
      return this

    method should_cull->Logical
      return not is_used

    method to->String
      return name

    method trace_used_code
      if (is_used) return   # Already traced
      is_used = true
      if (is_singleton)
        local m = find_method( "init()" )
        if (m)
          m.make_essential
        endIf
      endIf

      if (element_type) element_type.trace_used_code

      forEach (base_type in base_types)
        base_type.trace_used_code
      endForEach

      forEach (s in global_list)
        s.type.trace_used_code
      endForEach

      forEach (p in property_list)
        p.type.trace_used_code
      endForEach

      forEach (r in global_method_list)
        if (r.is_essential) r.trace_used_code
      endForEach

      forEach (m in method_list)
        if (m.is_essential) m.trace_used_code
      endForEach

    method validate
      # Perform miscellaneous validation
      forEach (m in method_list) m.validate

    method is_topmost_synchronizable->Logical
      # True if we require synchronization, but no parent does
      if (base_class and base_class.is_synchronizable) return true
      return is_synchronizable
endClass
